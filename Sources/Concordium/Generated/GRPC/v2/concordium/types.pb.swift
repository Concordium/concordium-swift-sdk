// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: v2/concordium/types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Information about how open the pool is to new delegators.
enum Concordium_V2_OpenStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case openForAll // = 0
  case closedForNew // = 1
  case closedForAll // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .openForAll
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .openForAll
    case 1: self = .closedForNew
    case 2: self = .closedForAll
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .openForAll: return 0
    case .closedForNew: return 1
    case .closedForAll: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Concordium_V2_OpenStatus] = [
    .openForAll,
    .closedForNew,
    .closedForAll,
  ]

}

/// Version of smart contract.
enum Concordium_V2_ContractVersion: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case v0 // = 0
  case v1 // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .v0
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .v0
    case 1: self = .v1
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .v0: return 0
    case .v1: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Concordium_V2_ContractVersion] = [
    .v0,
    .v1,
  ]

}

/// The type of a credential.
enum Concordium_V2_CredentialType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// An initial credential created by the identity provider.
  case initial // = 0

  /// A normal credential type created by the account.
  case normal // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .initial
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .initial
    case 1: self = .normal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .initial: return 0
    case .normal: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Concordium_V2_CredentialType] = [
    .initial,
    .normal,
  ]

}

/// The type of chain update.
enum Concordium_V2_UpdateType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case updateProtocol // = 0
  case updateElectionDifficulty // = 1
  case updateEuroPerEnergy // = 2
  case updateMicroCcdPerEuro // = 3
  case updateFoundationAccount // = 4
  case updateMintDistribution // = 5
  case updateTransactionFeeDistribution // = 6
  case updateGasRewards // = 7
  case updatePoolParameters // = 8
  case addAnonymityRevoker // = 9
  case addIdentityProvider // = 10
  case updateRootKeys // = 11
  case updateLevel1Keys // = 12
  case updateLevel2Keys // = 13
  case updateCooldownParameters // = 14
  case updateTimeParameters // = 15
  case updateTimeoutParameters // = 16
  case updateMinBlockTime // = 17
  case updateBlockEnergyLimit // = 18
  case updateFinalizationCommitteeParameters // = 19
  case UNRECOGNIZED(Int)

  init() {
    self = .updateProtocol
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .updateProtocol
    case 1: self = .updateElectionDifficulty
    case 2: self = .updateEuroPerEnergy
    case 3: self = .updateMicroCcdPerEuro
    case 4: self = .updateFoundationAccount
    case 5: self = .updateMintDistribution
    case 6: self = .updateTransactionFeeDistribution
    case 7: self = .updateGasRewards
    case 8: self = .updatePoolParameters
    case 9: self = .addAnonymityRevoker
    case 10: self = .addIdentityProvider
    case 11: self = .updateRootKeys
    case 12: self = .updateLevel1Keys
    case 13: self = .updateLevel2Keys
    case 14: self = .updateCooldownParameters
    case 15: self = .updateTimeParameters
    case 16: self = .updateTimeoutParameters
    case 17: self = .updateMinBlockTime
    case 18: self = .updateBlockEnergyLimit
    case 19: self = .updateFinalizationCommitteeParameters
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .updateProtocol: return 0
    case .updateElectionDifficulty: return 1
    case .updateEuroPerEnergy: return 2
    case .updateMicroCcdPerEuro: return 3
    case .updateFoundationAccount: return 4
    case .updateMintDistribution: return 5
    case .updateTransactionFeeDistribution: return 6
    case .updateGasRewards: return 7
    case .updatePoolParameters: return 8
    case .addAnonymityRevoker: return 9
    case .addIdentityProvider: return 10
    case .updateRootKeys: return 11
    case .updateLevel1Keys: return 12
    case .updateLevel2Keys: return 13
    case .updateCooldownParameters: return 14
    case .updateTimeParameters: return 15
    case .updateTimeoutParameters: return 16
    case .updateMinBlockTime: return 17
    case .updateBlockEnergyLimit: return 18
    case .updateFinalizationCommitteeParameters: return 19
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Concordium_V2_UpdateType] = [
    .updateProtocol,
    .updateElectionDifficulty,
    .updateEuroPerEnergy,
    .updateMicroCcdPerEuro,
    .updateFoundationAccount,
    .updateMintDistribution,
    .updateTransactionFeeDistribution,
    .updateGasRewards,
    .updatePoolParameters,
    .addAnonymityRevoker,
    .addIdentityProvider,
    .updateRootKeys,
    .updateLevel1Keys,
    .updateLevel2Keys,
    .updateCooldownParameters,
    .updateTimeParameters,
    .updateTimeoutParameters,
    .updateMinBlockTime,
    .updateBlockEnergyLimit,
    .updateFinalizationCommitteeParameters,
  ]

}

/// The type of transaction.
enum Concordium_V2_TransactionType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case deployModule // = 0
  case initContract // = 1
  case update // = 2
  case transfer // = 3
  case addBaker // = 4
  case removeBaker // = 5
  case updateBakerStake // = 6
  case updateBakerRestakeEarnings // = 7
  case updateBakerKeys // = 8
  case updateCredentialKeys // = 9
  case encryptedAmountTransfer // = 10
  case transferToEncrypted // = 11
  case transferToPublic // = 12
  case transferWithSchedule // = 13
  case updateCredentials // = 14
  case registerData // = 15
  case transferWithMemo // = 16
  case encryptedAmountTransferWithMemo // = 17
  case transferWithScheduleAndMemo // = 18
  case configureBaker // = 19
  case configureDelegation // = 20
  case UNRECOGNIZED(Int)

  init() {
    self = .deployModule
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .deployModule
    case 1: self = .initContract
    case 2: self = .update
    case 3: self = .transfer
    case 4: self = .addBaker
    case 5: self = .removeBaker
    case 6: self = .updateBakerStake
    case 7: self = .updateBakerRestakeEarnings
    case 8: self = .updateBakerKeys
    case 9: self = .updateCredentialKeys
    case 10: self = .encryptedAmountTransfer
    case 11: self = .transferToEncrypted
    case 12: self = .transferToPublic
    case 13: self = .transferWithSchedule
    case 14: self = .updateCredentials
    case 15: self = .registerData
    case 16: self = .transferWithMemo
    case 17: self = .encryptedAmountTransferWithMemo
    case 18: self = .transferWithScheduleAndMemo
    case 19: self = .configureBaker
    case 20: self = .configureDelegation
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .deployModule: return 0
    case .initContract: return 1
    case .update: return 2
    case .transfer: return 3
    case .addBaker: return 4
    case .removeBaker: return 5
    case .updateBakerStake: return 6
    case .updateBakerRestakeEarnings: return 7
    case .updateBakerKeys: return 8
    case .updateCredentialKeys: return 9
    case .encryptedAmountTransfer: return 10
    case .transferToEncrypted: return 11
    case .transferToPublic: return 12
    case .transferWithSchedule: return 13
    case .updateCredentials: return 14
    case .registerData: return 15
    case .transferWithMemo: return 16
    case .encryptedAmountTransferWithMemo: return 17
    case .transferWithScheduleAndMemo: return 18
    case .configureBaker: return 19
    case .configureDelegation: return 20
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Concordium_V2_TransactionType] = [
    .deployModule,
    .initContract,
    .update,
    .transfer,
    .addBaker,
    .removeBaker,
    .updateBakerStake,
    .updateBakerRestakeEarnings,
    .updateBakerKeys,
    .updateCredentialKeys,
    .encryptedAmountTransfer,
    .transferToEncrypted,
    .transferToPublic,
    .transferWithSchedule,
    .updateCredentials,
    .registerData,
    .transferWithMemo,
    .encryptedAmountTransferWithMemo,
    .transferWithScheduleAndMemo,
    .configureBaker,
    .configureDelegation,
  ]

}

/// The different versions of the protocol.
enum Concordium_V2_ProtocolVersion: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case protocolVersion1 // = 0
  case protocolVersion2 // = 1
  case protocolVersion3 // = 2
  case protocolVersion4 // = 3
  case protocolVersion5 // = 4
  case protocolVersion6 // = 5
  case protocolVersion7 // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .protocolVersion1
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .protocolVersion1
    case 1: self = .protocolVersion2
    case 2: self = .protocolVersion3
    case 3: self = .protocolVersion4
    case 4: self = .protocolVersion5
    case 5: self = .protocolVersion6
    case 6: self = .protocolVersion7
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .protocolVersion1: return 0
    case .protocolVersion2: return 1
    case .protocolVersion3: return 2
    case .protocolVersion4: return 3
    case .protocolVersion5: return 4
    case .protocolVersion6: return 5
    case .protocolVersion7: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Concordium_V2_ProtocolVersion] = [
    .protocolVersion1,
    .protocolVersion2,
    .protocolVersion3,
    .protocolVersion4,
    .protocolVersion5,
    .protocolVersion6,
    .protocolVersion7,
  ]

}

/// A message that contains no information.
struct Concordium_V2_Empty: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Hash of a block. This is always 32 bytes long.
struct Concordium_V2_BlockHash: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A SHA256 hash. This is always 32 bytes long.
struct Concordium_V2_Sha256Hash: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Hash of a transaction. This is always 32 bytes long.
struct Concordium_V2_TransactionHash: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Hash of the state after some block. This is always 32 bytes long.
struct Concordium_V2_StateHash: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The absolute height of a block. This is the number of ancestors of a block
/// since the genesis block. In particular, the chain genesis block has absolute
/// height 0.
struct Concordium_V2_AbsoluteBlockHeight: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The height of a block relative to the last genesis. This differs from the
/// absolute block height in that it counts height from the last protocol update.
struct Concordium_V2_BlockHeight: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The ID of a baker, which is the index of its account.
struct Concordium_V2_BakerId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Index of the account in the account table. These are assigned sequentially
/// in the order of creation of accounts. The first account has index 0.
struct Concordium_V2_AccountIndex: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A smart contract module reference. This is always 32 bytes long.
struct Concordium_V2_ModuleRef: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Source bytes of a versioned smart contract module.
struct Concordium_V2_VersionedModuleSource: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var module: Concordium_V2_VersionedModuleSource.OneOf_Module? = nil

  var v0: Concordium_V2_VersionedModuleSource.ModuleSourceV0 {
    get {
      if case .v0(let v)? = module {return v}
      return Concordium_V2_VersionedModuleSource.ModuleSourceV0()
    }
    set {module = .v0(newValue)}
  }

  var v1: Concordium_V2_VersionedModuleSource.ModuleSourceV1 {
    get {
      if case .v1(let v)? = module {return v}
      return Concordium_V2_VersionedModuleSource.ModuleSourceV1()
    }
    set {module = .v1(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Module: Equatable, Sendable {
    case v0(Concordium_V2_VersionedModuleSource.ModuleSourceV0)
    case v1(Concordium_V2_VersionedModuleSource.ModuleSourceV1)

  }

  /// Source bytes of a smart contract v0 module.
  struct ModuleSourceV0: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Source bytes of a smart contract v1 module.
  struct ModuleSourceV1: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Unix timestamp in milliseconds.
struct Concordium_V2_Timestamp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An individual release of a locked balance.
struct Concordium_V2_Release: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Effective time of the release in milliseconds since unix epoch.
  var timestamp: Concordium_V2_Timestamp {
    get {return _timestamp ?? Concordium_V2_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// Amount to be released.
  var amount: Concordium_V2_Amount {
    get {return _amount ?? Concordium_V2_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  /// List of transaction hashes that contribute a balance to this release.
  var transactions: [Concordium_V2_TransactionHash] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timestamp: Concordium_V2_Timestamp? = nil
  fileprivate var _amount: Concordium_V2_Amount? = nil
}

/// A new individual release. Part of a single transfer with schedule transaction.
struct Concordium_V2_NewRelease: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Effective time of the release in milliseconds since unix epoch.
  var timestamp: Concordium_V2_Timestamp {
    get {return _timestamp ?? Concordium_V2_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// Amount to be released.
  var amount: Concordium_V2_Amount {
    get {return _amount ?? Concordium_V2_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timestamp: Concordium_V2_Timestamp? = nil
  fileprivate var _amount: Concordium_V2_Amount? = nil
}

/// State of the account's release schedule. This is the balance of the account
/// that is owned by the account, but cannot be used until the release point.
struct Concordium_V2_ReleaseSchedule: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Total amount locked in the release schedule.
  var total: Concordium_V2_Amount {
    get {return _total ?? Concordium_V2_Amount()}
    set {_total = newValue}
  }
  /// Returns true if `total` has been explicitly set.
  var hasTotal: Bool {return self._total != nil}
  /// Clears the value of `total`. Subsequent reads from it will return its default value.
  mutating func clearTotal() {self._total = nil}

  /// A list of releases, ordered by increasing timestamp.
  var schedules: [Concordium_V2_Release] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _total: Concordium_V2_Amount? = nil
}

/// An encrypted amount, in two chunks in "little endian limbs". That is, the
/// first chunk represents the low 32 bits of an amount, and the second chunk
/// represents the high 32 bits. The chunks are serialized in order and
/// represented as a byte array.
/// Always 192 bytes.
struct Concordium_V2_EncryptedAmount: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Concordium_V2_EncryptedBalance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Encrypted amount that is a result of this account's actions.
  /// In particular this list includes the aggregate of
  ///
  /// - remaining amounts that result when transferring to public balance
  /// - remaining amounts when transferring to another account
  /// - encrypted amounts that are transferred from public balance
  ///
  /// When a transfer is made all of these must always be used.
  var selfAmount: Concordium_V2_EncryptedAmount {
    get {return _selfAmount ?? Concordium_V2_EncryptedAmount()}
    set {_selfAmount = newValue}
  }
  /// Returns true if `selfAmount` has been explicitly set.
  var hasSelfAmount: Bool {return self._selfAmount != nil}
  /// Clears the value of `selfAmount`. Subsequent reads from it will return its default value.
  mutating func clearSelfAmount() {self._selfAmount = nil}

  /// Starting index for incoming encrypted amounts. If an aggregated amount
  /// is present then this index is associated with such an amount and the
  /// list of incoming encrypted amounts starts at the index `start_index
  /// + 1`.
  var startIndex: UInt64 = 0

  /// If present, the amount that has resulted from aggregating other amounts
  /// If this field is present so is `num_aggregated`.
  var aggregatedAmount: Concordium_V2_EncryptedAmount {
    get {return _aggregatedAmount ?? Concordium_V2_EncryptedAmount()}
    set {_aggregatedAmount = newValue}
  }
  /// Returns true if `aggregatedAmount` has been explicitly set.
  var hasAggregatedAmount: Bool {return self._aggregatedAmount != nil}
  /// Clears the value of `aggregatedAmount`. Subsequent reads from it will return its default value.
  mutating func clearAggregatedAmount() {self._aggregatedAmount = nil}

  /// The number of aggregated amounts (must be at least 2 if present). This
  /// field is present if and only if `aggregated_amount` is present.
  var numAggregated: UInt32 {
    get {return _numAggregated ?? 0}
    set {_numAggregated = newValue}
  }
  /// Returns true if `numAggregated` has been explicitly set.
  var hasNumAggregated: Bool {return self._numAggregated != nil}
  /// Clears the value of `numAggregated`. Subsequent reads from it will return its default value.
  mutating func clearNumAggregated() {self._numAggregated = nil}

  /// Amounts starting at `start_index` (or at `start_index + 1` if there is
  /// an aggregated amount present). They are assumed to be numbered
  /// sequentially. The length of this list is bounded by the maximum number
  /// of incoming amounts on the accounts, which is currently 32. After
  /// that aggregation kicks in.
  var incomingAmounts: [Concordium_V2_EncryptedAmount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _selfAmount: Concordium_V2_EncryptedAmount? = nil
  fileprivate var _aggregatedAmount: Concordium_V2_EncryptedAmount? = nil
  fileprivate var _numAggregated: UInt32? = nil
}

/// Entity to which the account delegates a portion of its stake.
struct Concordium_V2_DelegationTarget: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var target: Concordium_V2_DelegationTarget.OneOf_Target? = nil

  /// Delegate passively, i.e., to no specific baker.
  var passive: Concordium_V2_Empty {
    get {
      if case .passive(let v)? = target {return v}
      return Concordium_V2_Empty()
    }
    set {target = .passive(newValue)}
  }

  /// Delegate to a specific baker.
  var baker: Concordium_V2_BakerId {
    get {
      if case .baker(let v)? = target {return v}
      return Concordium_V2_BakerId()
    }
    set {target = .baker(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Target: Equatable, Sendable {
    /// Delegate passively, i.e., to no specific baker.
    case passive(Concordium_V2_Empty)
    /// Delegate to a specific baker.
    case baker(Concordium_V2_BakerId)

  }

  init() {}
}

/// Baker's public key used to check whether they won the lottery or not.
struct Concordium_V2_BakerElectionVerifyKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Baker's public key used to check that they are indeed the ones who
/// produced the block.
struct Concordium_V2_BakerSignatureVerifyKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Baker's public key used to check signatures on finalization records.
/// This is only used if the baker has sufficient stake to participate in
/// finalization.
struct Concordium_V2_BakerAggregationVerifyKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information about a baker.
struct Concordium_V2_BakerInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identity of the baker. This is actually the account index of
  /// the account controlling the baker.
  var bakerID: Concordium_V2_BakerId {
    get {return _bakerID ?? Concordium_V2_BakerId()}
    set {_bakerID = newValue}
  }
  /// Returns true if `bakerID` has been explicitly set.
  var hasBakerID: Bool {return self._bakerID != nil}
  /// Clears the value of `bakerID`. Subsequent reads from it will return its default value.
  mutating func clearBakerID() {self._bakerID = nil}

  /// Baker's public key used to check whether they won the lottery or not.
  var electionKey: Concordium_V2_BakerElectionVerifyKey {
    get {return _electionKey ?? Concordium_V2_BakerElectionVerifyKey()}
    set {_electionKey = newValue}
  }
  /// Returns true if `electionKey` has been explicitly set.
  var hasElectionKey: Bool {return self._electionKey != nil}
  /// Clears the value of `electionKey`. Subsequent reads from it will return its default value.
  mutating func clearElectionKey() {self._electionKey = nil}

  /// Baker's public key used to check that they are indeed the ones who
  /// produced the block.
  var signatureKey: Concordium_V2_BakerSignatureVerifyKey {
    get {return _signatureKey ?? Concordium_V2_BakerSignatureVerifyKey()}
    set {_signatureKey = newValue}
  }
  /// Returns true if `signatureKey` has been explicitly set.
  var hasSignatureKey: Bool {return self._signatureKey != nil}
  /// Clears the value of `signatureKey`. Subsequent reads from it will return its default value.
  mutating func clearSignatureKey() {self._signatureKey = nil}

  /// Baker's public key used to check signatures on finalization records.
  /// This is only used if the baker has sufficient stake to participate in
  /// finalization.
  var aggregationKey: Concordium_V2_BakerAggregationVerifyKey {
    get {return _aggregationKey ?? Concordium_V2_BakerAggregationVerifyKey()}
    set {_aggregationKey = newValue}
  }
  /// Returns true if `aggregationKey` has been explicitly set.
  var hasAggregationKey: Bool {return self._aggregationKey != nil}
  /// Clears the value of `aggregationKey`. Subsequent reads from it will return its default value.
  mutating func clearAggregationKey() {self._aggregationKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bakerID: Concordium_V2_BakerId? = nil
  fileprivate var _electionKey: Concordium_V2_BakerElectionVerifyKey? = nil
  fileprivate var _signatureKey: Concordium_V2_BakerSignatureVerifyKey? = nil
  fileprivate var _aggregationKey: Concordium_V2_BakerAggregationVerifyKey? = nil
}

/// Pending change to the stake either of a baker or delegator.
struct Concordium_V2_StakePendingChange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var change: Concordium_V2_StakePendingChange.OneOf_Change? = nil

  var reduce: Concordium_V2_StakePendingChange.Reduce {
    get {
      if case .reduce(let v)? = change {return v}
      return Concordium_V2_StakePendingChange.Reduce()
    }
    set {change = .reduce(newValue)}
  }

  /// Remove the stake. The value is a Unix timestamp of the effective time in
  /// milliseconds.
  var remove: Concordium_V2_Timestamp {
    get {
      if case .remove(let v)? = change {return v}
      return Concordium_V2_Timestamp()
    }
    set {change = .remove(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Change: Equatable, Sendable {
    case reduce(Concordium_V2_StakePendingChange.Reduce)
    /// Remove the stake. The value is a Unix timestamp of the effective time in
    /// milliseconds.
    case remove(Concordium_V2_Timestamp)

  }

  struct Reduce: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var newStake: Concordium_V2_Amount {
      get {return _newStake ?? Concordium_V2_Amount()}
      set {_newStake = newValue}
    }
    /// Returns true if `newStake` has been explicitly set.
    var hasNewStake: Bool {return self._newStake != nil}
    /// Clears the value of `newStake`. Subsequent reads from it will return its default value.
    mutating func clearNewStake() {self._newStake = nil}

    /// Unix timestamp in milliseconds when the change takes effect.
    var effectiveTime: Concordium_V2_Timestamp {
      get {return _effectiveTime ?? Concordium_V2_Timestamp()}
      set {_effectiveTime = newValue}
    }
    /// Returns true if `effectiveTime` has been explicitly set.
    var hasEffectiveTime: Bool {return self._effectiveTime != nil}
    /// Clears the value of `effectiveTime`. Subsequent reads from it will return its default value.
    mutating func clearEffectiveTime() {self._effectiveTime = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _newStake: Concordium_V2_Amount? = nil
    fileprivate var _effectiveTime: Concordium_V2_Timestamp? = nil
  }

  init() {}
}

/// A fraction of an amount with a precision of `1/100_000`.
struct Concordium_V2_AmountFraction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Must not exceed 100000.
  var partsPerHundredThousand: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Distribution of the rewards for the particular pool.
struct Concordium_V2_CommissionRates: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Fraction of finalization rewards charged by the pool owner.
  var finalization: Concordium_V2_AmountFraction {
    get {return _finalization ?? Concordium_V2_AmountFraction()}
    set {_finalization = newValue}
  }
  /// Returns true if `finalization` has been explicitly set.
  var hasFinalization: Bool {return self._finalization != nil}
  /// Clears the value of `finalization`. Subsequent reads from it will return its default value.
  mutating func clearFinalization() {self._finalization = nil}

  /// Fraction of baking rewards charged by the pool owner.
  var baking: Concordium_V2_AmountFraction {
    get {return _baking ?? Concordium_V2_AmountFraction()}
    set {_baking = newValue}
  }
  /// Returns true if `baking` has been explicitly set.
  var hasBaking: Bool {return self._baking != nil}
  /// Clears the value of `baking`. Subsequent reads from it will return its default value.
  mutating func clearBaking() {self._baking = nil}

  /// Fraction of transaction rewards charged by the pool owner.
  var transaction: Concordium_V2_AmountFraction {
    get {return _transaction ?? Concordium_V2_AmountFraction()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  mutating func clearTransaction() {self._transaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _finalization: Concordium_V2_AmountFraction? = nil
  fileprivate var _baking: Concordium_V2_AmountFraction? = nil
  fileprivate var _transaction: Concordium_V2_AmountFraction? = nil
}

/// Additional information about a baking pool.
/// This information is added with the introduction of delegation.
struct Concordium_V2_BakerPoolInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the pool allows delegators.
  var openStatus: Concordium_V2_OpenStatus = .openForAll

  /// The URL that links to the metadata about the pool.
  var url: String = String()

  /// The commission rates charged by the pool owner.
  var commissionRates: Concordium_V2_CommissionRates {
    get {return _commissionRates ?? Concordium_V2_CommissionRates()}
    set {_commissionRates = newValue}
  }
  /// Returns true if `commissionRates` has been explicitly set.
  var hasCommissionRates: Bool {return self._commissionRates != nil}
  /// Clears the value of `commissionRates`. Subsequent reads from it will return its default value.
  mutating func clearCommissionRates() {self._commissionRates = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commissionRates: Concordium_V2_CommissionRates? = nil
}

/// Information about the account stake, if the account is either a baker or a
/// delegator.
struct Concordium_V2_AccountStakingInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stakingInfo: Concordium_V2_AccountStakingInfo.OneOf_StakingInfo? = nil

  /// The account is a baker.
  var baker: Concordium_V2_AccountStakingInfo.Baker {
    get {
      if case .baker(let v)? = stakingInfo {return v}
      return Concordium_V2_AccountStakingInfo.Baker()
    }
    set {stakingInfo = .baker(newValue)}
  }

  /// The account is a delegator.
  var delegator: Concordium_V2_AccountStakingInfo.Delegator {
    get {
      if case .delegator(let v)? = stakingInfo {return v}
      return Concordium_V2_AccountStakingInfo.Delegator()
    }
    set {stakingInfo = .delegator(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_StakingInfo: Equatable, Sendable {
    /// The account is a baker.
    case baker(Concordium_V2_AccountStakingInfo.Baker)
    /// The account is a delegator.
    case delegator(Concordium_V2_AccountStakingInfo.Delegator)

  }

  struct Baker: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Amount staked at present.
    var stakedAmount: Concordium_V2_Amount {
      get {return _stakedAmount ?? Concordium_V2_Amount()}
      set {_stakedAmount = newValue}
    }
    /// Returns true if `stakedAmount` has been explicitly set.
    var hasStakedAmount: Bool {return self._stakedAmount != nil}
    /// Clears the value of `stakedAmount`. Subsequent reads from it will return its default value.
    mutating func clearStakedAmount() {self._stakedAmount = nil}

    /// A flag indicating whether rewards paid to the baker are automatically
    /// restaked or not.
    var restakeEarnings: Bool = false

    /// Information about the baker that is staking.
    var bakerInfo: Concordium_V2_BakerInfo {
      get {return _bakerInfo ?? Concordium_V2_BakerInfo()}
      set {_bakerInfo = newValue}
    }
    /// Returns true if `bakerInfo` has been explicitly set.
    var hasBakerInfo: Bool {return self._bakerInfo != nil}
    /// Clears the value of `bakerInfo`. Subsequent reads from it will return its default value.
    mutating func clearBakerInfo() {self._bakerInfo = nil}

    /// If present, any pending change to the delegated stake.
    var pendingChange: Concordium_V2_StakePendingChange {
      get {return _pendingChange ?? Concordium_V2_StakePendingChange()}
      set {_pendingChange = newValue}
    }
    /// Returns true if `pendingChange` has been explicitly set.
    var hasPendingChange: Bool {return self._pendingChange != nil}
    /// Clears the value of `pendingChange`. Subsequent reads from it will return its default value.
    mutating func clearPendingChange() {self._pendingChange = nil}

    /// Present if the account is currently a baker, i.e., it is in the baking
    /// committee of the current epoch.
    var poolInfo: Concordium_V2_BakerPoolInfo {
      get {return _poolInfo ?? Concordium_V2_BakerPoolInfo()}
      set {_poolInfo = newValue}
    }
    /// Returns true if `poolInfo` has been explicitly set.
    var hasPoolInfo: Bool {return self._poolInfo != nil}
    /// Clears the value of `poolInfo`. Subsequent reads from it will return its default value.
    mutating func clearPoolInfo() {self._poolInfo = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _stakedAmount: Concordium_V2_Amount? = nil
    fileprivate var _bakerInfo: Concordium_V2_BakerInfo? = nil
    fileprivate var _pendingChange: Concordium_V2_StakePendingChange? = nil
    fileprivate var _poolInfo: Concordium_V2_BakerPoolInfo? = nil
  }

  struct Delegator: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The amount that the account delegates.
    var stakedAmount: Concordium_V2_Amount {
      get {return _stakedAmount ?? Concordium_V2_Amount()}
      set {_stakedAmount = newValue}
    }
    /// Returns true if `stakedAmount` has been explicitly set.
    var hasStakedAmount: Bool {return self._stakedAmount != nil}
    /// Clears the value of `stakedAmount`. Subsequent reads from it will return its default value.
    mutating func clearStakedAmount() {self._stakedAmount = nil}

    /// Whether the earnings are automatically added to the staked amount.
    var restakeEarnings: Bool = false

    /// The entity to which the account delegates.
    var target: Concordium_V2_DelegationTarget {
      get {return _target ?? Concordium_V2_DelegationTarget()}
      set {_target = newValue}
    }
    /// Returns true if `target` has been explicitly set.
    var hasTarget: Bool {return self._target != nil}
    /// Clears the value of `target`. Subsequent reads from it will return its default value.
    mutating func clearTarget() {self._target = nil}

    /// If present, any pending change to the delegated stake.
    var pendingChange: Concordium_V2_StakePendingChange {
      get {return _pendingChange ?? Concordium_V2_StakePendingChange()}
      set {_pendingChange = newValue}
    }
    /// Returns true if `pendingChange` has been explicitly set.
    var hasPendingChange: Bool {return self._pendingChange != nil}
    /// Clears the value of `pendingChange`. Subsequent reads from it will return its default value.
    mutating func clearPendingChange() {self._pendingChange = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _stakedAmount: Concordium_V2_Amount? = nil
    fileprivate var _target: Concordium_V2_DelegationTarget? = nil
    fileprivate var _pendingChange: Concordium_V2_StakePendingChange? = nil
  }

  init() {}
}

/// A sequence number that determines the ordering of transactions from the
/// account. The minimum sequence number is 1.
struct Concordium_V2_SequenceNumber: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The sequence number.
  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A sequence number that determines the ordering of update transactions.
/// Equivalent to `SequenceNumber` for account transactions.
/// Update sequence numbers are per update type and the minimum value is 1.
struct Concordium_V2_UpdateSequenceNumber: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The sequence number.
  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An amount of microCCD.
struct Concordium_V2_Amount: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Index of a credential on an account.
struct Concordium_V2_CredentialIndex: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The number of signatures required to sign.
struct Concordium_V2_SignatureThreshold: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The number of credentials required to sign an account transaction.
struct Concordium_V2_AccountThreshold: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An account encryption key. Always 96 bytes.
struct Concordium_V2_EncryptionKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An address of an account. Always 32 bytes.
struct Concordium_V2_AccountAddress: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An address of either a contract or an account.
struct Concordium_V2_Address: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Concordium_V2_Address.OneOf_Type? = nil

  var account: Concordium_V2_AccountAddress {
    get {
      if case .account(let v)? = type {return v}
      return Concordium_V2_AccountAddress()
    }
    set {type = .account(newValue)}
  }

  var contract: Concordium_V2_ContractAddress {
    get {
      if case .contract(let v)? = type {return v}
      return Concordium_V2_ContractAddress()
    }
    set {type = .contract(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    case account(Concordium_V2_AccountAddress)
    case contract(Concordium_V2_ContractAddress)

  }

  init() {}
}

/// A public key used to verify transaction signatures from an account.
struct Concordium_V2_AccountVerifyKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: Concordium_V2_AccountVerifyKey.OneOf_Key? = nil

  var ed25519Key: Data {
    get {
      if case .ed25519Key(let v)? = key {return v}
      return Data()
    }
    set {key = .ed25519Key(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Key: Equatable, @unchecked Sendable {
    case ed25519Key(Data)

  }

  init() {}
}

/// Public keys of a single credential.
struct Concordium_V2_CredentialPublicKeys: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keys: Dictionary<UInt32,Concordium_V2_AccountVerifyKey> = [:]

  var threshold: Concordium_V2_SignatureThreshold {
    get {return _threshold ?? Concordium_V2_SignatureThreshold()}
    set {_threshold = newValue}
  }
  /// Returns true if `threshold` has been explicitly set.
  var hasThreshold: Bool {return self._threshold != nil}
  /// Clears the value of `threshold`. Subsequent reads from it will return its default value.
  mutating func clearThreshold() {self._threshold = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _threshold: Concordium_V2_SignatureThreshold? = nil
}

/// A registration ID of a credential, derived from the secret PRF key and a
/// nonce. This is always 48 bytes long.
struct Concordium_V2_CredentialRegistrationId: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An index of the identity provider that identifies them uniquely in the
/// context of a specific chain.
struct Concordium_V2_IdentityProviderIdentity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Representation of the pair of a year and month.
struct Concordium_V2_YearMonth: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var year: UInt32 = 0

  var month: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Policy on a credential.
struct Concordium_V2_Policy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The year and month when the identity object from which the credential is
  /// derived was created.
  var createdAt: Concordium_V2_YearMonth {
    get {return _createdAt ?? Concordium_V2_YearMonth()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  /// The last year and month when the credential is still valid. After this
  /// expires an account can no longer be created from the credential.
  var validTo: Concordium_V2_YearMonth {
    get {return _validTo ?? Concordium_V2_YearMonth()}
    set {_validTo = newValue}
  }
  /// Returns true if `validTo` has been explicitly set.
  var hasValidTo: Bool {return self._validTo != nil}
  /// Clears the value of `validTo`. Subsequent reads from it will return its default value.
  mutating func clearValidTo() {self._validTo = nil}

  /// Mapping from attribute tags to attribute values. Attribute tags are always
  /// representable in a single `u8`, attribute values are never more than 31
  /// bytes in length.
  var attributes: Dictionary<UInt32,Data> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: Concordium_V2_YearMonth? = nil
  fileprivate var _validTo: Concordium_V2_YearMonth? = nil
}

/// Values contained in an initial credential.
struct Concordium_V2_InitialCredentialValues: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Public keys of the credential.
  var keys: Concordium_V2_CredentialPublicKeys {
    get {return _keys ?? Concordium_V2_CredentialPublicKeys()}
    set {_keys = newValue}
  }
  /// Returns true if `keys` has been explicitly set.
  var hasKeys: Bool {return self._keys != nil}
  /// Clears the value of `keys`. Subsequent reads from it will return its default value.
  mutating func clearKeys() {self._keys = nil}

  /// Its registration ID.
  var credID: Concordium_V2_CredentialRegistrationId {
    get {return _credID ?? Concordium_V2_CredentialRegistrationId()}
    set {_credID = newValue}
  }
  /// Returns true if `credID` has been explicitly set.
  var hasCredID: Bool {return self._credID != nil}
  /// Clears the value of `credID`. Subsequent reads from it will return its default value.
  mutating func clearCredID() {self._credID = nil}

  /// The identity provider who signed the identity object from which this
  /// credential is derived.
  var ipID: Concordium_V2_IdentityProviderIdentity {
    get {return _ipID ?? Concordium_V2_IdentityProviderIdentity()}
    set {_ipID = newValue}
  }
  /// Returns true if `ipID` has been explicitly set.
  var hasIpID: Bool {return self._ipID != nil}
  /// Clears the value of `ipID`. Subsequent reads from it will return its default value.
  mutating func clearIpID() {self._ipID = nil}

  /// Policy of this credential.
  var policy: Concordium_V2_Policy {
    get {return _policy ?? Concordium_V2_Policy()}
    set {_policy = newValue}
  }
  /// Returns true if `policy` has been explicitly set.
  var hasPolicy: Bool {return self._policy != nil}
  /// Clears the value of `policy`. Subsequent reads from it will return its default value.
  mutating func clearPolicy() {self._policy = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keys: Concordium_V2_CredentialPublicKeys? = nil
  fileprivate var _credID: Concordium_V2_CredentialRegistrationId? = nil
  fileprivate var _ipID: Concordium_V2_IdentityProviderIdentity? = nil
  fileprivate var _policy: Concordium_V2_Policy? = nil
}

/// Data relating to a single anonymity revoker sent by the account holder to
/// the chain.
struct Concordium_V2_ChainArData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Share of the encryption of IdCredPub.
  var encIDCredPubShare: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The number of anonymity revokers needed to revoke anonymity of a credential
/// holder.
struct Concordium_V2_ArThreshold: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A single commitment in the G1 group of the BLS curve. This is always 48 bytes
/// in length.
struct Concordium_V2_Commitment: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Commitments that are part of a normal credential.
struct Concordium_V2_CredentialCommitments: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Commitment to the PRF key.
  var prf: Concordium_V2_Commitment {
    get {return _prf ?? Concordium_V2_Commitment()}
    set {_prf = newValue}
  }
  /// Returns true if `prf` has been explicitly set.
  var hasPrf: Bool {return self._prf != nil}
  /// Clears the value of `prf`. Subsequent reads from it will return its default value.
  mutating func clearPrf() {self._prf = nil}

  /// Commitment to the counter used to generate the credential registration id.
  var credCounter: Concordium_V2_Commitment {
    get {return _credCounter ?? Concordium_V2_Commitment()}
    set {_credCounter = newValue}
  }
  /// Returns true if `credCounter` has been explicitly set.
  var hasCredCounter: Bool {return self._credCounter != nil}
  /// Clears the value of `credCounter`. Subsequent reads from it will return its default value.
  mutating func clearCredCounter() {self._credCounter = nil}

  /// Commitment to the `max_accounts` value, which determines the maximum number
  /// of credentials that may be created from the identity object.
  var maxAccounts: Concordium_V2_Commitment {
    get {return _maxAccounts ?? Concordium_V2_Commitment()}
    set {_maxAccounts = newValue}
  }
  /// Returns true if `maxAccounts` has been explicitly set.
  var hasMaxAccounts: Bool {return self._maxAccounts != nil}
  /// Clears the value of `maxAccounts`. Subsequent reads from it will return its default value.
  mutating func clearMaxAccounts() {self._maxAccounts = nil}

  /// Commitments to the attributes which have not been revealed in the policy.
  var attributes: Dictionary<UInt32,Concordium_V2_Commitment> = [:]

  /// List of commitments to the coefficients of the sharing polynomial. This
  /// polynomial is used in a shared encryption of `id_cred_pub` among the
  /// anonymity revokers.
  var idCredSecSharingCoeff: [Concordium_V2_Commitment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _prf: Concordium_V2_Commitment? = nil
  fileprivate var _credCounter: Concordium_V2_Commitment? = nil
  fileprivate var _maxAccounts: Concordium_V2_Commitment? = nil
}

/// Values contained in a normal (non-initial) credential.
struct Concordium_V2_NormalCredentialValues: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Public keys of the credential.
  var keys: Concordium_V2_CredentialPublicKeys {
    get {return _keys ?? Concordium_V2_CredentialPublicKeys()}
    set {_keys = newValue}
  }
  /// Returns true if `keys` has been explicitly set.
  var hasKeys: Bool {return self._keys != nil}
  /// Clears the value of `keys`. Subsequent reads from it will return its default value.
  mutating func clearKeys() {self._keys = nil}

  /// Its registration ID.
  var credID: Concordium_V2_CredentialRegistrationId {
    get {return _credID ?? Concordium_V2_CredentialRegistrationId()}
    set {_credID = newValue}
  }
  /// Returns true if `credID` has been explicitly set.
  var hasCredID: Bool {return self._credID != nil}
  /// Clears the value of `credID`. Subsequent reads from it will return its default value.
  mutating func clearCredID() {self._credID = nil}

  /// The identity provider who signed the identity object from which this
  /// credential is derived.
  var ipID: Concordium_V2_IdentityProviderIdentity {
    get {return _ipID ?? Concordium_V2_IdentityProviderIdentity()}
    set {_ipID = newValue}
  }
  /// Returns true if `ipID` has been explicitly set.
  var hasIpID: Bool {return self._ipID != nil}
  /// Clears the value of `ipID`. Subsequent reads from it will return its default value.
  mutating func clearIpID() {self._ipID = nil}

  /// Policy of this credential.
  var policy: Concordium_V2_Policy {
    get {return _policy ?? Concordium_V2_Policy()}
    set {_policy = newValue}
  }
  /// Returns true if `policy` has been explicitly set.
  var hasPolicy: Bool {return self._policy != nil}
  /// Clears the value of `policy`. Subsequent reads from it will return its default value.
  mutating func clearPolicy() {self._policy = nil}

  /// The number of anonymity revokers that must work together to revoke the
  /// anonymity of the credential holder.
  var arThreshold: Concordium_V2_ArThreshold {
    get {return _arThreshold ?? Concordium_V2_ArThreshold()}
    set {_arThreshold = newValue}
  }
  /// Returns true if `arThreshold` has been explicitly set.
  var hasArThreshold: Bool {return self._arThreshold != nil}
  /// Clears the value of `arThreshold`. Subsequent reads from it will return its default value.
  mutating func clearArThreshold() {self._arThreshold = nil}

  /// Mapping from anonymity revoker identities to revocation data for the given anonymity revoker.
  var arData: Dictionary<UInt32,Concordium_V2_ChainArData> = [:]

  /// Commitments to attributes which have not been revealed.
  var commitments: Concordium_V2_CredentialCommitments {
    get {return _commitments ?? Concordium_V2_CredentialCommitments()}
    set {_commitments = newValue}
  }
  /// Returns true if `commitments` has been explicitly set.
  var hasCommitments: Bool {return self._commitments != nil}
  /// Clears the value of `commitments`. Subsequent reads from it will return its default value.
  mutating func clearCommitments() {self._commitments = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keys: Concordium_V2_CredentialPublicKeys? = nil
  fileprivate var _credID: Concordium_V2_CredentialRegistrationId? = nil
  fileprivate var _ipID: Concordium_V2_IdentityProviderIdentity? = nil
  fileprivate var _policy: Concordium_V2_Policy? = nil
  fileprivate var _arThreshold: Concordium_V2_ArThreshold? = nil
  fileprivate var _commitments: Concordium_V2_CredentialCommitments? = nil
}

/// Credential that is part of an account.
struct Concordium_V2_AccountCredential: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var credentialValues: Concordium_V2_AccountCredential.OneOf_CredentialValues? = nil

  var initial: Concordium_V2_InitialCredentialValues {
    get {
      if case .initial(let v)? = credentialValues {return v}
      return Concordium_V2_InitialCredentialValues()
    }
    set {credentialValues = .initial(newValue)}
  }

  var normal: Concordium_V2_NormalCredentialValues {
    get {
      if case .normal(let v)? = credentialValues {return v}
      return Concordium_V2_NormalCredentialValues()
    }
    set {credentialValues = .normal(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_CredentialValues: Equatable, Sendable {
    case initial(Concordium_V2_InitialCredentialValues)
    case normal(Concordium_V2_NormalCredentialValues)

  }

  init() {}
}

struct Concordium_V2_Cooldown: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time in milliseconds since the Unix epoch when the cooldown period
  /// ends.
  var endTime: Concordium_V2_Timestamp {
    get {return _endTime ?? Concordium_V2_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {self._endTime = nil}

  /// The amount that is in cooldown and set to be released at the end of the
  /// cooldown period.
  var amount: Concordium_V2_Amount {
    get {return _amount ?? Concordium_V2_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  /// The status of the cooldown.
  var status: Concordium_V2_Cooldown.CooldownStatus = .cooldown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The status of a cooldown. When stake is removed from a baker or delegator
  /// (from protocol version 7) it first enters the pre-pre-cooldown state.
  /// The next time the stake snaphot is taken (at the epoch transition before
  /// a payday) it enters the pre-cooldown state. At the subsequent payday, it
  /// enters the cooldown state. At the payday after the end of the cooldown
  /// period, the stake is finally released.
  enum CooldownStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int

    /// The amount is in cooldown and will expire at the specified time, becoming available
    /// at the subsequent pay day.
    case cooldown // = 0

    /// The amount will enter cooldown at the next pay day. The specified end time is
    /// projected to be the end of the cooldown period, but the actual end time will be
    /// determined at the payday, and may be different if the global cooldown period
    /// changes.
    case preCooldown // = 1

    /// The amount will enter pre-cooldown at the next snapshot epoch (i.e. the epoch
    /// transition before a pay day transition). As with pre-cooldown, the specified
    /// end time is projected, but the actual end time will be determined later.
    case prePreCooldown // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .cooldown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cooldown
      case 1: self = .preCooldown
      case 2: self = .prePreCooldown
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .cooldown: return 0
      case .preCooldown: return 1
      case .prePreCooldown: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Concordium_V2_Cooldown.CooldownStatus] = [
      .cooldown,
      .preCooldown,
      .prePreCooldown,
    ]

  }

  init() {}

  fileprivate var _endTime: Concordium_V2_Timestamp? = nil
  fileprivate var _amount: Concordium_V2_Amount? = nil
}

/// Information about the account at a particular point in time.
struct Concordium_V2_AccountInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Next sequence number to be used for transactions signed from this account.
  var sequenceNumber: Concordium_V2_SequenceNumber {
    get {return _storage._sequenceNumber ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._sequenceNumber = newValue}
  }
  /// Returns true if `sequenceNumber` has been explicitly set.
  var hasSequenceNumber: Bool {return _storage._sequenceNumber != nil}
  /// Clears the value of `sequenceNumber`. Subsequent reads from it will return its default value.
  mutating func clearSequenceNumber() {_uniqueStorage()._sequenceNumber = nil}

  /// Current (unencrypted) balance of the account.
  var amount: Concordium_V2_Amount {
    get {return _storage._amount ?? Concordium_V2_Amount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {_uniqueStorage()._amount = nil}

  /// Release schedule for any locked up amount. This could be an empty
  /// release schedule.
  var schedule: Concordium_V2_ReleaseSchedule {
    get {return _storage._schedule ?? Concordium_V2_ReleaseSchedule()}
    set {_uniqueStorage()._schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  var hasSchedule: Bool {return _storage._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  mutating func clearSchedule() {_uniqueStorage()._schedule = nil}

  /// Map of all currently active credentials on the account.
  /// This includes public keys that can sign for the given credentials, as
  /// well as any revealed attributes. This map always contains a credential
  /// with index 0.
  var creds: Dictionary<UInt32,Concordium_V2_AccountCredential> {
    get {return _storage._creds}
    set {_uniqueStorage()._creds = newValue}
  }

  /// Lower bound on how many credentials must sign any given transaction from
  /// this account.
  var threshold: Concordium_V2_AccountThreshold {
    get {return _storage._threshold ?? Concordium_V2_AccountThreshold()}
    set {_uniqueStorage()._threshold = newValue}
  }
  /// Returns true if `threshold` has been explicitly set.
  var hasThreshold: Bool {return _storage._threshold != nil}
  /// Clears the value of `threshold`. Subsequent reads from it will return its default value.
  mutating func clearThreshold() {_uniqueStorage()._threshold = nil}

  /// The encrypted balance of the account.
  var encryptedBalance: Concordium_V2_EncryptedBalance {
    get {return _storage._encryptedBalance ?? Concordium_V2_EncryptedBalance()}
    set {_uniqueStorage()._encryptedBalance = newValue}
  }
  /// Returns true if `encryptedBalance` has been explicitly set.
  var hasEncryptedBalance: Bool {return _storage._encryptedBalance != nil}
  /// Clears the value of `encryptedBalance`. Subsequent reads from it will return its default value.
  mutating func clearEncryptedBalance() {_uniqueStorage()._encryptedBalance = nil}

  /// The public key for sending encrypted balances to the account.
  var encryptionKey: Concordium_V2_EncryptionKey {
    get {return _storage._encryptionKey ?? Concordium_V2_EncryptionKey()}
    set {_uniqueStorage()._encryptionKey = newValue}
  }
  /// Returns true if `encryptionKey` has been explicitly set.
  var hasEncryptionKey: Bool {return _storage._encryptionKey != nil}
  /// Clears the value of `encryptionKey`. Subsequent reads from it will return its default value.
  mutating func clearEncryptionKey() {_uniqueStorage()._encryptionKey = nil}

  /// Internal index of the account. Accounts on the chain get sequential
  /// indices. These should generally not be used outside of the chain,
  /// the account address is meant to be used to refer to accounts,
  /// however the account index serves the role of the baker id, if the
  /// account is a baker. Hence it is exposed here as well.
  var index: Concordium_V2_AccountIndex {
    get {return _storage._index ?? Concordium_V2_AccountIndex()}
    set {_uniqueStorage()._index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  var hasIndex: Bool {return _storage._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  mutating func clearIndex() {_uniqueStorage()._index = nil}

  /// Present if the account is a baker or delegator. In that case
  /// it is the information about the baker or delegator.
  var stake: Concordium_V2_AccountStakingInfo {
    get {return _storage._stake ?? Concordium_V2_AccountStakingInfo()}
    set {_uniqueStorage()._stake = newValue}
  }
  /// Returns true if `stake` has been explicitly set.
  var hasStake: Bool {return _storage._stake != nil}
  /// Clears the value of `stake`. Subsequent reads from it will return its default value.
  mutating func clearStake() {_uniqueStorage()._stake = nil}

  /// Canonical address of the account. This is derived from the first credential
  /// that created the account.
  var address: Concordium_V2_AccountAddress {
    get {return _storage._address ?? Concordium_V2_AccountAddress()}
    set {_uniqueStorage()._address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return _storage._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {_uniqueStorage()._address = nil}

  /// The stake on the account that is in cooldown.
  /// There can be multiple amounts in cooldown that expire at different times.
  /// This was introduced in protocol version 7, and so is not present in
  /// earlier protocol versions.
  var cooldowns: [Concordium_V2_Cooldown] {
    get {return _storage._cooldowns}
    set {_uniqueStorage()._cooldowns = newValue}
  }

  /// The available (unencrypted) balance of the account (i.e. that can be transferred
  /// or used to pay for transactions). This is the balance minus the locked amount.
  /// The locked amount is the maximum of the amount in the release schedule and
  /// the total amount that is actively staked or in cooldown (inactive stake).
  /// This was introduced in node version 7.0.
  var availableBalance: Concordium_V2_Amount {
    get {return _storage._availableBalance ?? Concordium_V2_Amount()}
    set {_uniqueStorage()._availableBalance = newValue}
  }
  /// Returns true if `availableBalance` has been explicitly set.
  var hasAvailableBalance: Bool {return _storage._availableBalance != nil}
  /// Clears the value of `availableBalance`. Subsequent reads from it will return its default value.
  mutating func clearAvailableBalance() {_uniqueStorage()._availableBalance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Input to queries which take a block as a parameter.
struct Concordium_V2_BlockHashInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockHashInput: Concordium_V2_BlockHashInput.OneOf_BlockHashInput? = nil

  /// Query for the best block.
  var best: Concordium_V2_Empty {
    get {
      if case .best(let v)? = blockHashInput {return v}
      return Concordium_V2_Empty()
    }
    set {blockHashInput = .best(newValue)}
  }

  /// Query for the last finalized block.
  var lastFinal: Concordium_V2_Empty {
    get {
      if case .lastFinal(let v)? = blockHashInput {return v}
      return Concordium_V2_Empty()
    }
    set {blockHashInput = .lastFinal(newValue)}
  }

  /// Query for the block specified by the hash. This hash should always be 32 bytes.
  var given: Concordium_V2_BlockHash {
    get {
      if case .given(let v)? = blockHashInput {return v}
      return Concordium_V2_BlockHash()
    }
    set {blockHashInput = .given(newValue)}
  }

  /// Query for a block at absolute height, if a unique block can be identified at that height.
  var absoluteHeight: Concordium_V2_AbsoluteBlockHeight {
    get {
      if case .absoluteHeight(let v)? = blockHashInput {return v}
      return Concordium_V2_AbsoluteBlockHeight()
    }
    set {blockHashInput = .absoluteHeight(newValue)}
  }

  /// Query for a block at height relative to a genesis index.
  var relativeHeight: Concordium_V2_BlockHashInput.RelativeHeight {
    get {
      if case .relativeHeight(let v)? = blockHashInput {return v}
      return Concordium_V2_BlockHashInput.RelativeHeight()
    }
    set {blockHashInput = .relativeHeight(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_BlockHashInput: Equatable, Sendable {
    /// Query for the best block.
    case best(Concordium_V2_Empty)
    /// Query for the last finalized block.
    case lastFinal(Concordium_V2_Empty)
    /// Query for the block specified by the hash. This hash should always be 32 bytes.
    case given(Concordium_V2_BlockHash)
    /// Query for a block at absolute height, if a unique block can be identified at that height.
    case absoluteHeight(Concordium_V2_AbsoluteBlockHeight)
    /// Query for a block at height relative to a genesis index.
    case relativeHeight(Concordium_V2_BlockHashInput.RelativeHeight)

  }

  /// Request using a relative block height.
  struct RelativeHeight: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Genesis index to start from.
    var genesisIndex: Concordium_V2_GenesisIndex {
      get {return _genesisIndex ?? Concordium_V2_GenesisIndex()}
      set {_genesisIndex = newValue}
    }
    /// Returns true if `genesisIndex` has been explicitly set.
    var hasGenesisIndex: Bool {return self._genesisIndex != nil}
    /// Clears the value of `genesisIndex`. Subsequent reads from it will return its default value.
    mutating func clearGenesisIndex() {self._genesisIndex = nil}

    /// Height starting from the genesis block at the genesis index.
    var height: Concordium_V2_BlockHeight {
      get {return _height ?? Concordium_V2_BlockHeight()}
      set {_height = newValue}
    }
    /// Returns true if `height` has been explicitly set.
    var hasHeight: Bool {return self._height != nil}
    /// Clears the value of `height`. Subsequent reads from it will return its default value.
    mutating func clearHeight() {self._height = nil}

    /// Whether to return results only from the specified genesis index (`true`),
    /// or allow results from more recent genesis indices as well (`false`).
    var restrict: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _genesisIndex: Concordium_V2_GenesisIndex? = nil
    fileprivate var _height: Concordium_V2_BlockHeight? = nil
  }

  init() {}
}

/// Input to queries which take an epoch as a parameter.
struct Concordium_V2_EpochRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var epochRequestInput: Concordium_V2_EpochRequest.OneOf_EpochRequestInput? = nil

  /// Query by genesis index and epoch number.
  var relativeEpoch: Concordium_V2_EpochRequest.RelativeEpoch {
    get {
      if case .relativeEpoch(let v)? = epochRequestInput {return v}
      return Concordium_V2_EpochRequest.RelativeEpoch()
    }
    set {epochRequestInput = .relativeEpoch(newValue)}
  }

  /// Query for the epoch of a specified block.
  var blockHash: Concordium_V2_BlockHashInput {
    get {
      if case .blockHash(let v)? = epochRequestInput {return v}
      return Concordium_V2_BlockHashInput()
    }
    set {epochRequestInput = .blockHash(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_EpochRequestInput: Equatable, Sendable {
    /// Query by genesis index and epoch number.
    case relativeEpoch(Concordium_V2_EpochRequest.RelativeEpoch)
    /// Query for the epoch of a specified block.
    case blockHash(Concordium_V2_BlockHashInput)

  }

  /// Request an epoch by number at a given genesis index.
  struct RelativeEpoch: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The genesis index to query at. The query is restricted to this genesis index, and
    /// will not return results for other indices even if the epoch number is out of bounds.
    var genesisIndex: Concordium_V2_GenesisIndex {
      get {return _genesisIndex ?? Concordium_V2_GenesisIndex()}
      set {_genesisIndex = newValue}
    }
    /// Returns true if `genesisIndex` has been explicitly set.
    var hasGenesisIndex: Bool {return self._genesisIndex != nil}
    /// Clears the value of `genesisIndex`. Subsequent reads from it will return its default value.
    mutating func clearGenesisIndex() {self._genesisIndex = nil}

    /// The epoch number to query at.
    var epoch: Concordium_V2_Epoch {
      get {return _epoch ?? Concordium_V2_Epoch()}
      set {_epoch = newValue}
    }
    /// Returns true if `epoch` has been explicitly set.
    var hasEpoch: Bool {return self._epoch != nil}
    /// Clears the value of `epoch`. Subsequent reads from it will return its default value.
    mutating func clearEpoch() {self._epoch = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _genesisIndex: Concordium_V2_GenesisIndex? = nil
    fileprivate var _epoch: Concordium_V2_Epoch? = nil
  }

  init() {}
}

/// Input to queries which take an account as a parameter.
struct Concordium_V2_AccountIdentifierInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountIdentifierInput: Concordium_V2_AccountIdentifierInput.OneOf_AccountIdentifierInput? = nil

  /// Identify the account by the address of the account.
  var address: Concordium_V2_AccountAddress {
    get {
      if case .address(let v)? = accountIdentifierInput {return v}
      return Concordium_V2_AccountAddress()
    }
    set {accountIdentifierInput = .address(newValue)}
  }

  /// Identify the account by the credential that belongs or has belonged to it.
  var credID: Concordium_V2_CredentialRegistrationId {
    get {
      if case .credID(let v)? = accountIdentifierInput {return v}
      return Concordium_V2_CredentialRegistrationId()
    }
    set {accountIdentifierInput = .credID(newValue)}
  }

  /// Identify the account via its index.
  var accountIndex: Concordium_V2_AccountIndex {
    get {
      if case .accountIndex(let v)? = accountIdentifierInput {return v}
      return Concordium_V2_AccountIndex()
    }
    set {accountIdentifierInput = .accountIndex(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_AccountIdentifierInput: Equatable, Sendable {
    /// Identify the account by the address of the account.
    case address(Concordium_V2_AccountAddress)
    /// Identify the account by the credential that belongs or has belonged to it.
    case credID(Concordium_V2_CredentialRegistrationId)
    /// Identify the account via its index.
    case accountIndex(Concordium_V2_AccountIndex)

  }

  init() {}
}

/// Request for account information.
struct Concordium_V2_AccountInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Block in which to query the account information.
  var blockHash: Concordium_V2_BlockHashInput {
    get {return _blockHash ?? Concordium_V2_BlockHashInput()}
    set {_blockHash = newValue}
  }
  /// Returns true if `blockHash` has been explicitly set.
  var hasBlockHash: Bool {return self._blockHash != nil}
  /// Clears the value of `blockHash`. Subsequent reads from it will return its default value.
  mutating func clearBlockHash() {self._blockHash = nil}

  /// Specification of the account.
  var accountIdentifier: Concordium_V2_AccountIdentifierInput {
    get {return _accountIdentifier ?? Concordium_V2_AccountIdentifierInput()}
    set {_accountIdentifier = newValue}
  }
  /// Returns true if `accountIdentifier` has been explicitly set.
  var hasAccountIdentifier: Bool {return self._accountIdentifier != nil}
  /// Clears the value of `accountIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearAccountIdentifier() {self._accountIdentifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockHash: Concordium_V2_BlockHashInput? = nil
  fileprivate var _accountIdentifier: Concordium_V2_AccountIdentifierInput? = nil
}

/// Information about a finalized block that is part of the streaming response.
struct Concordium_V2_FinalizedBlockInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hash of the block.
  var hash: Concordium_V2_BlockHash {
    get {return _hash ?? Concordium_V2_BlockHash()}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  /// Absolute height of the block, height 0 is the genesis block.
  var height: Concordium_V2_AbsoluteBlockHeight {
    get {return _height ?? Concordium_V2_AbsoluteBlockHeight()}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hash: Concordium_V2_BlockHash? = nil
  fileprivate var _height: Concordium_V2_AbsoluteBlockHeight? = nil
}

/// Request the ancestors for the given block.
struct Concordium_V2_AncestorsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The block to get ancestors of.
  var blockHash: Concordium_V2_BlockHashInput {
    get {return _blockHash ?? Concordium_V2_BlockHashInput()}
    set {_blockHash = newValue}
  }
  /// Returns true if `blockHash` has been explicitly set.
  var hasBlockHash: Bool {return self._blockHash != nil}
  /// Clears the value of `blockHash`. Subsequent reads from it will return its default value.
  mutating func clearBlockHash() {self._blockHash = nil}

  /// The maximum number of ancestors returned.
  var amount: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockHash: Concordium_V2_BlockHashInput? = nil
}

/// Request for getting the source of a smart contract module.
struct Concordium_V2_ModuleSourceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The block to be used for the query.
  var blockHash: Concordium_V2_BlockHashInput {
    get {return _blockHash ?? Concordium_V2_BlockHashInput()}
    set {_blockHash = newValue}
  }
  /// Returns true if `blockHash` has been explicitly set.
  var hasBlockHash: Bool {return self._blockHash != nil}
  /// Clears the value of `blockHash`. Subsequent reads from it will return its default value.
  mutating func clearBlockHash() {self._blockHash = nil}

  /// The reference of the module.
  var moduleRef: Concordium_V2_ModuleRef {
    get {return _moduleRef ?? Concordium_V2_ModuleRef()}
    set {_moduleRef = newValue}
  }
  /// Returns true if `moduleRef` has been explicitly set.
  var hasModuleRef: Bool {return self._moduleRef != nil}
  /// Clears the value of `moduleRef`. Subsequent reads from it will return its default value.
  mutating func clearModuleRef() {self._moduleRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockHash: Concordium_V2_BlockHashInput? = nil
  fileprivate var _moduleRef: Concordium_V2_ModuleRef? = nil
}

/// Address of a smart contract instance.
struct Concordium_V2_ContractAddress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The index of the smart contract.
  var index: UInt64 = 0

  /// The subindex of the smart contract instance.
  /// Currently not used, so it is always 0.
  var subindex: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for getting information about a smart contract instance.
struct Concordium_V2_InstanceInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The block to be used for the query.
  var blockHash: Concordium_V2_BlockHashInput {
    get {return _blockHash ?? Concordium_V2_BlockHashInput()}
    set {_blockHash = newValue}
  }
  /// Returns true if `blockHash` has been explicitly set.
  var hasBlockHash: Bool {return self._blockHash != nil}
  /// Clears the value of `blockHash`. Subsequent reads from it will return its default value.
  mutating func clearBlockHash() {self._blockHash = nil}

  /// The address of the smart contract instance.
  var address: Concordium_V2_ContractAddress {
    get {return _address ?? Concordium_V2_ContractAddress()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockHash: Concordium_V2_BlockHashInput? = nil
  fileprivate var _address: Concordium_V2_ContractAddress? = nil
}

/// Information about a smart contract instance.
struct Concordium_V2_InstanceInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The information depends on the smart contract version used by the instance.
  var version: Concordium_V2_InstanceInfo.OneOf_Version? = nil

  var v0: Concordium_V2_InstanceInfo.V0 {
    get {
      if case .v0(let v)? = version {return v}
      return Concordium_V2_InstanceInfo.V0()
    }
    set {version = .v0(newValue)}
  }

  var v1: Concordium_V2_InstanceInfo.V1 {
    get {
      if case .v1(let v)? = version {return v}
      return Concordium_V2_InstanceInfo.V1()
    }
    set {version = .v1(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The information depends on the smart contract version used by the instance.
  enum OneOf_Version: Equatable, Sendable {
    case v0(Concordium_V2_InstanceInfo.V0)
    case v1(Concordium_V2_InstanceInfo.V1)

  }

  /// Version 0 smart contract instance information.
  struct V0: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The state of the instance.
    var model: Concordium_V2_ContractStateV0 {
      get {return _model ?? Concordium_V2_ContractStateV0()}
      set {_model = newValue}
    }
    /// Returns true if `model` has been explicitly set.
    var hasModel: Bool {return self._model != nil}
    /// Clears the value of `model`. Subsequent reads from it will return its default value.
    mutating func clearModel() {self._model = nil}

    /// The account address which deployed the instance.
    var owner: Concordium_V2_AccountAddress {
      get {return _owner ?? Concordium_V2_AccountAddress()}
      set {_owner = newValue}
    }
    /// Returns true if `owner` has been explicitly set.
    var hasOwner: Bool {return self._owner != nil}
    /// Clears the value of `owner`. Subsequent reads from it will return its default value.
    mutating func clearOwner() {self._owner = nil}

    /// The amount of CCD tokens in the balance of the instance.
    var amount: Concordium_V2_Amount {
      get {return _amount ?? Concordium_V2_Amount()}
      set {_amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    var hasAmount: Bool {return self._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    mutating func clearAmount() {self._amount = nil}

    /// A list of endpoints exposed by the instance.
    var methods: [Concordium_V2_ReceiveName] = []

    /// The name of the smart contract of the instance.
    var name: Concordium_V2_InitName {
      get {return _name ?? Concordium_V2_InitName()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    /// The module reference for the smart contract module of the instance.
    var sourceModule: Concordium_V2_ModuleRef {
      get {return _sourceModule ?? Concordium_V2_ModuleRef()}
      set {_sourceModule = newValue}
    }
    /// Returns true if `sourceModule` has been explicitly set.
    var hasSourceModule: Bool {return self._sourceModule != nil}
    /// Clears the value of `sourceModule`. Subsequent reads from it will return its default value.
    mutating func clearSourceModule() {self._sourceModule = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _model: Concordium_V2_ContractStateV0? = nil
    fileprivate var _owner: Concordium_V2_AccountAddress? = nil
    fileprivate var _amount: Concordium_V2_Amount? = nil
    fileprivate var _name: Concordium_V2_InitName? = nil
    fileprivate var _sourceModule: Concordium_V2_ModuleRef? = nil
  }

  /// Version 1 smart contract instance information.
  struct V1: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The account address which deployed the instance.
    var owner: Concordium_V2_AccountAddress {
      get {return _owner ?? Concordium_V2_AccountAddress()}
      set {_owner = newValue}
    }
    /// Returns true if `owner` has been explicitly set.
    var hasOwner: Bool {return self._owner != nil}
    /// Clears the value of `owner`. Subsequent reads from it will return its default value.
    mutating func clearOwner() {self._owner = nil}

    /// The amount of CCD tokens in the balance of the instance.
    var amount: Concordium_V2_Amount {
      get {return _amount ?? Concordium_V2_Amount()}
      set {_amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    var hasAmount: Bool {return self._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    mutating func clearAmount() {self._amount = nil}

    /// A list of endpoints exposed by the instance.
    var methods: [Concordium_V2_ReceiveName] = []

    /// The name of the smart contract of the instance.
    var name: Concordium_V2_InitName {
      get {return _name ?? Concordium_V2_InitName()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    /// The module reference for the smart contract module of the instance.
    var sourceModule: Concordium_V2_ModuleRef {
      get {return _sourceModule ?? Concordium_V2_ModuleRef()}
      set {_sourceModule = newValue}
    }
    /// Returns true if `sourceModule` has been explicitly set.
    var hasSourceModule: Bool {return self._sourceModule != nil}
    /// Clears the value of `sourceModule`. Subsequent reads from it will return its default value.
    mutating func clearSourceModule() {self._sourceModule = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _owner: Concordium_V2_AccountAddress? = nil
    fileprivate var _amount: Concordium_V2_Amount? = nil
    fileprivate var _name: Concordium_V2_InitName? = nil
    fileprivate var _sourceModule: Concordium_V2_ModuleRef? = nil
  }

  init() {}
}

/// A smart contract instance key-value pair.
struct Concordium_V2_InstanceStateKVPair: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: Data = Data()

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request for a specific key of a smart contract instance state.
struct Concordium_V2_InstanceStateLookupRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The block to be used for the query.
  var blockHash: Concordium_V2_BlockHashInput {
    get {return _blockHash ?? Concordium_V2_BlockHashInput()}
    set {_blockHash = newValue}
  }
  /// Returns true if `blockHash` has been explicitly set.
  var hasBlockHash: Bool {return self._blockHash != nil}
  /// Clears the value of `blockHash`. Subsequent reads from it will return its default value.
  mutating func clearBlockHash() {self._blockHash = nil}

  /// The address of the smart contract instance.
  var address: Concordium_V2_ContractAddress {
    get {return _address ?? Concordium_V2_ContractAddress()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  /// Key to look up. If the instance is a V0 instance then this will not be used.
  var key: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockHash: Concordium_V2_BlockHashInput? = nil
  fileprivate var _address: Concordium_V2_ContractAddress? = nil
}

/// Value at the requested key of a smart contract instance state. For V0
/// contracts this will always be the entire state of the contract.
struct Concordium_V2_InstanceStateValueAtKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The receive name of a smart contract function. Expected format:
/// `<contract_name>.<func_name>`. It must only consist of atmost 100 ASCII
/// alphanumeric or punctuation characters, and must contain a '.'.
struct Concordium_V2_ReceiveName: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The init name of a smart contract function. Expected format:
/// `init_<contract_name>`. It must only consist of atmost 100 ASCII alphanumeric
/// or punctuation characters, must not contain a '.' and must start with
/// 'init_'.
struct Concordium_V2_InitName: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Parameter to a smart contract initialization or invocation.
struct Concordium_V2_Parameter: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A smart contract v0 state.
struct Concordium_V2_ContractStateV0: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Status of a block item known to the node.
struct Concordium_V2_BlockItemStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Concordium_V2_BlockItemStatus.OneOf_Status? = nil

  /// Block item is received, but not yet in any blocks.
  var received: Concordium_V2_Empty {
    get {
      if case .received(let v)? = status {return v}
      return Concordium_V2_Empty()
    }
    set {status = .received(newValue)}
  }

  /// Block item is committed to one or more blocks. The outcomes are listed
  /// for each block. Note that in the vast majority of cases the outcome of a
  /// transaction should not be dependent on the block it is in, but this
  /// can in principle happen.
  var committed: Concordium_V2_BlockItemStatus.Committed {
    get {
      if case .committed(let v)? = status {return v}
      return Concordium_V2_BlockItemStatus.Committed()
    }
    set {status = .committed(newValue)}
  }

  /// Block item is finalized in the given block, with the given summary.
  var finalized: Concordium_V2_BlockItemStatus.Finalized {
    get {
      if case .finalized(let v)? = status {return v}
      return Concordium_V2_BlockItemStatus.Finalized()
    }
    set {status = .finalized(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Status: Equatable, Sendable {
    /// Block item is received, but not yet in any blocks.
    case received(Concordium_V2_Empty)
    /// Block item is committed to one or more blocks. The outcomes are listed
    /// for each block. Note that in the vast majority of cases the outcome of a
    /// transaction should not be dependent on the block it is in, but this
    /// can in principle happen.
    case committed(Concordium_V2_BlockItemStatus.Committed)
    /// Block item is finalized in the given block, with the given summary.
    case finalized(Concordium_V2_BlockItemStatus.Finalized)

  }

  struct Committed: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var outcomes: [Concordium_V2_BlockItemSummaryInBlock] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Finalized: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var outcome: Concordium_V2_BlockItemSummaryInBlock {
      get {return _outcome ?? Concordium_V2_BlockItemSummaryInBlock()}
      set {_outcome = newValue}
    }
    /// Returns true if `outcome` has been explicitly set.
    var hasOutcome: Bool {return self._outcome != nil}
    /// Clears the value of `outcome`. Subsequent reads from it will return its default value.
    mutating func clearOutcome() {self._outcome = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _outcome: Concordium_V2_BlockItemSummaryInBlock? = nil
  }

  init() {}
}

/// A block item summary together with a block hash. Used in BlockItemStatus.
struct Concordium_V2_BlockItemSummaryInBlock: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The block hash.
  var blockHash: Concordium_V2_BlockHash {
    get {return _blockHash ?? Concordium_V2_BlockHash()}
    set {_blockHash = newValue}
  }
  /// Returns true if `blockHash` has been explicitly set.
  var hasBlockHash: Bool {return self._blockHash != nil}
  /// Clears the value of `blockHash`. Subsequent reads from it will return its default value.
  mutating func clearBlockHash() {self._blockHash = nil}

  /// The block item summary.
  var outcome: Concordium_V2_BlockItemSummary {
    get {return _outcome ?? Concordium_V2_BlockItemSummary()}
    set {_outcome = newValue}
  }
  /// Returns true if `outcome` has been explicitly set.
  var hasOutcome: Bool {return self._outcome != nil}
  /// Clears the value of `outcome`. Subsequent reads from it will return its default value.
  mutating func clearOutcome() {self._outcome = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockHash: Concordium_V2_BlockHash? = nil
  fileprivate var _outcome: Concordium_V2_BlockItemSummary? = nil
}

/// Energy is used to count exact execution cost.
/// This cost is then converted to CCD amounts.
struct Concordium_V2_Energy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A number representing a slot for baking a block.
struct Concordium_V2_Slot: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response for getNextAccountSequenceNumber.
struct Concordium_V2_NextAccountSequenceNumber: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The best guess for the available account sequence number.
  var sequenceNumber: Concordium_V2_SequenceNumber {
    get {return _sequenceNumber ?? Concordium_V2_SequenceNumber()}
    set {_sequenceNumber = newValue}
  }
  /// Returns true if `sequenceNumber` has been explicitly set.
  var hasSequenceNumber: Bool {return self._sequenceNumber != nil}
  /// Clears the value of `sequenceNumber`. Subsequent reads from it will return its default value.
  mutating func clearSequenceNumber() {self._sequenceNumber = nil}

  /// Whether the guess relies on any non-finalized transactions. If true all of the relevant transactions are finalized.
  var allFinal: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sequenceNumber: Concordium_V2_SequenceNumber? = nil
}

/// A duration of milliseconds.
struct Concordium_V2_Duration: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A reason for why a transaction was rejected. Rejected means included in a
/// block, but the desired action was not achieved. The only effect of a
/// rejected transaction is payment.
struct Concordium_V2_RejectReason: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: Concordium_V2_RejectReason.OneOf_Reason? = nil

  /// Raised while validating a Wasm module that is not well formed.
  var moduleNotWf: Concordium_V2_Empty {
    get {
      if case .moduleNotWf(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .moduleNotWf(newValue)}
  }

  /// The smart contract module hash already exists.
  var moduleHashAlreadyExists: Concordium_V2_ModuleRef {
    get {
      if case .moduleHashAlreadyExists(let v)? = reason {return v}
      return Concordium_V2_ModuleRef()
    }
    set {reason = .moduleHashAlreadyExists(newValue)}
  }

  /// Account does not exist.
  var invalidAccountReference: Concordium_V2_AccountAddress {
    get {
      if case .invalidAccountReference(let v)? = reason {return v}
      return Concordium_V2_AccountAddress()
    }
    set {reason = .invalidAccountReference(newValue)}
  }

  /// Reference to a non-existing contract init method.
  var invalidInitMethod: Concordium_V2_RejectReason.InvalidInitMethod {
    get {
      if case .invalidInitMethod(let v)? = reason {return v}
      return Concordium_V2_RejectReason.InvalidInitMethod()
    }
    set {reason = .invalidInitMethod(newValue)}
  }

  /// Reference to a non-existing contract receive method.
  var invalidReceiveMethod: Concordium_V2_RejectReason.InvalidReceiveMethod {
    get {
      if case .invalidReceiveMethod(let v)? = reason {return v}
      return Concordium_V2_RejectReason.InvalidReceiveMethod()
    }
    set {reason = .invalidReceiveMethod(newValue)}
  }

  /// Reference to a non-existing smart contract module.
  var invalidModuleReference: Concordium_V2_ModuleRef {
    get {
      if case .invalidModuleReference(let v)? = reason {return v}
      return Concordium_V2_ModuleRef()
    }
    set {reason = .invalidModuleReference(newValue)}
  }

  /// Contract instance does not exist.
  var invalidContractAddress: Concordium_V2_ContractAddress {
    get {
      if case .invalidContractAddress(let v)? = reason {return v}
      return Concordium_V2_ContractAddress()
    }
    set {reason = .invalidContractAddress(newValue)}
  }

  /// Runtime exception occurred when running either the init or receive
  /// method.
  var runtimeFailure: Concordium_V2_Empty {
    get {
      if case .runtimeFailure(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .runtimeFailure(newValue)}
  }

  /// When one wishes to transfer an amount from A to B but there
  /// are not enough funds on account/contract A to make this
  /// possible. The data are the from address and the amount to transfer.
  var amountTooLarge: Concordium_V2_RejectReason.AmountTooLarge {
    get {
      if case .amountTooLarge(let v)? = reason {return v}
      return Concordium_V2_RejectReason.AmountTooLarge()
    }
    set {reason = .amountTooLarge(newValue)}
  }

  /// Serialization of the body failed.
  var serializationFailure: Concordium_V2_Empty {
    get {
      if case .serializationFailure(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .serializationFailure(newValue)}
  }

  /// We ran of out energy to process this transaction.
  var outOfEnergy: Concordium_V2_Empty {
    get {
      if case .outOfEnergy(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .outOfEnergy(newValue)}
  }

  /// Rejected due to contract logic in init function of a contract.
  var rejectedInit: Concordium_V2_RejectReason.RejectedInit {
    get {
      if case .rejectedInit(let v)? = reason {return v}
      return Concordium_V2_RejectReason.RejectedInit()
    }
    set {reason = .rejectedInit(newValue)}
  }

  /// Rejected due to contract logic in receive function of a contract.
  var rejectedReceive: Concordium_V2_RejectReason.RejectedReceive {
    get {
      if case .rejectedReceive(let v)? = reason {return v}
      return Concordium_V2_RejectReason.RejectedReceive()
    }
    set {reason = .rejectedReceive(newValue)}
  }

  /// Proof that the baker owns relevant private keys is not valid.
  var invalidProof: Concordium_V2_Empty {
    get {
      if case .invalidProof(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .invalidProof(newValue)}
  }

  /// Tried to add baker for an account that already has a baker.
  var alreadyABaker: Concordium_V2_BakerId {
    get {
      if case .alreadyABaker(let v)? = reason {return v}
      return Concordium_V2_BakerId()
    }
    set {reason = .alreadyABaker(newValue)}
  }

  /// Tried to remove a baker for an account that has no baker.
  var notABaker: Concordium_V2_AccountAddress {
    get {
      if case .notABaker(let v)? = reason {return v}
      return Concordium_V2_AccountAddress()
    }
    set {reason = .notABaker(newValue)}
  }

  /// The amount on the account was insufficient to cover the proposed stake.
  var insufficientBalanceForBakerStake: Concordium_V2_Empty {
    get {
      if case .insufficientBalanceForBakerStake(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .insufficientBalanceForBakerStake(newValue)}
  }

  /// The amount provided is under the threshold required for becoming a baker.
  var stakeUnderMinimumThresholdForBaking: Concordium_V2_Empty {
    get {
      if case .stakeUnderMinimumThresholdForBaking(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .stakeUnderMinimumThresholdForBaking(newValue)}
  }

  /// The change could not be made because the baker is in cooldown for
  /// another change.
  var bakerInCooldown: Concordium_V2_Empty {
    get {
      if case .bakerInCooldown(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .bakerInCooldown(newValue)}
  }

  /// A baker with the given aggregation key already exists.
  var duplicateAggregationKey: Concordium_V2_BakerAggregationVerifyKey {
    get {
      if case .duplicateAggregationKey(let v)? = reason {return v}
      return Concordium_V2_BakerAggregationVerifyKey()
    }
    set {reason = .duplicateAggregationKey(newValue)}
  }

  /// Encountered credential ID that does not exist.
  var nonExistentCredentialID: Concordium_V2_Empty {
    get {
      if case .nonExistentCredentialID(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .nonExistentCredentialID(newValue)}
  }

  /// Attempted to add an account key to a key index already in use.
  var keyIndexAlreadyInUse: Concordium_V2_Empty {
    get {
      if case .keyIndexAlreadyInUse(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .keyIndexAlreadyInUse(newValue)}
  }

  /// When the account threshold is updated, it must not exceed the amount of
  /// existing keys.
  var invalidAccountThreshold: Concordium_V2_Empty {
    get {
      if case .invalidAccountThreshold(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .invalidAccountThreshold(newValue)}
  }

  /// When the credential key threshold is updated, it must not exceed the
  /// amount of existing keys.
  var invalidCredentialKeySignThreshold: Concordium_V2_Empty {
    get {
      if case .invalidCredentialKeySignThreshold(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .invalidCredentialKeySignThreshold(newValue)}
  }

  /// Proof for an encrypted amount transfer did not validate.
  var invalidEncryptedAmountTransferProof: Concordium_V2_Empty {
    get {
      if case .invalidEncryptedAmountTransferProof(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .invalidEncryptedAmountTransferProof(newValue)}
  }

  /// Proof for a secret to public transfer did not validate.
  var invalidTransferToPublicProof: Concordium_V2_Empty {
    get {
      if case .invalidTransferToPublicProof(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .invalidTransferToPublicProof(newValue)}
  }

  /// Account tried to transfer an encrypted amount to itself, that's not
  /// allowed.
  var encryptedAmountSelfTransfer: Concordium_V2_AccountAddress {
    get {
      if case .encryptedAmountSelfTransfer(let v)? = reason {return v}
      return Concordium_V2_AccountAddress()
    }
    set {reason = .encryptedAmountSelfTransfer(newValue)}
  }

  /// The provided index is below the start index or above `startIndex +
  /// length incomingAmounts`.
  var invalidIndexOnEncryptedTransfer: Concordium_V2_Empty {
    get {
      if case .invalidIndexOnEncryptedTransfer(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .invalidIndexOnEncryptedTransfer(newValue)}
  }

  /// The transfer with schedule is going to send 0 tokens.
  var zeroScheduledAmount: Concordium_V2_Empty {
    get {
      if case .zeroScheduledAmount(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .zeroScheduledAmount(newValue)}
  }

  /// The transfer with schedule has a non strictly increasing schedule.
  var nonIncreasingSchedule: Concordium_V2_Empty {
    get {
      if case .nonIncreasingSchedule(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .nonIncreasingSchedule(newValue)}
  }

  /// The first scheduled release in a transfer with schedule has already
  /// expired.
  var firstScheduledReleaseExpired: Concordium_V2_Empty {
    get {
      if case .firstScheduledReleaseExpired(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .firstScheduledReleaseExpired(newValue)}
  }

  /// Account tried to transfer with schedule to itself, that's not allowed.
  var scheduledSelfTransfer: Concordium_V2_AccountAddress {
    get {
      if case .scheduledSelfTransfer(let v)? = reason {return v}
      return Concordium_V2_AccountAddress()
    }
    set {reason = .scheduledSelfTransfer(newValue)}
  }

  /// At least one of the credentials was either malformed or its proof was
  /// incorrect.
  var invalidCredentials: Concordium_V2_Empty {
    get {
      if case .invalidCredentials(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .invalidCredentials(newValue)}
  }

  /// Some of the credential IDs already exist or are duplicated in the
  /// transaction.
  var duplicateCredIds: Concordium_V2_RejectReason.DuplicateCredIds {
    get {
      if case .duplicateCredIds(let v)? = reason {return v}
      return Concordium_V2_RejectReason.DuplicateCredIds()
    }
    set {reason = .duplicateCredIds(newValue)}
  }

  /// A credential id that was to be removed is not part of the account.
  var nonExistentCredIds: Concordium_V2_RejectReason.NonExistentCredIds {
    get {
      if case .nonExistentCredIds(let v)? = reason {return v}
      return Concordium_V2_RejectReason.NonExistentCredIds()
    }
    set {reason = .nonExistentCredIds(newValue)}
  }

  /// Attemp to remove the first credential.
  var removeFirstCredential: Concordium_V2_Empty {
    get {
      if case .removeFirstCredential(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .removeFirstCredential(newValue)}
  }

  /// The credential holder of the keys to be updated did not sign the
  /// transaction.
  var credentialHolderDidNotSign: Concordium_V2_Empty {
    get {
      if case .credentialHolderDidNotSign(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .credentialHolderDidNotSign(newValue)}
  }

  /// Account is not allowed to have multiple credentials because it contains
  /// a non-zero encrypted transfer.
  var notAllowedMultipleCredentials: Concordium_V2_Empty {
    get {
      if case .notAllowedMultipleCredentials(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .notAllowedMultipleCredentials(newValue)}
  }

  /// The account is not allowed to receive encrypted transfers because it has
  /// multiple credentials.
  var notAllowedToReceiveEncrypted: Concordium_V2_Empty {
    get {
      if case .notAllowedToReceiveEncrypted(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .notAllowedToReceiveEncrypted(newValue)}
  }

  /// The account is not allowed to send encrypted transfers (or transfer
  /// from/to public to/from encrypted).
  var notAllowedToHandleEncrypted: Concordium_V2_Empty {
    get {
      if case .notAllowedToHandleEncrypted(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .notAllowedToHandleEncrypted(newValue)}
  }

  /// A configure baker transaction is missing one or more arguments in order
  /// to add a baker.
  var missingBakerAddParameters: Concordium_V2_Empty {
    get {
      if case .missingBakerAddParameters(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .missingBakerAddParameters(newValue)}
  }

  /// Finalization reward commission is not in the valid range for a baker.
  var finalizationRewardCommissionNotInRange: Concordium_V2_Empty {
    get {
      if case .finalizationRewardCommissionNotInRange(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .finalizationRewardCommissionNotInRange(newValue)}
  }

  /// Baking reward commission is not in the valid range for a baker.
  var bakingRewardCommissionNotInRange: Concordium_V2_Empty {
    get {
      if case .bakingRewardCommissionNotInRange(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .bakingRewardCommissionNotInRange(newValue)}
  }

  /// Transaction fee commission is not in the valid range for a baker.
  var transactionFeeCommissionNotInRange: Concordium_V2_Empty {
    get {
      if case .transactionFeeCommissionNotInRange(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .transactionFeeCommissionNotInRange(newValue)}
  }

  /// Tried to add baker for an account that already has a delegator.
  var alreadyADelegator: Concordium_V2_Empty {
    get {
      if case .alreadyADelegator(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .alreadyADelegator(newValue)}
  }

  /// The amount on the account was insufficient to cover the proposed stake.
  var insufficientBalanceForDelegationStake: Concordium_V2_Empty {
    get {
      if case .insufficientBalanceForDelegationStake(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .insufficientBalanceForDelegationStake(newValue)}
  }

  /// A configure delegation transaction is missing one or more arguments in
  /// order to add a delegator.
  var missingDelegationAddParameters: Concordium_V2_Empty {
    get {
      if case .missingDelegationAddParameters(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .missingDelegationAddParameters(newValue)}
  }

  /// Delegation stake when adding a delegator was 0.
  var insufficientDelegationStake: Concordium_V2_Empty {
    get {
      if case .insufficientDelegationStake(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .insufficientDelegationStake(newValue)}
  }

  /// Account is not a delegation account.
  var delegatorInCooldown: Concordium_V2_Empty {
    get {
      if case .delegatorInCooldown(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .delegatorInCooldown(newValue)}
  }

  /// Account is not a delegation account.
  var notADelegator: Concordium_V2_AccountAddress {
    get {
      if case .notADelegator(let v)? = reason {return v}
      return Concordium_V2_AccountAddress()
    }
    set {reason = .notADelegator(newValue)}
  }

  /// Delegation target is not a baker
  var delegationTargetNotABaker: Concordium_V2_BakerId {
    get {
      if case .delegationTargetNotABaker(let v)? = reason {return v}
      return Concordium_V2_BakerId()
    }
    set {reason = .delegationTargetNotABaker(newValue)}
  }

  /// The amount would result in pool capital higher than the maximum
  /// threshold.
  var stakeOverMaximumThresholdForPool: Concordium_V2_Empty {
    get {
      if case .stakeOverMaximumThresholdForPool(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .stakeOverMaximumThresholdForPool(newValue)}
  }

  /// The amount would result in pool with a too high fraction of delegated
  /// capital.
  var poolWouldBecomeOverDelegated: Concordium_V2_Empty {
    get {
      if case .poolWouldBecomeOverDelegated(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .poolWouldBecomeOverDelegated(newValue)}
  }

  /// The pool is not open to delegators.
  var poolClosed: Concordium_V2_Empty {
    get {
      if case .poolClosed(let v)? = reason {return v}
      return Concordium_V2_Empty()
    }
    set {reason = .poolClosed(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Reason: Equatable, Sendable {
    /// Raised while validating a Wasm module that is not well formed.
    case moduleNotWf(Concordium_V2_Empty)
    /// The smart contract module hash already exists.
    case moduleHashAlreadyExists(Concordium_V2_ModuleRef)
    /// Account does not exist.
    case invalidAccountReference(Concordium_V2_AccountAddress)
    /// Reference to a non-existing contract init method.
    case invalidInitMethod(Concordium_V2_RejectReason.InvalidInitMethod)
    /// Reference to a non-existing contract receive method.
    case invalidReceiveMethod(Concordium_V2_RejectReason.InvalidReceiveMethod)
    /// Reference to a non-existing smart contract module.
    case invalidModuleReference(Concordium_V2_ModuleRef)
    /// Contract instance does not exist.
    case invalidContractAddress(Concordium_V2_ContractAddress)
    /// Runtime exception occurred when running either the init or receive
    /// method.
    case runtimeFailure(Concordium_V2_Empty)
    /// When one wishes to transfer an amount from A to B but there
    /// are not enough funds on account/contract A to make this
    /// possible. The data are the from address and the amount to transfer.
    case amountTooLarge(Concordium_V2_RejectReason.AmountTooLarge)
    /// Serialization of the body failed.
    case serializationFailure(Concordium_V2_Empty)
    /// We ran of out energy to process this transaction.
    case outOfEnergy(Concordium_V2_Empty)
    /// Rejected due to contract logic in init function of a contract.
    case rejectedInit(Concordium_V2_RejectReason.RejectedInit)
    /// Rejected due to contract logic in receive function of a contract.
    case rejectedReceive(Concordium_V2_RejectReason.RejectedReceive)
    /// Proof that the baker owns relevant private keys is not valid.
    case invalidProof(Concordium_V2_Empty)
    /// Tried to add baker for an account that already has a baker.
    case alreadyABaker(Concordium_V2_BakerId)
    /// Tried to remove a baker for an account that has no baker.
    case notABaker(Concordium_V2_AccountAddress)
    /// The amount on the account was insufficient to cover the proposed stake.
    case insufficientBalanceForBakerStake(Concordium_V2_Empty)
    /// The amount provided is under the threshold required for becoming a baker.
    case stakeUnderMinimumThresholdForBaking(Concordium_V2_Empty)
    /// The change could not be made because the baker is in cooldown for
    /// another change.
    case bakerInCooldown(Concordium_V2_Empty)
    /// A baker with the given aggregation key already exists.
    case duplicateAggregationKey(Concordium_V2_BakerAggregationVerifyKey)
    /// Encountered credential ID that does not exist.
    case nonExistentCredentialID(Concordium_V2_Empty)
    /// Attempted to add an account key to a key index already in use.
    case keyIndexAlreadyInUse(Concordium_V2_Empty)
    /// When the account threshold is updated, it must not exceed the amount of
    /// existing keys.
    case invalidAccountThreshold(Concordium_V2_Empty)
    /// When the credential key threshold is updated, it must not exceed the
    /// amount of existing keys.
    case invalidCredentialKeySignThreshold(Concordium_V2_Empty)
    /// Proof for an encrypted amount transfer did not validate.
    case invalidEncryptedAmountTransferProof(Concordium_V2_Empty)
    /// Proof for a secret to public transfer did not validate.
    case invalidTransferToPublicProof(Concordium_V2_Empty)
    /// Account tried to transfer an encrypted amount to itself, that's not
    /// allowed.
    case encryptedAmountSelfTransfer(Concordium_V2_AccountAddress)
    /// The provided index is below the start index or above `startIndex +
    /// length incomingAmounts`.
    case invalidIndexOnEncryptedTransfer(Concordium_V2_Empty)
    /// The transfer with schedule is going to send 0 tokens.
    case zeroScheduledAmount(Concordium_V2_Empty)
    /// The transfer with schedule has a non strictly increasing schedule.
    case nonIncreasingSchedule(Concordium_V2_Empty)
    /// The first scheduled release in a transfer with schedule has already
    /// expired.
    case firstScheduledReleaseExpired(Concordium_V2_Empty)
    /// Account tried to transfer with schedule to itself, that's not allowed.
    case scheduledSelfTransfer(Concordium_V2_AccountAddress)
    /// At least one of the credentials was either malformed or its proof was
    /// incorrect.
    case invalidCredentials(Concordium_V2_Empty)
    /// Some of the credential IDs already exist or are duplicated in the
    /// transaction.
    case duplicateCredIds(Concordium_V2_RejectReason.DuplicateCredIds)
    /// A credential id that was to be removed is not part of the account.
    case nonExistentCredIds(Concordium_V2_RejectReason.NonExistentCredIds)
    /// Attemp to remove the first credential.
    case removeFirstCredential(Concordium_V2_Empty)
    /// The credential holder of the keys to be updated did not sign the
    /// transaction.
    case credentialHolderDidNotSign(Concordium_V2_Empty)
    /// Account is not allowed to have multiple credentials because it contains
    /// a non-zero encrypted transfer.
    case notAllowedMultipleCredentials(Concordium_V2_Empty)
    /// The account is not allowed to receive encrypted transfers because it has
    /// multiple credentials.
    case notAllowedToReceiveEncrypted(Concordium_V2_Empty)
    /// The account is not allowed to send encrypted transfers (or transfer
    /// from/to public to/from encrypted).
    case notAllowedToHandleEncrypted(Concordium_V2_Empty)
    /// A configure baker transaction is missing one or more arguments in order
    /// to add a baker.
    case missingBakerAddParameters(Concordium_V2_Empty)
    /// Finalization reward commission is not in the valid range for a baker.
    case finalizationRewardCommissionNotInRange(Concordium_V2_Empty)
    /// Baking reward commission is not in the valid range for a baker.
    case bakingRewardCommissionNotInRange(Concordium_V2_Empty)
    /// Transaction fee commission is not in the valid range for a baker.
    case transactionFeeCommissionNotInRange(Concordium_V2_Empty)
    /// Tried to add baker for an account that already has a delegator.
    case alreadyADelegator(Concordium_V2_Empty)
    /// The amount on the account was insufficient to cover the proposed stake.
    case insufficientBalanceForDelegationStake(Concordium_V2_Empty)
    /// A configure delegation transaction is missing one or more arguments in
    /// order to add a delegator.
    case missingDelegationAddParameters(Concordium_V2_Empty)
    /// Delegation stake when adding a delegator was 0.
    case insufficientDelegationStake(Concordium_V2_Empty)
    /// Account is not a delegation account.
    case delegatorInCooldown(Concordium_V2_Empty)
    /// Account is not a delegation account.
    case notADelegator(Concordium_V2_AccountAddress)
    /// Delegation target is not a baker
    case delegationTargetNotABaker(Concordium_V2_BakerId)
    /// The amount would result in pool capital higher than the maximum
    /// threshold.
    case stakeOverMaximumThresholdForPool(Concordium_V2_Empty)
    /// The amount would result in pool with a too high fraction of delegated
    /// capital.
    case poolWouldBecomeOverDelegated(Concordium_V2_Empty)
    /// The pool is not open to delegators.
    case poolClosed(Concordium_V2_Empty)

  }

  struct InvalidInitMethod: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var moduleRef: Concordium_V2_ModuleRef {
      get {return _moduleRef ?? Concordium_V2_ModuleRef()}
      set {_moduleRef = newValue}
    }
    /// Returns true if `moduleRef` has been explicitly set.
    var hasModuleRef: Bool {return self._moduleRef != nil}
    /// Clears the value of `moduleRef`. Subsequent reads from it will return its default value.
    mutating func clearModuleRef() {self._moduleRef = nil}

    var initName: Concordium_V2_InitName {
      get {return _initName ?? Concordium_V2_InitName()}
      set {_initName = newValue}
    }
    /// Returns true if `initName` has been explicitly set.
    var hasInitName: Bool {return self._initName != nil}
    /// Clears the value of `initName`. Subsequent reads from it will return its default value.
    mutating func clearInitName() {self._initName = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _moduleRef: Concordium_V2_ModuleRef? = nil
    fileprivate var _initName: Concordium_V2_InitName? = nil
  }

  struct InvalidReceiveMethod: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var moduleRef: Concordium_V2_ModuleRef {
      get {return _moduleRef ?? Concordium_V2_ModuleRef()}
      set {_moduleRef = newValue}
    }
    /// Returns true if `moduleRef` has been explicitly set.
    var hasModuleRef: Bool {return self._moduleRef != nil}
    /// Clears the value of `moduleRef`. Subsequent reads from it will return its default value.
    mutating func clearModuleRef() {self._moduleRef = nil}

    var receiveName: Concordium_V2_ReceiveName {
      get {return _receiveName ?? Concordium_V2_ReceiveName()}
      set {_receiveName = newValue}
    }
    /// Returns true if `receiveName` has been explicitly set.
    var hasReceiveName: Bool {return self._receiveName != nil}
    /// Clears the value of `receiveName`. Subsequent reads from it will return its default value.
    mutating func clearReceiveName() {self._receiveName = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _moduleRef: Concordium_V2_ModuleRef? = nil
    fileprivate var _receiveName: Concordium_V2_ReceiveName? = nil
  }

  struct AmountTooLarge: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var address: Concordium_V2_Address {
      get {return _address ?? Concordium_V2_Address()}
      set {_address = newValue}
    }
    /// Returns true if `address` has been explicitly set.
    var hasAddress: Bool {return self._address != nil}
    /// Clears the value of `address`. Subsequent reads from it will return its default value.
    mutating func clearAddress() {self._address = nil}

    var amount: Concordium_V2_Amount {
      get {return _amount ?? Concordium_V2_Amount()}
      set {_amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    var hasAmount: Bool {return self._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    mutating func clearAmount() {self._amount = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _address: Concordium_V2_Address? = nil
    fileprivate var _amount: Concordium_V2_Amount? = nil
  }

  struct RejectedInit: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rejectReason: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RejectedReceive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rejectReason: Int32 = 0

    var contractAddress: Concordium_V2_ContractAddress {
      get {return _contractAddress ?? Concordium_V2_ContractAddress()}
      set {_contractAddress = newValue}
    }
    /// Returns true if `contractAddress` has been explicitly set.
    var hasContractAddress: Bool {return self._contractAddress != nil}
    /// Clears the value of `contractAddress`. Subsequent reads from it will return its default value.
    mutating func clearContractAddress() {self._contractAddress = nil}

    var receiveName: Concordium_V2_ReceiveName {
      get {return _receiveName ?? Concordium_V2_ReceiveName()}
      set {_receiveName = newValue}
    }
    /// Returns true if `receiveName` has been explicitly set.
    var hasReceiveName: Bool {return self._receiveName != nil}
    /// Clears the value of `receiveName`. Subsequent reads from it will return its default value.
    mutating func clearReceiveName() {self._receiveName = nil}

    var parameter: Concordium_V2_Parameter {
      get {return _parameter ?? Concordium_V2_Parameter()}
      set {_parameter = newValue}
    }
    /// Returns true if `parameter` has been explicitly set.
    var hasParameter: Bool {return self._parameter != nil}
    /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
    mutating func clearParameter() {self._parameter = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _contractAddress: Concordium_V2_ContractAddress? = nil
    fileprivate var _receiveName: Concordium_V2_ReceiveName? = nil
    fileprivate var _parameter: Concordium_V2_Parameter? = nil
  }

  struct DuplicateCredIds: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ids: [Concordium_V2_CredentialRegistrationId] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct NonExistentCredIds: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ids: [Concordium_V2_CredentialRegistrationId] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Data generated as part of initializing a single contract instance.
struct Concordium_V2_ContractInitializedEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contract version.
  var contractVersion: Concordium_V2_ContractVersion = .v0

  /// Module with the source code of the contract.
  var originRef: Concordium_V2_ModuleRef {
    get {return _originRef ?? Concordium_V2_ModuleRef()}
    set {_originRef = newValue}
  }
  /// Returns true if `originRef` has been explicitly set.
  var hasOriginRef: Bool {return self._originRef != nil}
  /// Clears the value of `originRef`. Subsequent reads from it will return its default value.
  mutating func clearOriginRef() {self._originRef = nil}

  /// The newly assigned address of the contract.
  var address: Concordium_V2_ContractAddress {
    get {return _address ?? Concordium_V2_ContractAddress()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  /// The amount the instance was initialized with.
  var amount: Concordium_V2_Amount {
    get {return _amount ?? Concordium_V2_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  /// The name of the contract.
  var initName: Concordium_V2_InitName {
    get {return _initName ?? Concordium_V2_InitName()}
    set {_initName = newValue}
  }
  /// Returns true if `initName` has been explicitly set.
  var hasInitName: Bool {return self._initName != nil}
  /// Clears the value of `initName`. Subsequent reads from it will return its default value.
  mutating func clearInitName() {self._initName = nil}

  /// Any contract events that might have been genereated by the contract initialization.
  var events: [Concordium_V2_ContractEvent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _originRef: Concordium_V2_ModuleRef? = nil
  fileprivate var _address: Concordium_V2_ContractAddress? = nil
  fileprivate var _amount: Concordium_V2_Amount? = nil
  fileprivate var _initName: Concordium_V2_InitName? = nil
}

/// An event generated by a smart contract.
struct Concordium_V2_ContractEvent: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Data generated as part of updating a single contract instance.
/// In general a single Update transaction will
/// generate one or more of these events, together with possibly some transfers.
struct Concordium_V2_InstanceUpdatedEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contract version.
  var contractVersion: Concordium_V2_ContractVersion = .v0

  /// Address of the affected instance.
  var address: Concordium_V2_ContractAddress {
    get {return _address ?? Concordium_V2_ContractAddress()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  /// The origin of the message to the smart contract. This can be
  /// either an account or a smart contract.
  var instigator: Concordium_V2_Address {
    get {return _instigator ?? Concordium_V2_Address()}
    set {_instigator = newValue}
  }
  /// Returns true if `instigator` has been explicitly set.
  var hasInstigator: Bool {return self._instigator != nil}
  /// Clears the value of `instigator`. Subsequent reads from it will return its default value.
  mutating func clearInstigator() {self._instigator = nil}

  /// The amount the method was invoked with.
  var amount: Concordium_V2_Amount {
    get {return _amount ?? Concordium_V2_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  /// The parameter passed to the method.
  var parameter: Concordium_V2_Parameter {
    get {return _parameter ?? Concordium_V2_Parameter()}
    set {_parameter = newValue}
  }
  /// Returns true if `parameter` has been explicitly set.
  var hasParameter: Bool {return self._parameter != nil}
  /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
  mutating func clearParameter() {self._parameter = nil}

  /// The name of the method that was executed.
  var receiveName: Concordium_V2_ReceiveName {
    get {return _receiveName ?? Concordium_V2_ReceiveName()}
    set {_receiveName = newValue}
  }
  /// Returns true if `receiveName` has been explicitly set.
  var hasReceiveName: Bool {return self._receiveName != nil}
  /// Clears the value of `receiveName`. Subsequent reads from it will return its default value.
  mutating func clearReceiveName() {self._receiveName = nil}

  /// Any contract events that might have been generated by the contract execution.
  var events: [Concordium_V2_ContractEvent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _address: Concordium_V2_ContractAddress? = nil
  fileprivate var _instigator: Concordium_V2_Address? = nil
  fileprivate var _amount: Concordium_V2_Amount? = nil
  fileprivate var _parameter: Concordium_V2_Parameter? = nil
  fileprivate var _receiveName: Concordium_V2_ReceiveName? = nil
}

/// Effects produced by successful smart contract invocations.
/// A single invocation will produce a sequence of these effects.
struct Concordium_V2_ContractTraceElement: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var element: Concordium_V2_ContractTraceElement.OneOf_Element? = nil

  /// A contract instance was updated.
  var updated: Concordium_V2_InstanceUpdatedEvent {
    get {
      if case .updated(let v)? = element {return v}
      return Concordium_V2_InstanceUpdatedEvent()
    }
    set {element = .updated(newValue)}
  }

  /// A contract transferred an amount to an account.
  var transferred: Concordium_V2_ContractTraceElement.Transferred {
    get {
      if case .transferred(let v)? = element {return v}
      return Concordium_V2_ContractTraceElement.Transferred()
    }
    set {element = .transferred(newValue)}
  }

  /// A contract was interrupted.
  /// This occurs when a contract invokes another contract or makes a transfer to an account.
  var interrupted: Concordium_V2_ContractTraceElement.Interrupted {
    get {
      if case .interrupted(let v)? = element {return v}
      return Concordium_V2_ContractTraceElement.Interrupted()
    }
    set {element = .interrupted(newValue)}
  }

  /// A previously interrupted contract was resumed.
  var resumed: Concordium_V2_ContractTraceElement.Resumed {
    get {
      if case .resumed(let v)? = element {return v}
      return Concordium_V2_ContractTraceElement.Resumed()
    }
    set {element = .resumed(newValue)}
  }

  /// A contract was upgraded.
  var upgraded: Concordium_V2_ContractTraceElement.Upgraded {
    get {
      if case .upgraded(let v)? = element {return v}
      return Concordium_V2_ContractTraceElement.Upgraded()
    }
    set {element = .upgraded(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Element: Equatable, Sendable {
    /// A contract instance was updated.
    case updated(Concordium_V2_InstanceUpdatedEvent)
    /// A contract transferred an amount to an account.
    case transferred(Concordium_V2_ContractTraceElement.Transferred)
    /// A contract was interrupted.
    /// This occurs when a contract invokes another contract or makes a transfer to an account.
    case interrupted(Concordium_V2_ContractTraceElement.Interrupted)
    /// A previously interrupted contract was resumed.
    case resumed(Concordium_V2_ContractTraceElement.Resumed)
    /// A contract was upgraded.
    case upgraded(Concordium_V2_ContractTraceElement.Upgraded)

  }

  /// A contract transferred an amount to an account.
  struct Transferred: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Sender contract.
    var sender: Concordium_V2_ContractAddress {
      get {return _sender ?? Concordium_V2_ContractAddress()}
      set {_sender = newValue}
    }
    /// Returns true if `sender` has been explicitly set.
    var hasSender: Bool {return self._sender != nil}
    /// Clears the value of `sender`. Subsequent reads from it will return its default value.
    mutating func clearSender() {self._sender = nil}

    /// Amount transferred.
    var amount: Concordium_V2_Amount {
      get {return _amount ?? Concordium_V2_Amount()}
      set {_amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    var hasAmount: Bool {return self._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    mutating func clearAmount() {self._amount = nil}

    /// Receiver account.
    var receiver: Concordium_V2_AccountAddress {
      get {return _receiver ?? Concordium_V2_AccountAddress()}
      set {_receiver = newValue}
    }
    /// Returns true if `receiver` has been explicitly set.
    var hasReceiver: Bool {return self._receiver != nil}
    /// Clears the value of `receiver`. Subsequent reads from it will return its default value.
    mutating func clearReceiver() {self._receiver = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sender: Concordium_V2_ContractAddress? = nil
    fileprivate var _amount: Concordium_V2_Amount? = nil
    fileprivate var _receiver: Concordium_V2_AccountAddress? = nil
  }

  /// A contract was interrupted.
  /// This occurs when a contract invokes another contract or makes a transfer to an account.
  struct Interrupted: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The contract interrupted.
    var address: Concordium_V2_ContractAddress {
      get {return _address ?? Concordium_V2_ContractAddress()}
      set {_address = newValue}
    }
    /// Returns true if `address` has been explicitly set.
    var hasAddress: Bool {return self._address != nil}
    /// Clears the value of `address`. Subsequent reads from it will return its default value.
    mutating func clearAddress() {self._address = nil}

    /// The events generated up until the interruption.
    var events: [Concordium_V2_ContractEvent] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _address: Concordium_V2_ContractAddress? = nil
  }

  /// A previously interrupted contract was resumed.
  struct Resumed: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The contract resumed.
    var address: Concordium_V2_ContractAddress {
      get {return _address ?? Concordium_V2_ContractAddress()}
      set {_address = newValue}
    }
    /// Returns true if `address` has been explicitly set.
    var hasAddress: Bool {return self._address != nil}
    /// Clears the value of `address`. Subsequent reads from it will return its default value.
    mutating func clearAddress() {self._address = nil}

    /// Whether the action that caused the interruption (invoke contract or make transfer) was successful or not.
    var success: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _address: Concordium_V2_ContractAddress? = nil
  }

  /// A previously interrupted contract was resumed.
  struct Upgraded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The that was upgraded.
    var address: Concordium_V2_ContractAddress {
      get {return _address ?? Concordium_V2_ContractAddress()}
      set {_address = newValue}
    }
    /// Returns true if `address` has been explicitly set.
    var hasAddress: Bool {return self._address != nil}
    /// Clears the value of `address`. Subsequent reads from it will return its default value.
    mutating func clearAddress() {self._address = nil}

    /// The module from which the contract was upgraded.
    var from: Concordium_V2_ModuleRef {
      get {return _from ?? Concordium_V2_ModuleRef()}
      set {_from = newValue}
    }
    /// Returns true if `from` has been explicitly set.
    var hasFrom: Bool {return self._from != nil}
    /// Clears the value of `from`. Subsequent reads from it will return its default value.
    mutating func clearFrom() {self._from = nil}

    /// The module to which it was upgraded.
    var to: Concordium_V2_ModuleRef {
      get {return _to ?? Concordium_V2_ModuleRef()}
      set {_to = newValue}
    }
    /// Returns true if `to` has been explicitly set.
    var hasTo: Bool {return self._to != nil}
    /// Clears the value of `to`. Subsequent reads from it will return its default value.
    mutating func clearTo() {self._to = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _address: Concordium_V2_ContractAddress? = nil
    fileprivate var _from: Concordium_V2_ModuleRef? = nil
    fileprivate var _to: Concordium_V2_ModuleRef? = nil
  }

  init() {}
}

/// Result of a successful change of baker keys.
struct Concordium_V2_BakerKeysEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the baker whose keys were changed.
  var bakerID: Concordium_V2_BakerId {
    get {return _bakerID ?? Concordium_V2_BakerId()}
    set {_bakerID = newValue}
  }
  /// Returns true if `bakerID` has been explicitly set.
  var hasBakerID: Bool {return self._bakerID != nil}
  /// Clears the value of `bakerID`. Subsequent reads from it will return its default value.
  mutating func clearBakerID() {self._bakerID = nil}

  /// Account address of the baker.
  var account: Concordium_V2_AccountAddress {
    get {return _account ?? Concordium_V2_AccountAddress()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  /// The new public key for verifying block signatures.
  var signKey: Concordium_V2_BakerSignatureVerifyKey {
    get {return _signKey ?? Concordium_V2_BakerSignatureVerifyKey()}
    set {_signKey = newValue}
  }
  /// Returns true if `signKey` has been explicitly set.
  var hasSignKey: Bool {return self._signKey != nil}
  /// Clears the value of `signKey`. Subsequent reads from it will return its default value.
  mutating func clearSignKey() {self._signKey = nil}

  /// The new public key for verifying whether the baker won the block
  /// lottery.
  var electionKey: Concordium_V2_BakerElectionVerifyKey {
    get {return _electionKey ?? Concordium_V2_BakerElectionVerifyKey()}
    set {_electionKey = newValue}
  }
  /// Returns true if `electionKey` has been explicitly set.
  var hasElectionKey: Bool {return self._electionKey != nil}
  /// Clears the value of `electionKey`. Subsequent reads from it will return its default value.
  mutating func clearElectionKey() {self._electionKey = nil}

  /// The new public key for verifying finalization records.
  var aggregationKey: Concordium_V2_BakerAggregationVerifyKey {
    get {return _aggregationKey ?? Concordium_V2_BakerAggregationVerifyKey()}
    set {_aggregationKey = newValue}
  }
  /// Returns true if `aggregationKey` has been explicitly set.
  var hasAggregationKey: Bool {return self._aggregationKey != nil}
  /// Clears the value of `aggregationKey`. Subsequent reads from it will return its default value.
  mutating func clearAggregationKey() {self._aggregationKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bakerID: Concordium_V2_BakerId? = nil
  fileprivate var _account: Concordium_V2_AccountAddress? = nil
  fileprivate var _signKey: Concordium_V2_BakerSignatureVerifyKey? = nil
  fileprivate var _electionKey: Concordium_V2_BakerElectionVerifyKey? = nil
  fileprivate var _aggregationKey: Concordium_V2_BakerAggregationVerifyKey? = nil
}

/// A memo which can be included as part of a transfer. Max size is 256 bytes.
struct Concordium_V2_Memo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Concordium_V2_BakerStakeUpdatedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Affected baker.
  var bakerID: Concordium_V2_BakerId {
    get {return _bakerID ?? Concordium_V2_BakerId()}
    set {_bakerID = newValue}
  }
  /// Returns true if `bakerID` has been explicitly set.
  var hasBakerID: Bool {return self._bakerID != nil}
  /// Clears the value of `bakerID`. Subsequent reads from it will return its default value.
  mutating func clearBakerID() {self._bakerID = nil}

  /// New stake.
  var newStake: Concordium_V2_Amount {
    get {return _newStake ?? Concordium_V2_Amount()}
    set {_newStake = newValue}
  }
  /// Returns true if `newStake` has been explicitly set.
  var hasNewStake: Bool {return self._newStake != nil}
  /// Clears the value of `newStake`. Subsequent reads from it will return its default value.
  mutating func clearNewStake() {self._newStake = nil}

  /// A boolean which indicates whether it increased
  /// (`true`) or decreased (`false`).
  var increased: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bakerID: Concordium_V2_BakerId? = nil
  fileprivate var _newStake: Concordium_V2_Amount? = nil
}

/// Event generated when one or more encrypted amounts are consumed from the account.
struct Concordium_V2_EncryptedAmountRemovedEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The affected account.
  var account: Concordium_V2_AccountAddress {
    get {return _account ?? Concordium_V2_AccountAddress()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  /// The new self encrypted amount on the affected account.
  var newAmount: Concordium_V2_EncryptedAmount {
    get {return _newAmount ?? Concordium_V2_EncryptedAmount()}
    set {_newAmount = newValue}
  }
  /// Returns true if `newAmount` has been explicitly set.
  var hasNewAmount: Bool {return self._newAmount != nil}
  /// Clears the value of `newAmount`. Subsequent reads from it will return its default value.
  mutating func clearNewAmount() {self._newAmount = nil}

  /// The input encrypted amount that was removed.
  var inputAmount: Concordium_V2_EncryptedAmount {
    get {return _inputAmount ?? Concordium_V2_EncryptedAmount()}
    set {_inputAmount = newValue}
  }
  /// Returns true if `inputAmount` has been explicitly set.
  var hasInputAmount: Bool {return self._inputAmount != nil}
  /// Clears the value of `inputAmount`. Subsequent reads from it will return its default value.
  mutating func clearInputAmount() {self._inputAmount = nil}

  /// The index indicating which amounts were used.
  var upToIndex: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: Concordium_V2_AccountAddress? = nil
  fileprivate var _newAmount: Concordium_V2_EncryptedAmount? = nil
  fileprivate var _inputAmount: Concordium_V2_EncryptedAmount? = nil
}

/// Event generated when an account receives a new encrypted amount.
struct Concordium_V2_NewEncryptedAmountEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account onto which the amount was added.
  var receiver: Concordium_V2_AccountAddress {
    get {return _receiver ?? Concordium_V2_AccountAddress()}
    set {_receiver = newValue}
  }
  /// Returns true if `receiver` has been explicitly set.
  var hasReceiver: Bool {return self._receiver != nil}
  /// Clears the value of `receiver`. Subsequent reads from it will return its default value.
  mutating func clearReceiver() {self._receiver = nil}

  /// The index the amount was assigned.
  var newIndex: UInt64 = 0

  /// The encrypted amount that was added.
  var encryptedAmount: Concordium_V2_EncryptedAmount {
    get {return _encryptedAmount ?? Concordium_V2_EncryptedAmount()}
    set {_encryptedAmount = newValue}
  }
  /// Returns true if `encryptedAmount` has been explicitly set.
  var hasEncryptedAmount: Bool {return self._encryptedAmount != nil}
  /// Clears the value of `encryptedAmount`. Subsequent reads from it will return its default value.
  mutating func clearEncryptedAmount() {self._encryptedAmount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _receiver: Concordium_V2_AccountAddress? = nil
  fileprivate var _encryptedAmount: Concordium_V2_EncryptedAmount? = nil
}

struct Concordium_V2_EncryptedSelfAmountAddedEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The affected account.
  var account: Concordium_V2_AccountAddress {
    get {return _account ?? Concordium_V2_AccountAddress()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  /// The new self encrypted amount of the account.
  var newAmount: Concordium_V2_EncryptedAmount {
    get {return _newAmount ?? Concordium_V2_EncryptedAmount()}
    set {_newAmount = newValue}
  }
  /// Returns true if `newAmount` has been explicitly set.
  var hasNewAmount: Bool {return self._newAmount != nil}
  /// Clears the value of `newAmount`. Subsequent reads from it will return its default value.
  mutating func clearNewAmount() {self._newAmount = nil}

  /// The amount that was transferred from public to encrypted balance.
  var amount: Concordium_V2_Amount {
    get {return _amount ?? Concordium_V2_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: Concordium_V2_AccountAddress? = nil
  fileprivate var _newAmount: Concordium_V2_EncryptedAmount? = nil
  fileprivate var _amount: Concordium_V2_Amount? = nil
}

/// Data registered on the chain with a register data transaction.
struct Concordium_V2_RegisteredData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Events that may result from the ConfigureBaker transaction.
struct Concordium_V2_BakerEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: Concordium_V2_BakerEvent.OneOf_Event? = nil

  /// A baker was added.
  var bakerAdded: Concordium_V2_BakerEvent.BakerAdded {
    get {
      if case .bakerAdded(let v)? = event {return v}
      return Concordium_V2_BakerEvent.BakerAdded()
    }
    set {event = .bakerAdded(newValue)}
  }

  /// A baker was removed.
  var bakerRemoved: Concordium_V2_BakerId {
    get {
      if case .bakerRemoved(let v)? = event {return v}
      return Concordium_V2_BakerId()
    }
    set {event = .bakerRemoved(newValue)}
  }

  /// The baker's stake was increased.
  var bakerStakeIncreased: Concordium_V2_BakerEvent.BakerStakeIncreased {
    get {
      if case .bakerStakeIncreased(let v)? = event {return v}
      return Concordium_V2_BakerEvent.BakerStakeIncreased()
    }
    set {event = .bakerStakeIncreased(newValue)}
  }

  /// The baker's stake was decreased.
  var bakerStakeDecreased: Concordium_V2_BakerEvent.BakerStakeDecreased {
    get {
      if case .bakerStakeDecreased(let v)? = event {return v}
      return Concordium_V2_BakerEvent.BakerStakeDecreased()
    }
    set {event = .bakerStakeDecreased(newValue)}
  }

  /// The baker's setting for restaking earnings was updated.
  var bakerRestakeEarningsUpdated: Concordium_V2_BakerEvent.BakerRestakeEarningsUpdated {
    get {
      if case .bakerRestakeEarningsUpdated(let v)? = event {return v}
      return Concordium_V2_BakerEvent.BakerRestakeEarningsUpdated()
    }
    set {event = .bakerRestakeEarningsUpdated(newValue)}
  }

  /// Baker keys were updated.
  var bakerKeysUpdated: Concordium_V2_BakerKeysEvent {
    get {
      if case .bakerKeysUpdated(let v)? = event {return v}
      return Concordium_V2_BakerKeysEvent()
    }
    set {event = .bakerKeysUpdated(newValue)}
  }

  /// The baker's open status was updated.
  var bakerSetOpenStatus: Concordium_V2_BakerEvent.BakerSetOpenStatus {
    get {
      if case .bakerSetOpenStatus(let v)? = event {return v}
      return Concordium_V2_BakerEvent.BakerSetOpenStatus()
    }
    set {event = .bakerSetOpenStatus(newValue)}
  }

  /// The baker's metadata URL was updated.
  var bakerSetMetadataURL: Concordium_V2_BakerEvent.BakerSetMetadataUrl {
    get {
      if case .bakerSetMetadataURL(let v)? = event {return v}
      return Concordium_V2_BakerEvent.BakerSetMetadataUrl()
    }
    set {event = .bakerSetMetadataURL(newValue)}
  }

  /// The baker's transaction fee commission was updated.
  var bakerSetTransactionFeeCommission: Concordium_V2_BakerEvent.BakerSetTransactionFeeCommission {
    get {
      if case .bakerSetTransactionFeeCommission(let v)? = event {return v}
      return Concordium_V2_BakerEvent.BakerSetTransactionFeeCommission()
    }
    set {event = .bakerSetTransactionFeeCommission(newValue)}
  }

  /// The baker's baking reward commission was updated.
  var bakerSetBakingRewardCommission: Concordium_V2_BakerEvent.BakerSetBakingRewardCommission {
    get {
      if case .bakerSetBakingRewardCommission(let v)? = event {return v}
      return Concordium_V2_BakerEvent.BakerSetBakingRewardCommission()
    }
    set {event = .bakerSetBakingRewardCommission(newValue)}
  }

  /// The baker's finalization reward commission was updated.
  var bakerSetFinalizationRewardCommission: Concordium_V2_BakerEvent.BakerSetFinalizationRewardCommission {
    get {
      if case .bakerSetFinalizationRewardCommission(let v)? = event {return v}
      return Concordium_V2_BakerEvent.BakerSetFinalizationRewardCommission()
    }
    set {event = .bakerSetFinalizationRewardCommission(newValue)}
  }

  /// An existing delegator was removed.
  var delegationRemoved: Concordium_V2_BakerEvent.DelegationRemoved {
    get {
      if case .delegationRemoved(let v)? = event {return v}
      return Concordium_V2_BakerEvent.DelegationRemoved()
    }
    set {event = .delegationRemoved(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable, Sendable {
    /// A baker was added.
    case bakerAdded(Concordium_V2_BakerEvent.BakerAdded)
    /// A baker was removed.
    case bakerRemoved(Concordium_V2_BakerId)
    /// The baker's stake was increased.
    case bakerStakeIncreased(Concordium_V2_BakerEvent.BakerStakeIncreased)
    /// The baker's stake was decreased.
    case bakerStakeDecreased(Concordium_V2_BakerEvent.BakerStakeDecreased)
    /// The baker's setting for restaking earnings was updated.
    case bakerRestakeEarningsUpdated(Concordium_V2_BakerEvent.BakerRestakeEarningsUpdated)
    /// Baker keys were updated.
    case bakerKeysUpdated(Concordium_V2_BakerKeysEvent)
    /// The baker's open status was updated.
    case bakerSetOpenStatus(Concordium_V2_BakerEvent.BakerSetOpenStatus)
    /// The baker's metadata URL was updated.
    case bakerSetMetadataURL(Concordium_V2_BakerEvent.BakerSetMetadataUrl)
    /// The baker's transaction fee commission was updated.
    case bakerSetTransactionFeeCommission(Concordium_V2_BakerEvent.BakerSetTransactionFeeCommission)
    /// The baker's baking reward commission was updated.
    case bakerSetBakingRewardCommission(Concordium_V2_BakerEvent.BakerSetBakingRewardCommission)
    /// The baker's finalization reward commission was updated.
    case bakerSetFinalizationRewardCommission(Concordium_V2_BakerEvent.BakerSetFinalizationRewardCommission)
    /// An existing delegator was removed.
    case delegationRemoved(Concordium_V2_BakerEvent.DelegationRemoved)

  }

  /// A baker was added.
  struct BakerAdded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The keys with which the baker registered.
    var keysEvent: Concordium_V2_BakerKeysEvent {
      get {return _keysEvent ?? Concordium_V2_BakerKeysEvent()}
      set {_keysEvent = newValue}
    }
    /// Returns true if `keysEvent` has been explicitly set.
    var hasKeysEvent: Bool {return self._keysEvent != nil}
    /// Clears the value of `keysEvent`. Subsequent reads from it will return its default value.
    mutating func clearKeysEvent() {self._keysEvent = nil}

    /// The amount the account staked to become a baker. This amount is
    /// locked.
    var stake: Concordium_V2_Amount {
      get {return _stake ?? Concordium_V2_Amount()}
      set {_stake = newValue}
    }
    /// Returns true if `stake` has been explicitly set.
    var hasStake: Bool {return self._stake != nil}
    /// Clears the value of `stake`. Subsequent reads from it will return its default value.
    mutating func clearStake() {self._stake = nil}

    /// Whether the baker will automatically add earnings to their stake or
    /// not.
    var restakeEarnings: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _keysEvent: Concordium_V2_BakerKeysEvent? = nil
    fileprivate var _stake: Concordium_V2_Amount? = nil
  }

  /// Baker stake increased.
  struct BakerStakeIncreased: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Baker's id.
    var bakerID: Concordium_V2_BakerId {
      get {return _bakerID ?? Concordium_V2_BakerId()}
      set {_bakerID = newValue}
    }
    /// Returns true if `bakerID` has been explicitly set.
    var hasBakerID: Bool {return self._bakerID != nil}
    /// Clears the value of `bakerID`. Subsequent reads from it will return its default value.
    mutating func clearBakerID() {self._bakerID = nil}

    /// The new stake.
    var newStake: Concordium_V2_Amount {
      get {return _newStake ?? Concordium_V2_Amount()}
      set {_newStake = newValue}
    }
    /// Returns true if `newStake` has been explicitly set.
    var hasNewStake: Bool {return self._newStake != nil}
    /// Clears the value of `newStake`. Subsequent reads from it will return its default value.
    mutating func clearNewStake() {self._newStake = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bakerID: Concordium_V2_BakerId? = nil
    fileprivate var _newStake: Concordium_V2_Amount? = nil
  }

  struct BakerStakeDecreased: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Baker's id.
    var bakerID: Concordium_V2_BakerId {
      get {return _bakerID ?? Concordium_V2_BakerId()}
      set {_bakerID = newValue}
    }
    /// Returns true if `bakerID` has been explicitly set.
    var hasBakerID: Bool {return self._bakerID != nil}
    /// Clears the value of `bakerID`. Subsequent reads from it will return its default value.
    mutating func clearBakerID() {self._bakerID = nil}

    /// The new stake.
    var newStake: Concordium_V2_Amount {
      get {return _newStake ?? Concordium_V2_Amount()}
      set {_newStake = newValue}
    }
    /// Returns true if `newStake` has been explicitly set.
    var hasNewStake: Bool {return self._newStake != nil}
    /// Clears the value of `newStake`. Subsequent reads from it will return its default value.
    mutating func clearNewStake() {self._newStake = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bakerID: Concordium_V2_BakerId? = nil
    fileprivate var _newStake: Concordium_V2_Amount? = nil
  }

  struct BakerRestakeEarningsUpdated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Baker's id.
    var bakerID: Concordium_V2_BakerId {
      get {return _bakerID ?? Concordium_V2_BakerId()}
      set {_bakerID = newValue}
    }
    /// Returns true if `bakerID` has been explicitly set.
    var hasBakerID: Bool {return self._bakerID != nil}
    /// Clears the value of `bakerID`. Subsequent reads from it will return its default value.
    mutating func clearBakerID() {self._bakerID = nil}

    /// The new value of the flag.
    var restakeEarnings: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bakerID: Concordium_V2_BakerId? = nil
  }

  /// Updated open status for a baker pool.
  struct BakerSetOpenStatus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Baker's id.
    var bakerID: Concordium_V2_BakerId {
      get {return _bakerID ?? Concordium_V2_BakerId()}
      set {_bakerID = newValue}
    }
    /// Returns true if `bakerID` has been explicitly set.
    var hasBakerID: Bool {return self._bakerID != nil}
    /// Clears the value of `bakerID`. Subsequent reads from it will return its default value.
    mutating func clearBakerID() {self._bakerID = nil}

    /// The new open status.
    var openStatus: Concordium_V2_OpenStatus = .openForAll

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bakerID: Concordium_V2_BakerId? = nil
  }

  /// Updated metadata url for a baker pool.
  struct BakerSetMetadataUrl: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Baker's id.
    var bakerID: Concordium_V2_BakerId {
      get {return _bakerID ?? Concordium_V2_BakerId()}
      set {_bakerID = newValue}
    }
    /// Returns true if `bakerID` has been explicitly set.
    var hasBakerID: Bool {return self._bakerID != nil}
    /// Clears the value of `bakerID`. Subsequent reads from it will return its default value.
    mutating func clearBakerID() {self._bakerID = nil}

    /// The URL.
    var url: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bakerID: Concordium_V2_BakerId? = nil
  }

  /// Updated transaction fee commission for a baker pool.
  struct BakerSetTransactionFeeCommission: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Baker's id.
    var bakerID: Concordium_V2_BakerId {
      get {return _bakerID ?? Concordium_V2_BakerId()}
      set {_bakerID = newValue}
    }
    /// Returns true if `bakerID` has been explicitly set.
    var hasBakerID: Bool {return self._bakerID != nil}
    /// Clears the value of `bakerID`. Subsequent reads from it will return its default value.
    mutating func clearBakerID() {self._bakerID = nil}

    /// The transaction fee commission.
    var transactionFeeCommission: Concordium_V2_AmountFraction {
      get {return _transactionFeeCommission ?? Concordium_V2_AmountFraction()}
      set {_transactionFeeCommission = newValue}
    }
    /// Returns true if `transactionFeeCommission` has been explicitly set.
    var hasTransactionFeeCommission: Bool {return self._transactionFeeCommission != nil}
    /// Clears the value of `transactionFeeCommission`. Subsequent reads from it will return its default value.
    mutating func clearTransactionFeeCommission() {self._transactionFeeCommission = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bakerID: Concordium_V2_BakerId? = nil
    fileprivate var _transactionFeeCommission: Concordium_V2_AmountFraction? = nil
  }

  /// Updated baking reward commission for baker pool
  struct BakerSetBakingRewardCommission: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Baker's id
    var bakerID: Concordium_V2_BakerId {
      get {return _bakerID ?? Concordium_V2_BakerId()}
      set {_bakerID = newValue}
    }
    /// Returns true if `bakerID` has been explicitly set.
    var hasBakerID: Bool {return self._bakerID != nil}
    /// Clears the value of `bakerID`. Subsequent reads from it will return its default value.
    mutating func clearBakerID() {self._bakerID = nil}

    /// The baking reward commission
    var bakingRewardCommission: Concordium_V2_AmountFraction {
      get {return _bakingRewardCommission ?? Concordium_V2_AmountFraction()}
      set {_bakingRewardCommission = newValue}
    }
    /// Returns true if `bakingRewardCommission` has been explicitly set.
    var hasBakingRewardCommission: Bool {return self._bakingRewardCommission != nil}
    /// Clears the value of `bakingRewardCommission`. Subsequent reads from it will return its default value.
    mutating func clearBakingRewardCommission() {self._bakingRewardCommission = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bakerID: Concordium_V2_BakerId? = nil
    fileprivate var _bakingRewardCommission: Concordium_V2_AmountFraction? = nil
  }

  /// Updated finalization reward commission for baker pool
  struct BakerSetFinalizationRewardCommission: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Baker's id
    var bakerID: Concordium_V2_BakerId {
      get {return _bakerID ?? Concordium_V2_BakerId()}
      set {_bakerID = newValue}
    }
    /// Returns true if `bakerID` has been explicitly set.
    var hasBakerID: Bool {return self._bakerID != nil}
    /// Clears the value of `bakerID`. Subsequent reads from it will return its default value.
    mutating func clearBakerID() {self._bakerID = nil}

    /// The finalization reward commission
    var finalizationRewardCommission: Concordium_V2_AmountFraction {
      get {return _finalizationRewardCommission ?? Concordium_V2_AmountFraction()}
      set {_finalizationRewardCommission = newValue}
    }
    /// Returns true if `finalizationRewardCommission` has been explicitly set.
    var hasFinalizationRewardCommission: Bool {return self._finalizationRewardCommission != nil}
    /// Clears the value of `finalizationRewardCommission`. Subsequent reads from it will return its default value.
    mutating func clearFinalizationRewardCommission() {self._finalizationRewardCommission = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bakerID: Concordium_V2_BakerId? = nil
    fileprivate var _finalizationRewardCommission: Concordium_V2_AmountFraction? = nil
  }

  /// Removed an existing delegator.
  struct DelegationRemoved: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Delegator's id.
    var delegatorID: Concordium_V2_DelegatorId {
      get {return _delegatorID ?? Concordium_V2_DelegatorId()}
      set {_delegatorID = newValue}
    }
    /// Returns true if `delegatorID` has been explicitly set.
    var hasDelegatorID: Bool {return self._delegatorID != nil}
    /// Clears the value of `delegatorID`. Subsequent reads from it will return its default value.
    mutating func clearDelegatorID() {self._delegatorID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _delegatorID: Concordium_V2_DelegatorId? = nil
  }

  init() {}
}

/// The identifier for a delegator.
struct Concordium_V2_DelegatorId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Concordium_V2_AccountIndex {
    get {return _id ?? Concordium_V2_AccountIndex()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: Concordium_V2_AccountIndex? = nil
}

struct Concordium_V2_DelegationEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: Concordium_V2_DelegationEvent.OneOf_Event? = nil

  /// The delegator's stake increased.
  var delegationStakeIncreased: Concordium_V2_DelegationEvent.DelegationStakeIncreased {
    get {
      if case .delegationStakeIncreased(let v)? = event {return v}
      return Concordium_V2_DelegationEvent.DelegationStakeIncreased()
    }
    set {event = .delegationStakeIncreased(newValue)}
  }

  /// The delegator's stake decreased.
  var delegationStakeDecreased: Concordium_V2_DelegationEvent.DelegationStakeDecreased {
    get {
      if case .delegationStakeDecreased(let v)? = event {return v}
      return Concordium_V2_DelegationEvent.DelegationStakeDecreased()
    }
    set {event = .delegationStakeDecreased(newValue)}
  }

  /// The delegator's restaking setting was updated.
  var delegationSetRestakeEarnings: Concordium_V2_DelegationEvent.DelegationSetRestakeEarnings {
    get {
      if case .delegationSetRestakeEarnings(let v)? = event {return v}
      return Concordium_V2_DelegationEvent.DelegationSetRestakeEarnings()
    }
    set {event = .delegationSetRestakeEarnings(newValue)}
  }

  /// The delegator's delegation target was updated.
  var delegationSetDelegationTarget: Concordium_V2_DelegationEvent.DelegationSetDelegationTarget {
    get {
      if case .delegationSetDelegationTarget(let v)? = event {return v}
      return Concordium_V2_DelegationEvent.DelegationSetDelegationTarget()
    }
    set {event = .delegationSetDelegationTarget(newValue)}
  }

  /// A delegator was added.
  var delegationAdded: Concordium_V2_DelegatorId {
    get {
      if case .delegationAdded(let v)? = event {return v}
      return Concordium_V2_DelegatorId()
    }
    set {event = .delegationAdded(newValue)}
  }

  /// A delegator was removed.
  var delegationRemoved: Concordium_V2_DelegatorId {
    get {
      if case .delegationRemoved(let v)? = event {return v}
      return Concordium_V2_DelegatorId()
    }
    set {event = .delegationRemoved(newValue)}
  }

  /// An existing baker was removed.
  var bakerRemoved: Concordium_V2_DelegationEvent.BakerRemoved {
    get {
      if case .bakerRemoved(let v)? = event {return v}
      return Concordium_V2_DelegationEvent.BakerRemoved()
    }
    set {event = .bakerRemoved(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable, Sendable {
    /// The delegator's stake increased.
    case delegationStakeIncreased(Concordium_V2_DelegationEvent.DelegationStakeIncreased)
    /// The delegator's stake decreased.
    case delegationStakeDecreased(Concordium_V2_DelegationEvent.DelegationStakeDecreased)
    /// The delegator's restaking setting was updated.
    case delegationSetRestakeEarnings(Concordium_V2_DelegationEvent.DelegationSetRestakeEarnings)
    /// The delegator's delegation target was updated.
    case delegationSetDelegationTarget(Concordium_V2_DelegationEvent.DelegationSetDelegationTarget)
    /// A delegator was added.
    case delegationAdded(Concordium_V2_DelegatorId)
    /// A delegator was removed.
    case delegationRemoved(Concordium_V2_DelegatorId)
    /// An existing baker was removed.
    case bakerRemoved(Concordium_V2_DelegationEvent.BakerRemoved)

  }

  struct DelegationStakeIncreased: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Delegator's id
    var delegatorID: Concordium_V2_DelegatorId {
      get {return _delegatorID ?? Concordium_V2_DelegatorId()}
      set {_delegatorID = newValue}
    }
    /// Returns true if `delegatorID` has been explicitly set.
    var hasDelegatorID: Bool {return self._delegatorID != nil}
    /// Clears the value of `delegatorID`. Subsequent reads from it will return its default value.
    mutating func clearDelegatorID() {self._delegatorID = nil}

    /// New stake
    var newStake: Concordium_V2_Amount {
      get {return _newStake ?? Concordium_V2_Amount()}
      set {_newStake = newValue}
    }
    /// Returns true if `newStake` has been explicitly set.
    var hasNewStake: Bool {return self._newStake != nil}
    /// Clears the value of `newStake`. Subsequent reads from it will return its default value.
    mutating func clearNewStake() {self._newStake = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _delegatorID: Concordium_V2_DelegatorId? = nil
    fileprivate var _newStake: Concordium_V2_Amount? = nil
  }

  struct DelegationStakeDecreased: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Delegator's id
    var delegatorID: Concordium_V2_DelegatorId {
      get {return _delegatorID ?? Concordium_V2_DelegatorId()}
      set {_delegatorID = newValue}
    }
    /// Returns true if `delegatorID` has been explicitly set.
    var hasDelegatorID: Bool {return self._delegatorID != nil}
    /// Clears the value of `delegatorID`. Subsequent reads from it will return its default value.
    mutating func clearDelegatorID() {self._delegatorID = nil}

    /// New stake
    var newStake: Concordium_V2_Amount {
      get {return _newStake ?? Concordium_V2_Amount()}
      set {_newStake = newValue}
    }
    /// Returns true if `newStake` has been explicitly set.
    var hasNewStake: Bool {return self._newStake != nil}
    /// Clears the value of `newStake`. Subsequent reads from it will return its default value.
    mutating func clearNewStake() {self._newStake = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _delegatorID: Concordium_V2_DelegatorId? = nil
    fileprivate var _newStake: Concordium_V2_Amount? = nil
  }

  struct DelegationSetRestakeEarnings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Delegator's id
    var delegatorID: Concordium_V2_DelegatorId {
      get {return _delegatorID ?? Concordium_V2_DelegatorId()}
      set {_delegatorID = newValue}
    }
    /// Returns true if `delegatorID` has been explicitly set.
    var hasDelegatorID: Bool {return self._delegatorID != nil}
    /// Clears the value of `delegatorID`. Subsequent reads from it will return its default value.
    mutating func clearDelegatorID() {self._delegatorID = nil}

    /// Whether earnings will be restaked
    var restakeEarnings: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _delegatorID: Concordium_V2_DelegatorId? = nil
  }

  struct DelegationSetDelegationTarget: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Delegator's id
    var delegatorID: Concordium_V2_DelegatorId {
      get {return _delegatorID ?? Concordium_V2_DelegatorId()}
      set {_delegatorID = newValue}
    }
    /// Returns true if `delegatorID` has been explicitly set.
    var hasDelegatorID: Bool {return self._delegatorID != nil}
    /// Clears the value of `delegatorID`. Subsequent reads from it will return its default value.
    mutating func clearDelegatorID() {self._delegatorID = nil}

    /// New delegation target
    var delegationTarget: Concordium_V2_DelegationTarget {
      get {return _delegationTarget ?? Concordium_V2_DelegationTarget()}
      set {_delegationTarget = newValue}
    }
    /// Returns true if `delegationTarget` has been explicitly set.
    var hasDelegationTarget: Bool {return self._delegationTarget != nil}
    /// Clears the value of `delegationTarget`. Subsequent reads from it will return its default value.
    mutating func clearDelegationTarget() {self._delegationTarget = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _delegatorID: Concordium_V2_DelegatorId? = nil
    fileprivate var _delegationTarget: Concordium_V2_DelegationTarget? = nil
  }

  struct BakerRemoved: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Baker's id
    var bakerID: Concordium_V2_BakerId {
      get {return _bakerID ?? Concordium_V2_BakerId()}
      set {_bakerID = newValue}
    }
    /// Returns true if `bakerID` has been explicitly set.
    var hasBakerID: Bool {return self._bakerID != nil}
    /// Clears the value of `bakerID`. Subsequent reads from it will return its default value.
    mutating func clearBakerID() {self._bakerID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bakerID: Concordium_V2_BakerId? = nil
  }

  init() {}
}

/// Effects of an account transaction. All variants except `None`
/// correspond to a unique transaction that was successful.
struct Concordium_V2_AccountTransactionEffects: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var effect: Concordium_V2_AccountTransactionEffects.OneOf_Effect? = nil

  /// No effects other than payment from this transaction.
  /// The rejection reason indicates why the transaction failed.
  var none: Concordium_V2_AccountTransactionEffects.None {
    get {
      if case .none(let v)? = effect {return v}
      return Concordium_V2_AccountTransactionEffects.None()
    }
    set {effect = .none(newValue)}
  }

  /// A smart contract module with the attached reference was deployed.
  var moduleDeployed: Concordium_V2_ModuleRef {
    get {
      if case .moduleDeployed(let v)? = effect {return v}
      return Concordium_V2_ModuleRef()
    }
    set {effect = .moduleDeployed(newValue)}
  }

  /// A smart contract was initialized.
  var contractInitialized: Concordium_V2_ContractInitializedEvent {
    get {
      if case .contractInitialized(let v)? = effect {return v}
      return Concordium_V2_ContractInitializedEvent()
    }
    set {effect = .contractInitialized(newValue)}
  }

  /// A smart contract instance updated was issued.
  var contractUpdateIssued: Concordium_V2_AccountTransactionEffects.ContractUpdateIssued {
    get {
      if case .contractUpdateIssued(let v)? = effect {return v}
      return Concordium_V2_AccountTransactionEffects.ContractUpdateIssued()
    }
    set {effect = .contractUpdateIssued(newValue)}
  }

  /// A simple account to account transfer occurred.
  var accountTransfer: Concordium_V2_AccountTransactionEffects.AccountTransfer {
    get {
      if case .accountTransfer(let v)? = effect {return v}
      return Concordium_V2_AccountTransactionEffects.AccountTransfer()
    }
    set {effect = .accountTransfer(newValue)}
  }

  /// A baker was added.
  var bakerAdded: Concordium_V2_BakerEvent.BakerAdded {
    get {
      if case .bakerAdded(let v)? = effect {return v}
      return Concordium_V2_BakerEvent.BakerAdded()
    }
    set {effect = .bakerAdded(newValue)}
  }

  /// A baker was removed.
  var bakerRemoved: Concordium_V2_BakerId {
    get {
      if case .bakerRemoved(let v)? = effect {return v}
      return Concordium_V2_BakerId()
    }
    set {effect = .bakerRemoved(newValue)}
  }

  /// A baker's stake was updated.
  var bakerStakeUpdated: Concordium_V2_AccountTransactionEffects.BakerStakeUpdated {
    get {
      if case .bakerStakeUpdated(let v)? = effect {return v}
      return Concordium_V2_AccountTransactionEffects.BakerStakeUpdated()
    }
    set {effect = .bakerStakeUpdated(newValue)}
  }

  /// A baker's restake earnings setting was updated.
  var bakerRestakeEarningsUpdated: Concordium_V2_BakerEvent.BakerRestakeEarningsUpdated {
    get {
      if case .bakerRestakeEarningsUpdated(let v)? = effect {return v}
      return Concordium_V2_BakerEvent.BakerRestakeEarningsUpdated()
    }
    set {effect = .bakerRestakeEarningsUpdated(newValue)}
  }

  /// A baker's keys were updated.
  var bakerKeysUpdated: Concordium_V2_BakerKeysEvent {
    get {
      if case .bakerKeysUpdated(let v)? = effect {return v}
      return Concordium_V2_BakerKeysEvent()
    }
    set {effect = .bakerKeysUpdated(newValue)}
  }

  /// An encrypted amount was transferred.
  var encryptedAmountTransferred: Concordium_V2_AccountTransactionEffects.EncryptedAmountTransferred {
    get {
      if case .encryptedAmountTransferred(let v)? = effect {return v}
      return Concordium_V2_AccountTransactionEffects.EncryptedAmountTransferred()
    }
    set {effect = .encryptedAmountTransferred(newValue)}
  }

  /// An account transferred part of its public balance to its encrypted
  /// balance.
  var transferredToEncrypted: Concordium_V2_EncryptedSelfAmountAddedEvent {
    get {
      if case .transferredToEncrypted(let v)? = effect {return v}
      return Concordium_V2_EncryptedSelfAmountAddedEvent()
    }
    set {effect = .transferredToEncrypted(newValue)}
  }

  /// An account transferred part of its encrypted balance to its public balance.
  var transferredToPublic: Concordium_V2_AccountTransactionEffects.TransferredToPublic {
    get {
      if case .transferredToPublic(let v)? = effect {return v}
      return Concordium_V2_AccountTransactionEffects.TransferredToPublic()
    }
    set {effect = .transferredToPublic(newValue)}
  }

  /// A transfer with a release schedule was made.
  var transferredWithSchedule: Concordium_V2_AccountTransactionEffects.TransferredWithSchedule {
    get {
      if case .transferredWithSchedule(let v)? = effect {return v}
      return Concordium_V2_AccountTransactionEffects.TransferredWithSchedule()
    }
    set {effect = .transferredWithSchedule(newValue)}
  }

  /// Keys of a specific credential were updated.
  var credentialKeysUpdated: Concordium_V2_CredentialRegistrationId {
    get {
      if case .credentialKeysUpdated(let v)? = effect {return v}
      return Concordium_V2_CredentialRegistrationId()
    }
    set {effect = .credentialKeysUpdated(newValue)}
  }

  /// Account credentials were updated.
  var credentialsUpdated: Concordium_V2_AccountTransactionEffects.CredentialsUpdated {
    get {
      if case .credentialsUpdated(let v)? = effect {return v}
      return Concordium_V2_AccountTransactionEffects.CredentialsUpdated()
    }
    set {effect = .credentialsUpdated(newValue)}
  }

  /// Some data was registered on the chain.
  var dataRegistered: Concordium_V2_RegisteredData {
    get {
      if case .dataRegistered(let v)? = effect {return v}
      return Concordium_V2_RegisteredData()
    }
    set {effect = .dataRegistered(newValue)}
  }

  /// A baker was configured. The details of what happened are contained in a list of BakerEvents.
  var bakerConfigured: Concordium_V2_AccountTransactionEffects.BakerConfigured {
    get {
      if case .bakerConfigured(let v)? = effect {return v}
      return Concordium_V2_AccountTransactionEffects.BakerConfigured()
    }
    set {effect = .bakerConfigured(newValue)}
  }

  /// A delegator was configured. The details of what happened are contained in a list of DelegatorEvents.
  var delegationConfigured: Concordium_V2_AccountTransactionEffects.DelegationConfigured {
    get {
      if case .delegationConfigured(let v)? = effect {return v}
      return Concordium_V2_AccountTransactionEffects.DelegationConfigured()
    }
    set {effect = .delegationConfigured(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Effect: Equatable, Sendable {
    /// No effects other than payment from this transaction.
    /// The rejection reason indicates why the transaction failed.
    case none(Concordium_V2_AccountTransactionEffects.None)
    /// A smart contract module with the attached reference was deployed.
    case moduleDeployed(Concordium_V2_ModuleRef)
    /// A smart contract was initialized.
    case contractInitialized(Concordium_V2_ContractInitializedEvent)
    /// A smart contract instance updated was issued.
    case contractUpdateIssued(Concordium_V2_AccountTransactionEffects.ContractUpdateIssued)
    /// A simple account to account transfer occurred.
    case accountTransfer(Concordium_V2_AccountTransactionEffects.AccountTransfer)
    /// A baker was added.
    case bakerAdded(Concordium_V2_BakerEvent.BakerAdded)
    /// A baker was removed.
    case bakerRemoved(Concordium_V2_BakerId)
    /// A baker's stake was updated.
    case bakerStakeUpdated(Concordium_V2_AccountTransactionEffects.BakerStakeUpdated)
    /// A baker's restake earnings setting was updated.
    case bakerRestakeEarningsUpdated(Concordium_V2_BakerEvent.BakerRestakeEarningsUpdated)
    /// A baker's keys were updated.
    case bakerKeysUpdated(Concordium_V2_BakerKeysEvent)
    /// An encrypted amount was transferred.
    case encryptedAmountTransferred(Concordium_V2_AccountTransactionEffects.EncryptedAmountTransferred)
    /// An account transferred part of its public balance to its encrypted
    /// balance.
    case transferredToEncrypted(Concordium_V2_EncryptedSelfAmountAddedEvent)
    /// An account transferred part of its encrypted balance to its public balance.
    case transferredToPublic(Concordium_V2_AccountTransactionEffects.TransferredToPublic)
    /// A transfer with a release schedule was made.
    case transferredWithSchedule(Concordium_V2_AccountTransactionEffects.TransferredWithSchedule)
    /// Keys of a specific credential were updated.
    case credentialKeysUpdated(Concordium_V2_CredentialRegistrationId)
    /// Account credentials were updated.
    case credentialsUpdated(Concordium_V2_AccountTransactionEffects.CredentialsUpdated)
    /// Some data was registered on the chain.
    case dataRegistered(Concordium_V2_RegisteredData)
    /// A baker was configured. The details of what happened are contained in a list of BakerEvents.
    case bakerConfigured(Concordium_V2_AccountTransactionEffects.BakerConfigured)
    /// A delegator was configured. The details of what happened are contained in a list of DelegatorEvents.
    case delegationConfigured(Concordium_V2_AccountTransactionEffects.DelegationConfigured)

  }

  /// No effects other than payment from this transaction.
  /// The rejection reason indicates why the transaction failed.
  struct None: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Transaction type of a failed transaction, if known.
    /// In case of serialization failure this will not be set.
    var transactionType: Concordium_V2_TransactionType {
      get {return _transactionType ?? .deployModule}
      set {_transactionType = newValue}
    }
    /// Returns true if `transactionType` has been explicitly set.
    var hasTransactionType: Bool {return self._transactionType != nil}
    /// Clears the value of `transactionType`. Subsequent reads from it will return its default value.
    mutating func clearTransactionType() {self._transactionType = nil}

    /// Reason for rejection of the transaction.
    var rejectReason: Concordium_V2_RejectReason {
      get {return _rejectReason ?? Concordium_V2_RejectReason()}
      set {_rejectReason = newValue}
    }
    /// Returns true if `rejectReason` has been explicitly set.
    var hasRejectReason: Bool {return self._rejectReason != nil}
    /// Clears the value of `rejectReason`. Subsequent reads from it will return its default value.
    mutating func clearRejectReason() {self._rejectReason = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _transactionType: Concordium_V2_TransactionType? = nil
    fileprivate var _rejectReason: Concordium_V2_RejectReason? = nil
  }

  /// A contract update transaction was issued and produced the given trace.
  /// This is the result of Update transaction.
  struct ContractUpdateIssued: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var effects: [Concordium_V2_ContractTraceElement] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A simple account to account transfer occurred. This is the result of a
  /// successful Transfer transaction.
  struct AccountTransfer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Amount that was transferred.
    var amount: Concordium_V2_Amount {
      get {return _amount ?? Concordium_V2_Amount()}
      set {_amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    var hasAmount: Bool {return self._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    mutating func clearAmount() {self._amount = nil}

    /// Receiver account.
    var receiver: Concordium_V2_AccountAddress {
      get {return _receiver ?? Concordium_V2_AccountAddress()}
      set {_receiver = newValue}
    }
    /// Returns true if `receiver` has been explicitly set.
    var hasReceiver: Bool {return self._receiver != nil}
    /// Clears the value of `receiver`. Subsequent reads from it will return its default value.
    mutating func clearReceiver() {self._receiver = nil}

    /// Memo.
    var memo: Concordium_V2_Memo {
      get {return _memo ?? Concordium_V2_Memo()}
      set {_memo = newValue}
    }
    /// Returns true if `memo` has been explicitly set.
    var hasMemo: Bool {return self._memo != nil}
    /// Clears the value of `memo`. Subsequent reads from it will return its default value.
    mutating func clearMemo() {self._memo = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _amount: Concordium_V2_Amount? = nil
    fileprivate var _receiver: Concordium_V2_AccountAddress? = nil
    fileprivate var _memo: Concordium_V2_Memo? = nil
  }

  /// An account was deregistered as a baker. This is the result of a
  /// successful UpdateBakerStake transaction.
  struct BakerStakeUpdated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If the stake was updated (that is, it changed and did not stay the
    /// same) then this is present, otherwise it is not present.
    var update: Concordium_V2_BakerStakeUpdatedData {
      get {return _update ?? Concordium_V2_BakerStakeUpdatedData()}
      set {_update = newValue}
    }
    /// Returns true if `update` has been explicitly set.
    var hasUpdate: Bool {return self._update != nil}
    /// Clears the value of `update`. Subsequent reads from it will return its default value.
    mutating func clearUpdate() {self._update = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _update: Concordium_V2_BakerStakeUpdatedData? = nil
  }

  /// An encrypted amount was transferred. This is the result of a successful
  /// EncryptedAmountTransfer transaction.
  struct EncryptedAmountTransferred: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var removed: Concordium_V2_EncryptedAmountRemovedEvent {
      get {return _removed ?? Concordium_V2_EncryptedAmountRemovedEvent()}
      set {_removed = newValue}
    }
    /// Returns true if `removed` has been explicitly set.
    var hasRemoved: Bool {return self._removed != nil}
    /// Clears the value of `removed`. Subsequent reads from it will return its default value.
    mutating func clearRemoved() {self._removed = nil}

    var added: Concordium_V2_NewEncryptedAmountEvent {
      get {return _added ?? Concordium_V2_NewEncryptedAmountEvent()}
      set {_added = newValue}
    }
    /// Returns true if `added` has been explicitly set.
    var hasAdded: Bool {return self._added != nil}
    /// Clears the value of `added`. Subsequent reads from it will return its default value.
    mutating func clearAdded() {self._added = nil}

    var memo: Concordium_V2_Memo {
      get {return _memo ?? Concordium_V2_Memo()}
      set {_memo = newValue}
    }
    /// Returns true if `memo` has been explicitly set.
    var hasMemo: Bool {return self._memo != nil}
    /// Clears the value of `memo`. Subsequent reads from it will return its default value.
    mutating func clearMemo() {self._memo = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _removed: Concordium_V2_EncryptedAmountRemovedEvent? = nil
    fileprivate var _added: Concordium_V2_NewEncryptedAmountEvent? = nil
    fileprivate var _memo: Concordium_V2_Memo? = nil
  }

  /// An account transferred part of its encrypted balance to its public
  /// balance. This is the result of a successful TransferToPublic transaction.
  struct TransferredToPublic: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var removed: Concordium_V2_EncryptedAmountRemovedEvent {
      get {return _removed ?? Concordium_V2_EncryptedAmountRemovedEvent()}
      set {_removed = newValue}
    }
    /// Returns true if `removed` has been explicitly set.
    var hasRemoved: Bool {return self._removed != nil}
    /// Clears the value of `removed`. Subsequent reads from it will return its default value.
    mutating func clearRemoved() {self._removed = nil}

    var amount: Concordium_V2_Amount {
      get {return _amount ?? Concordium_V2_Amount()}
      set {_amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    var hasAmount: Bool {return self._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    mutating func clearAmount() {self._amount = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _removed: Concordium_V2_EncryptedAmountRemovedEvent? = nil
    fileprivate var _amount: Concordium_V2_Amount? = nil
  }

  /// A transfer with schedule was performed. This is the result of a
  /// successful TransferWithSchedule transaction.
  struct TransferredWithSchedule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Receiver account.
    var receiver: Concordium_V2_AccountAddress {
      get {return _receiver ?? Concordium_V2_AccountAddress()}
      set {_receiver = newValue}
    }
    /// Returns true if `receiver` has been explicitly set.
    var hasReceiver: Bool {return self._receiver != nil}
    /// Clears the value of `receiver`. Subsequent reads from it will return its default value.
    mutating func clearReceiver() {self._receiver = nil}

    /// The list of releases. Ordered by increasing timestamp.
    var amount: [Concordium_V2_NewRelease] = []

    /// Optional memo.
    var memo: Concordium_V2_Memo {
      get {return _memo ?? Concordium_V2_Memo()}
      set {_memo = newValue}
    }
    /// Returns true if `memo` has been explicitly set.
    var hasMemo: Bool {return self._memo != nil}
    /// Clears the value of `memo`. Subsequent reads from it will return its default value.
    mutating func clearMemo() {self._memo = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _receiver: Concordium_V2_AccountAddress? = nil
    fileprivate var _memo: Concordium_V2_Memo? = nil
  }

  /// Account's credentials were updated. This is the result of a
  /// successful UpdateCredentials transaction.
  struct CredentialsUpdated: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The credential ids that were added.
    var newCredIds: [Concordium_V2_CredentialRegistrationId] = []

    /// The credentials that were removed.
    var removedCredIds: [Concordium_V2_CredentialRegistrationId] = []

    /// The (possibly) updated account threshold.
    var newThreshold: Concordium_V2_AccountThreshold {
      get {return _newThreshold ?? Concordium_V2_AccountThreshold()}
      set {_newThreshold = newValue}
    }
    /// Returns true if `newThreshold` has been explicitly set.
    var hasNewThreshold: Bool {return self._newThreshold != nil}
    /// Clears the value of `newThreshold`. Subsequent reads from it will return its default value.
    mutating func clearNewThreshold() {self._newThreshold = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _newThreshold: Concordium_V2_AccountThreshold? = nil
  }

  /// A baker was configured. The details of what happened are contained in
  /// the list of BakerEvents.
  struct BakerConfigured: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var events: [Concordium_V2_BakerEvent] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// An account configured delegation. The details of what happened are
  /// contained in the list of DelegationEvents.
  struct DelegationConfigured: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var events: [Concordium_V2_DelegationEvent] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Election difficulty parameter.
struct Concordium_V2_ElectionDifficulty: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Concordium_V2_AmountFraction {
    get {return _value ?? Concordium_V2_AmountFraction()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Concordium_V2_AmountFraction? = nil
}

/// Parameters that determine timeouts in the consensus protocol used from protocol version 6.
struct Concordium_V2_TimeoutParameters: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The base value for triggering a timeout
  var timeoutBase: Concordium_V2_Duration {
    get {return _timeoutBase ?? Concordium_V2_Duration()}
    set {_timeoutBase = newValue}
  }
  /// Returns true if `timeoutBase` has been explicitly set.
  var hasTimeoutBase: Bool {return self._timeoutBase != nil}
  /// Clears the value of `timeoutBase`. Subsequent reads from it will return its default value.
  mutating func clearTimeoutBase() {self._timeoutBase = nil}

  /// Factor for increasing the timeout. Must be greater than 1.
  var timeoutIncrease: Concordium_V2_Ratio {
    get {return _timeoutIncrease ?? Concordium_V2_Ratio()}
    set {_timeoutIncrease = newValue}
  }
  /// Returns true if `timeoutIncrease` has been explicitly set.
  var hasTimeoutIncrease: Bool {return self._timeoutIncrease != nil}
  /// Clears the value of `timeoutIncrease`. Subsequent reads from it will return its default value.
  mutating func clearTimeoutIncrease() {self._timeoutIncrease = nil}

  /// Factor for decreasing the timeout. Must be between 0 and 1.
  var timeoutDecrease: Concordium_V2_Ratio {
    get {return _timeoutDecrease ?? Concordium_V2_Ratio()}
    set {_timeoutDecrease = newValue}
  }
  /// Returns true if `timeoutDecrease` has been explicitly set.
  var hasTimeoutDecrease: Bool {return self._timeoutDecrease != nil}
  /// Clears the value of `timeoutDecrease`. Subsequent reads from it will return its default value.
  mutating func clearTimeoutDecrease() {self._timeoutDecrease = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timeoutBase: Concordium_V2_Duration? = nil
  fileprivate var _timeoutIncrease: Concordium_V2_Ratio? = nil
  fileprivate var _timeoutDecrease: Concordium_V2_Ratio? = nil
}

/// Finalization committee parameters used from protocol version 6
struct Concordium_V2_FinalizationCommitteeParameters: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The minimum size of a finalization committee before `finalizer_relative_stake_threshold` takes effect.
  var minimumFinalizers: UInt32 = 0

  /// The maximum size of a finalization committee.
  var maximumFinalizers: UInt32 = 0

  /// The threshold for determining the stake required for being eligible the finalization committee.
  /// The amount is given by `total stake in pools * finalizer_relative_stake_threshold`
  var finalizerRelativeStakeThreshold: Concordium_V2_AmountFraction {
    get {return _finalizerRelativeStakeThreshold ?? Concordium_V2_AmountFraction()}
    set {_finalizerRelativeStakeThreshold = newValue}
  }
  /// Returns true if `finalizerRelativeStakeThreshold` has been explicitly set.
  var hasFinalizerRelativeStakeThreshold: Bool {return self._finalizerRelativeStakeThreshold != nil}
  /// Clears the value of `finalizerRelativeStakeThreshold`. Subsequent reads from it will return its default value.
  mutating func clearFinalizerRelativeStakeThreshold() {self._finalizerRelativeStakeThreshold = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _finalizerRelativeStakeThreshold: Concordium_V2_AmountFraction? = nil
}

/// Parameters for the consensus protocol used from protocol version 6.
struct Concordium_V2_ConsensusParametersV1: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parameters controlling round timeouts.
  var timeoutParameters: Concordium_V2_TimeoutParameters {
    get {return _timeoutParameters ?? Concordium_V2_TimeoutParameters()}
    set {_timeoutParameters = newValue}
  }
  /// Returns true if `timeoutParameters` has been explicitly set.
  var hasTimeoutParameters: Bool {return self._timeoutParameters != nil}
  /// Clears the value of `timeoutParameters`. Subsequent reads from it will return its default value.
  mutating func clearTimeoutParameters() {self._timeoutParameters = nil}

  /// Minimum time interval between blocks.
  var minBlockTime: Concordium_V2_Duration {
    get {return _minBlockTime ?? Concordium_V2_Duration()}
    set {_minBlockTime = newValue}
  }
  /// Returns true if `minBlockTime` has been explicitly set.
  var hasMinBlockTime: Bool {return self._minBlockTime != nil}
  /// Clears the value of `minBlockTime`. Subsequent reads from it will return its default value.
  mutating func clearMinBlockTime() {self._minBlockTime = nil}

  /// Maximum energy allowed per block.
  var blockEnergyLimit: Concordium_V2_Energy {
    get {return _blockEnergyLimit ?? Concordium_V2_Energy()}
    set {_blockEnergyLimit = newValue}
  }
  /// Returns true if `blockEnergyLimit` has been explicitly set.
  var hasBlockEnergyLimit: Bool {return self._blockEnergyLimit != nil}
  /// Clears the value of `blockEnergyLimit`. Subsequent reads from it will return its default value.
  mutating func clearBlockEnergyLimit() {self._blockEnergyLimit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timeoutParameters: Concordium_V2_TimeoutParameters? = nil
  fileprivate var _minBlockTime: Concordium_V2_Duration? = nil
  fileprivate var _blockEnergyLimit: Concordium_V2_Energy? = nil
}

/// Represents an exchange rate.
struct Concordium_V2_ExchangeRate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Concordium_V2_Ratio {
    get {return _value ?? Concordium_V2_Ratio()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Concordium_V2_Ratio? = nil
}

/// Represents a ratio, i.e., 'numerator / denominator'.
struct Concordium_V2_Ratio: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The numerator.
  var numerator: UInt64 = 0

  /// The denominator.
  var denominator: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A public key used for chain updates.
struct Concordium_V2_UpdatePublicKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The threshold for how many UpdatePublicKeys are need to make a certain chain update.
struct Concordium_V2_UpdateKeysThreshold: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is ensured to be within between 1 and 2^16.
  var value: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Index of a key in an authorizations update payload.
struct Concordium_V2_UpdateKeysIndex: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents root or level 1 keys.
struct Concordium_V2_HigherLevelKeys: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The keys.
  var keys: [Concordium_V2_UpdatePublicKey] = []

  /// The number of keys needed to make a chain update.
  var threshold: Concordium_V2_UpdateKeysThreshold {
    get {return _threshold ?? Concordium_V2_UpdateKeysThreshold()}
    set {_threshold = newValue}
  }
  /// Returns true if `threshold` has been explicitly set.
  var hasThreshold: Bool {return self._threshold != nil}
  /// Clears the value of `threshold`. Subsequent reads from it will return its default value.
  mutating func clearThreshold() {self._threshold = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _threshold: Concordium_V2_UpdateKeysThreshold? = nil
}

/// An access structure which specifies which UpdatePublicKeys in a HigherLevelKeys that are allowed
/// to make chain update of a specific type. The threshold defines the minimum number of allowed keys needed
/// to make the actual update.
struct Concordium_V2_AccessStructure: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique indexes into the set of keys in AuthorizationV0.
  var accessPublicKeys: [Concordium_V2_UpdateKeysIndex] = []

  /// Number of keys requred to authorize an update.
  var accessThreshold: Concordium_V2_UpdateKeysThreshold {
    get {return _accessThreshold ?? Concordium_V2_UpdateKeysThreshold()}
    set {_accessThreshold = newValue}
  }
  /// Returns true if `accessThreshold` has been explicitly set.
  var hasAccessThreshold: Bool {return self._accessThreshold != nil}
  /// Clears the value of `accessThreshold`. Subsequent reads from it will return its default value.
  mutating func clearAccessThreshold() {self._accessThreshold = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessThreshold: Concordium_V2_UpdateKeysThreshold? = nil
}

/// The set of keys authorized for chain updates, together with access structures
/// determining which keys are authorized for which update types.
/// This is the payload of an update to authorization.
struct Concordium_V2_AuthorizationsV0: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of keys authorized for chain updates.
  var keys: [Concordium_V2_UpdatePublicKey] {
    get {return _storage._keys}
    set {_uniqueStorage()._keys = newValue}
  }

  /// New emergency keys.
  var emergency: Concordium_V2_AccessStructure {
    get {return _storage._emergency ?? Concordium_V2_AccessStructure()}
    set {_uniqueStorage()._emergency = newValue}
  }
  /// Returns true if `emergency` has been explicitly set.
  var hasEmergency: Bool {return _storage._emergency != nil}
  /// Clears the value of `emergency`. Subsequent reads from it will return its default value.
  mutating func clearEmergency() {_uniqueStorage()._emergency = nil}

  /// New protocol update keys.
  var `protocol`: Concordium_V2_AccessStructure {
    get {return _storage._protocol ?? Concordium_V2_AccessStructure()}
    set {_uniqueStorage()._protocol = newValue}
  }
  /// Returns true if ``protocol`` has been explicitly set.
  var hasProtocol: Bool {return _storage._protocol != nil}
  /// Clears the value of ``protocol``. Subsequent reads from it will return its default value.
  mutating func clearProtocol() {_uniqueStorage()._protocol = nil}

  /// Access structure for updating the consensus parameters.
  /// Previously, this was the election difficulty.
  var parameterConsensus: Concordium_V2_AccessStructure {
    get {return _storage._parameterConsensus ?? Concordium_V2_AccessStructure()}
    set {_uniqueStorage()._parameterConsensus = newValue}
  }
  /// Returns true if `parameterConsensus` has been explicitly set.
  var hasParameterConsensus: Bool {return _storage._parameterConsensus != nil}
  /// Clears the value of `parameterConsensus`. Subsequent reads from it will return its default value.
  mutating func clearParameterConsensus() {_uniqueStorage()._parameterConsensus = nil}

  /// Access structure for updating the euro per energy.
  var parameterEuroPerEnergy: Concordium_V2_AccessStructure {
    get {return _storage._parameterEuroPerEnergy ?? Concordium_V2_AccessStructure()}
    set {_uniqueStorage()._parameterEuroPerEnergy = newValue}
  }
  /// Returns true if `parameterEuroPerEnergy` has been explicitly set.
  var hasParameterEuroPerEnergy: Bool {return _storage._parameterEuroPerEnergy != nil}
  /// Clears the value of `parameterEuroPerEnergy`. Subsequent reads from it will return its default value.
  mutating func clearParameterEuroPerEnergy() {_uniqueStorage()._parameterEuroPerEnergy = nil}

  /// Access structure for updating the micro CCD per euro.
  var parameterMicroCcdPerEuro: Concordium_V2_AccessStructure {
    get {return _storage._parameterMicroCcdPerEuro ?? Concordium_V2_AccessStructure()}
    set {_uniqueStorage()._parameterMicroCcdPerEuro = newValue}
  }
  /// Returns true if `parameterMicroCcdPerEuro` has been explicitly set.
  var hasParameterMicroCcdPerEuro: Bool {return _storage._parameterMicroCcdPerEuro != nil}
  /// Clears the value of `parameterMicroCcdPerEuro`. Subsequent reads from it will return its default value.
  mutating func clearParameterMicroCcdPerEuro() {_uniqueStorage()._parameterMicroCcdPerEuro = nil}

  /// Access structure for updating the foundation account.
  var parameterFoundationAccount: Concordium_V2_AccessStructure {
    get {return _storage._parameterFoundationAccount ?? Concordium_V2_AccessStructure()}
    set {_uniqueStorage()._parameterFoundationAccount = newValue}
  }
  /// Returns true if `parameterFoundationAccount` has been explicitly set.
  var hasParameterFoundationAccount: Bool {return _storage._parameterFoundationAccount != nil}
  /// Clears the value of `parameterFoundationAccount`. Subsequent reads from it will return its default value.
  mutating func clearParameterFoundationAccount() {_uniqueStorage()._parameterFoundationAccount = nil}

  /// Access structure for updating the mint distribution.
  var parameterMintDistribution: Concordium_V2_AccessStructure {
    get {return _storage._parameterMintDistribution ?? Concordium_V2_AccessStructure()}
    set {_uniqueStorage()._parameterMintDistribution = newValue}
  }
  /// Returns true if `parameterMintDistribution` has been explicitly set.
  var hasParameterMintDistribution: Bool {return _storage._parameterMintDistribution != nil}
  /// Clears the value of `parameterMintDistribution`. Subsequent reads from it will return its default value.
  mutating func clearParameterMintDistribution() {_uniqueStorage()._parameterMintDistribution = nil}

  /// Access structure for updating the transaction fee distribution.
  var parameterTransactionFeeDistribution: Concordium_V2_AccessStructure {
    get {return _storage._parameterTransactionFeeDistribution ?? Concordium_V2_AccessStructure()}
    set {_uniqueStorage()._parameterTransactionFeeDistribution = newValue}
  }
  /// Returns true if `parameterTransactionFeeDistribution` has been explicitly set.
  var hasParameterTransactionFeeDistribution: Bool {return _storage._parameterTransactionFeeDistribution != nil}
  /// Clears the value of `parameterTransactionFeeDistribution`. Subsequent reads from it will return its default value.
  mutating func clearParameterTransactionFeeDistribution() {_uniqueStorage()._parameterTransactionFeeDistribution = nil}

  /// Access structure for updating the gas rewards.
  var parameterGasRewards: Concordium_V2_AccessStructure {
    get {return _storage._parameterGasRewards ?? Concordium_V2_AccessStructure()}
    set {_uniqueStorage()._parameterGasRewards = newValue}
  }
  /// Returns true if `parameterGasRewards` has been explicitly set.
  var hasParameterGasRewards: Bool {return _storage._parameterGasRewards != nil}
  /// Clears the value of `parameterGasRewards`. Subsequent reads from it will return its default value.
  mutating func clearParameterGasRewards() {_uniqueStorage()._parameterGasRewards = nil}

  /// Access structure for updating the pool parameters. For V0 this is only
  /// the baker stake threshold, for V1 there are more.
  var poolParameters: Concordium_V2_AccessStructure {
    get {return _storage._poolParameters ?? Concordium_V2_AccessStructure()}
    set {_uniqueStorage()._poolParameters = newValue}
  }
  /// Returns true if `poolParameters` has been explicitly set.
  var hasPoolParameters: Bool {return _storage._poolParameters != nil}
  /// Clears the value of `poolParameters`. Subsequent reads from it will return its default value.
  mutating func clearPoolParameters() {_uniqueStorage()._poolParameters = nil}

  /// Access structure for adding new anonymity revokers.
  var addAnonymityRevoker: Concordium_V2_AccessStructure {
    get {return _storage._addAnonymityRevoker ?? Concordium_V2_AccessStructure()}
    set {_uniqueStorage()._addAnonymityRevoker = newValue}
  }
  /// Returns true if `addAnonymityRevoker` has been explicitly set.
  var hasAddAnonymityRevoker: Bool {return _storage._addAnonymityRevoker != nil}
  /// Clears the value of `addAnonymityRevoker`. Subsequent reads from it will return its default value.
  mutating func clearAddAnonymityRevoker() {_uniqueStorage()._addAnonymityRevoker = nil}

  /// Access structure for adding new identity providers.
  var addIdentityProvider: Concordium_V2_AccessStructure {
    get {return _storage._addIdentityProvider ?? Concordium_V2_AccessStructure()}
    set {_uniqueStorage()._addIdentityProvider = newValue}
  }
  /// Returns true if `addIdentityProvider` has been explicitly set.
  var hasAddIdentityProvider: Bool {return _storage._addIdentityProvider != nil}
  /// Clears the value of `addIdentityProvider`. Subsequent reads from it will return its default value.
  mutating func clearAddIdentityProvider() {_uniqueStorage()._addIdentityProvider = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The set of keys authorized for chain updates, together with access structures
/// determining which keys are authorized for which update types.
/// This is the payload of an update to authorization.
struct Concordium_V2_AuthorizationsV1: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var v0: Concordium_V2_AuthorizationsV0 {
    get {return _v0 ?? Concordium_V2_AuthorizationsV0()}
    set {_v0 = newValue}
  }
  /// Returns true if `v0` has been explicitly set.
  var hasV0: Bool {return self._v0 != nil}
  /// Clears the value of `v0`. Subsequent reads from it will return its default value.
  mutating func clearV0() {self._v0 = nil}

  /// Access structure for updating the cooldown periods related to baking and delegation.
  var parameterCooldown: Concordium_V2_AccessStructure {
    get {return _parameterCooldown ?? Concordium_V2_AccessStructure()}
    set {_parameterCooldown = newValue}
  }
  /// Returns true if `parameterCooldown` has been explicitly set.
  var hasParameterCooldown: Bool {return self._parameterCooldown != nil}
  /// Clears the value of `parameterCooldown`. Subsequent reads from it will return its default value.
  mutating func clearParameterCooldown() {self._parameterCooldown = nil}

  /// Access structure for updating the length of the reward period.
  var parameterTime: Concordium_V2_AccessStructure {
    get {return _parameterTime ?? Concordium_V2_AccessStructure()}
    set {_parameterTime = newValue}
  }
  /// Returns true if `parameterTime` has been explicitly set.
  var hasParameterTime: Bool {return self._parameterTime != nil}
  /// Clears the value of `parameterTime`. Subsequent reads from it will return its default value.
  mutating func clearParameterTime() {self._parameterTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _v0: Concordium_V2_AuthorizationsV0? = nil
  fileprivate var _parameterCooldown: Concordium_V2_AccessStructure? = nil
  fileprivate var _parameterTime: Concordium_V2_AccessStructure? = nil
}

/// Description either of an anonymity revoker or identity provider.
/// Metadata that should be visible on the chain.
struct Concordium_V2_Description: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name.
  var name: String = String()

  /// A link to more information about the anonymity revoker or identity provider.
  var url: String = String()

  /// A free form description of the revoker or provider.
  var description_p: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information on a single anonymity revoker help by the identity provider.
/// Typically an identity provider will hold more than one.
struct Concordium_V2_ArInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the anonymity revoker.
  var identity: Concordium_V2_ArInfo.ArIdentity {
    get {return _identity ?? Concordium_V2_ArInfo.ArIdentity()}
    set {_identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  var hasIdentity: Bool {return self._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  mutating func clearIdentity() {self._identity = nil}

  /// Description of the anonymity revoker.
  var description_p: Concordium_V2_Description {
    get {return _description_p ?? Concordium_V2_Description()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  /// Elgamal encryption key of the anonymity revoker.
  var publicKey: Concordium_V2_ArInfo.ArPublicKey {
    get {return _publicKey ?? Concordium_V2_ArInfo.ArPublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Identity of the anonymity revoker on the chain. This defines their
  /// evaluateion point for secret sharing, and thus it cannot be 0.
  struct ArIdentity: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Public key of an anonymity revoker.
  struct ArPublicKey: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _identity: Concordium_V2_ArInfo.ArIdentity? = nil
  fileprivate var _description_p: Concordium_V2_Description? = nil
  fileprivate var _publicKey: Concordium_V2_ArInfo.ArPublicKey? = nil
}

/// A succinct identifier of an identity provider on the chain.
/// In credential deployments, and other interactions with the chain this is
/// used to identify which identity provider is meant.
struct Concordium_V2_IpIdentity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Public information about an identity provider.
struct Concordium_V2_IpInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the identity provider.
  var identity: Concordium_V2_IpIdentity {
    get {return _identity ?? Concordium_V2_IpIdentity()}
    set {_identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  var hasIdentity: Bool {return self._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  mutating func clearIdentity() {self._identity = nil}

  /// Description of the identity provider.
  var description_p: Concordium_V2_Description {
    get {return _description_p ?? Concordium_V2_Description()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  /// Pointcheval-Sanders public key of the identity provider.
  var verifyKey: Concordium_V2_IpInfo.IpVerifyKey {
    get {return _verifyKey ?? Concordium_V2_IpInfo.IpVerifyKey()}
    set {_verifyKey = newValue}
  }
  /// Returns true if `verifyKey` has been explicitly set.
  var hasVerifyKey: Bool {return self._verifyKey != nil}
  /// Clears the value of `verifyKey`. Subsequent reads from it will return its default value.
  mutating func clearVerifyKey() {self._verifyKey = nil}

  /// Ed25519 public key of the identity provider.
  var cdiVerifyKey: Concordium_V2_IpInfo.IpCdiVerifyKey {
    get {return _cdiVerifyKey ?? Concordium_V2_IpInfo.IpCdiVerifyKey()}
    set {_cdiVerifyKey = newValue}
  }
  /// Returns true if `cdiVerifyKey` has been explicitly set.
  var hasCdiVerifyKey: Bool {return self._cdiVerifyKey != nil}
  /// Clears the value of `cdiVerifyKey`. Subsequent reads from it will return its default value.
  mutating func clearCdiVerifyKey() {self._cdiVerifyKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Pointcheval-Sanders public key of the identity provider.
  struct IpVerifyKey: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Ed25519 public key of the identity provider.
  struct IpCdiVerifyKey: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _identity: Concordium_V2_IpIdentity? = nil
  fileprivate var _description_p: Concordium_V2_Description? = nil
  fileprivate var _verifyKey: Concordium_V2_IpInfo.IpVerifyKey? = nil
  fileprivate var _cdiVerifyKey: Concordium_V2_IpInfo.IpCdiVerifyKey? = nil
}

/// A duration in seconds.
struct Concordium_V2_DurationSeconds: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Inclusive range of amount fractions.
struct Concordium_V2_InclusiveRangeAmountFraction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var min: Concordium_V2_AmountFraction {
    get {return _min ?? Concordium_V2_AmountFraction()}
    set {_min = newValue}
  }
  /// Returns true if `min` has been explicitly set.
  var hasMin: Bool {return self._min != nil}
  /// Clears the value of `min`. Subsequent reads from it will return its default value.
  mutating func clearMin() {self._min = nil}

  var max_: Concordium_V2_AmountFraction {
    get {return _max_ ?? Concordium_V2_AmountFraction()}
    set {_max_ = newValue}
  }
  /// Returns true if `max_` has been explicitly set.
  var hasMax_: Bool {return self._max_ != nil}
  /// Clears the value of `max_`. Subsequent reads from it will return its default value.
  mutating func clearMax_() {self._max_ = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _min: Concordium_V2_AmountFraction? = nil
  fileprivate var _max_: Concordium_V2_AmountFraction? = nil
}

/// Ranges of allowed commission values that pools may choose from.
struct Concordium_V2_CommissionRanges: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The range of allowed finalization commissions.
  var finalization: Concordium_V2_InclusiveRangeAmountFraction {
    get {return _finalization ?? Concordium_V2_InclusiveRangeAmountFraction()}
    set {_finalization = newValue}
  }
  /// Returns true if `finalization` has been explicitly set.
  var hasFinalization: Bool {return self._finalization != nil}
  /// Clears the value of `finalization`. Subsequent reads from it will return its default value.
  mutating func clearFinalization() {self._finalization = nil}

  /// The range of allowed baker commissions.
  var baking: Concordium_V2_InclusiveRangeAmountFraction {
    get {return _baking ?? Concordium_V2_InclusiveRangeAmountFraction()}
    set {_baking = newValue}
  }
  /// Returns true if `baking` has been explicitly set.
  var hasBaking: Bool {return self._baking != nil}
  /// Clears the value of `baking`. Subsequent reads from it will return its default value.
  mutating func clearBaking() {self._baking = nil}

  /// The range of allowed transaction commissions.
  var transaction: Concordium_V2_InclusiveRangeAmountFraction {
    get {return _transaction ?? Concordium_V2_InclusiveRangeAmountFraction()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  mutating func clearTransaction() {self._transaction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _finalization: Concordium_V2_InclusiveRangeAmountFraction? = nil
  fileprivate var _baking: Concordium_V2_InclusiveRangeAmountFraction? = nil
  fileprivate var _transaction: Concordium_V2_InclusiveRangeAmountFraction? = nil
}

/// A bound on the relative share of the total staked capital that a baker can
/// have as its stake. This is required to be greater than 0.
struct Concordium_V2_CapitalBound: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Concordium_V2_AmountFraction {
    get {return _value ?? Concordium_V2_AmountFraction()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Concordium_V2_AmountFraction? = nil
}

/// A leverage factor.
struct Concordium_V2_LeverageFactor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Concordium_V2_Ratio {
    get {return _value ?? Concordium_V2_Ratio()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Concordium_V2_Ratio? = nil
}

/// A chain epoch.
struct Concordium_V2_Epoch: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A round.
struct Concordium_V2_Round: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Length of a reward period in epochs.
/// Must always be a strictly positive number.
struct Concordium_V2_RewardPeriodLength: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Concordium_V2_Epoch {
    get {return _value ?? Concordium_V2_Epoch()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Concordium_V2_Epoch? = nil
}

/// A minting rate of CCD.
/// The value is `mantissa * 10^(-exponent)`.
struct Concordium_V2_MintRate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mantissa: UInt32 = 0

  /// This will never exceed 255 and can thus be stored in a single byte.
  var exponent: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Concordium_V2_CooldownParametersCpv1: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of seconds that pool owners must cooldown
  /// when reducing their equity capital or closing the pool.
  var poolOwnerCooldown: Concordium_V2_DurationSeconds {
    get {return _poolOwnerCooldown ?? Concordium_V2_DurationSeconds()}
    set {_poolOwnerCooldown = newValue}
  }
  /// Returns true if `poolOwnerCooldown` has been explicitly set.
  var hasPoolOwnerCooldown: Bool {return self._poolOwnerCooldown != nil}
  /// Clears the value of `poolOwnerCooldown`. Subsequent reads from it will return its default value.
  mutating func clearPoolOwnerCooldown() {self._poolOwnerCooldown = nil}

  /// Number of seconds that a delegator must cooldown
  /// when reducing their delegated stake.
  var delegatorCooldown: Concordium_V2_DurationSeconds {
    get {return _delegatorCooldown ?? Concordium_V2_DurationSeconds()}
    set {_delegatorCooldown = newValue}
  }
  /// Returns true if `delegatorCooldown` has been explicitly set.
  var hasDelegatorCooldown: Bool {return self._delegatorCooldown != nil}
  /// Clears the value of `delegatorCooldown`. Subsequent reads from it will return its default value.
  mutating func clearDelegatorCooldown() {self._delegatorCooldown = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _poolOwnerCooldown: Concordium_V2_DurationSeconds? = nil
  fileprivate var _delegatorCooldown: Concordium_V2_DurationSeconds? = nil
}

/// Parameters related to staking pools.
struct Concordium_V2_PoolParametersCpv1: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Fraction of finalization rewards charged by the passive delegation.
  var passiveFinalizationCommission: Concordium_V2_AmountFraction {
    get {return _passiveFinalizationCommission ?? Concordium_V2_AmountFraction()}
    set {_passiveFinalizationCommission = newValue}
  }
  /// Returns true if `passiveFinalizationCommission` has been explicitly set.
  var hasPassiveFinalizationCommission: Bool {return self._passiveFinalizationCommission != nil}
  /// Clears the value of `passiveFinalizationCommission`. Subsequent reads from it will return its default value.
  mutating func clearPassiveFinalizationCommission() {self._passiveFinalizationCommission = nil}

  /// Fraction of baking rewards charged by the passive delegation.
  var passiveBakingCommission: Concordium_V2_AmountFraction {
    get {return _passiveBakingCommission ?? Concordium_V2_AmountFraction()}
    set {_passiveBakingCommission = newValue}
  }
  /// Returns true if `passiveBakingCommission` has been explicitly set.
  var hasPassiveBakingCommission: Bool {return self._passiveBakingCommission != nil}
  /// Clears the value of `passiveBakingCommission`. Subsequent reads from it will return its default value.
  mutating func clearPassiveBakingCommission() {self._passiveBakingCommission = nil}

  /// Fraction of transaction rewards charged by the L-pool.
  var passiveTransactionCommission: Concordium_V2_AmountFraction {
    get {return _passiveTransactionCommission ?? Concordium_V2_AmountFraction()}
    set {_passiveTransactionCommission = newValue}
  }
  /// Returns true if `passiveTransactionCommission` has been explicitly set.
  var hasPassiveTransactionCommission: Bool {return self._passiveTransactionCommission != nil}
  /// Clears the value of `passiveTransactionCommission`. Subsequent reads from it will return its default value.
  mutating func clearPassiveTransactionCommission() {self._passiveTransactionCommission = nil}

  /// Bounds on the commission rates that may be charged by bakers.
  var commissionBounds: Concordium_V2_CommissionRanges {
    get {return _commissionBounds ?? Concordium_V2_CommissionRanges()}
    set {_commissionBounds = newValue}
  }
  /// Returns true if `commissionBounds` has been explicitly set.
  var hasCommissionBounds: Bool {return self._commissionBounds != nil}
  /// Clears the value of `commissionBounds`. Subsequent reads from it will return its default value.
  mutating func clearCommissionBounds() {self._commissionBounds = nil}

  /// Minimum equity capital required for a new baker.
  var minimumEquityCapital: Concordium_V2_Amount {
    get {return _minimumEquityCapital ?? Concordium_V2_Amount()}
    set {_minimumEquityCapital = newValue}
  }
  /// Returns true if `minimumEquityCapital` has been explicitly set.
  var hasMinimumEquityCapital: Bool {return self._minimumEquityCapital != nil}
  /// Clears the value of `minimumEquityCapital`. Subsequent reads from it will return its default value.
  mutating func clearMinimumEquityCapital() {self._minimumEquityCapital = nil}

  /// Maximum fraction of the total staked capital of that a new baker can
  /// have.
  var capitalBound: Concordium_V2_CapitalBound {
    get {return _capitalBound ?? Concordium_V2_CapitalBound()}
    set {_capitalBound = newValue}
  }
  /// Returns true if `capitalBound` has been explicitly set.
  var hasCapitalBound: Bool {return self._capitalBound != nil}
  /// Clears the value of `capitalBound`. Subsequent reads from it will return its default value.
  mutating func clearCapitalBound() {self._capitalBound = nil}

  /// The maximum leverage that a baker can have as a ratio of total stake
  /// to equity capital.
  var leverageBound: Concordium_V2_LeverageFactor {
    get {return _leverageBound ?? Concordium_V2_LeverageFactor()}
    set {_leverageBound = newValue}
  }
  /// Returns true if `leverageBound` has been explicitly set.
  var hasLeverageBound: Bool {return self._leverageBound != nil}
  /// Clears the value of `leverageBound`. Subsequent reads from it will return its default value.
  mutating func clearLeverageBound() {self._leverageBound = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _passiveFinalizationCommission: Concordium_V2_AmountFraction? = nil
  fileprivate var _passiveBakingCommission: Concordium_V2_AmountFraction? = nil
  fileprivate var _passiveTransactionCommission: Concordium_V2_AmountFraction? = nil
  fileprivate var _commissionBounds: Concordium_V2_CommissionRanges? = nil
  fileprivate var _minimumEquityCapital: Concordium_V2_Amount? = nil
  fileprivate var _capitalBound: Concordium_V2_CapitalBound? = nil
  fileprivate var _leverageBound: Concordium_V2_LeverageFactor? = nil
}

/// The time parameters are introduced as of protocol version 4, and consist of
/// the reward period length and the mint rate per payday. These are coupled as
/// a change to either affects the overall rate of minting.
struct Concordium_V2_TimeParametersCpv1: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rewardPeriodLength: Concordium_V2_RewardPeriodLength {
    get {return _rewardPeriodLength ?? Concordium_V2_RewardPeriodLength()}
    set {_rewardPeriodLength = newValue}
  }
  /// Returns true if `rewardPeriodLength` has been explicitly set.
  var hasRewardPeriodLength: Bool {return self._rewardPeriodLength != nil}
  /// Clears the value of `rewardPeriodLength`. Subsequent reads from it will return its default value.
  mutating func clearRewardPeriodLength() {self._rewardPeriodLength = nil}

  var mintPerPayday: Concordium_V2_MintRate {
    get {return _mintPerPayday ?? Concordium_V2_MintRate()}
    set {_mintPerPayday = newValue}
  }
  /// Returns true if `mintPerPayday` has been explicitly set.
  var hasMintPerPayday: Bool {return self._mintPerPayday != nil}
  /// Clears the value of `mintPerPayday`. Subsequent reads from it will return its default value.
  mutating func clearMintPerPayday() {self._mintPerPayday = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rewardPeriodLength: Concordium_V2_RewardPeriodLength? = nil
  fileprivate var _mintPerPayday: Concordium_V2_MintRate? = nil
}

/// Mint distribution payload as it looks in protocol version 4 and onward.
struct Concordium_V2_MintDistributionCpv1: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bakingReward: Concordium_V2_AmountFraction {
    get {return _bakingReward ?? Concordium_V2_AmountFraction()}
    set {_bakingReward = newValue}
  }
  /// Returns true if `bakingReward` has been explicitly set.
  var hasBakingReward: Bool {return self._bakingReward != nil}
  /// Clears the value of `bakingReward`. Subsequent reads from it will return its default value.
  mutating func clearBakingReward() {self._bakingReward = nil}

  var finalizationReward: Concordium_V2_AmountFraction {
    get {return _finalizationReward ?? Concordium_V2_AmountFraction()}
    set {_finalizationReward = newValue}
  }
  /// Returns true if `finalizationReward` has been explicitly set.
  var hasFinalizationReward: Bool {return self._finalizationReward != nil}
  /// Clears the value of `finalizationReward`. Subsequent reads from it will return its default value.
  mutating func clearFinalizationReward() {self._finalizationReward = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bakingReward: Concordium_V2_AmountFraction? = nil
  fileprivate var _finalizationReward: Concordium_V2_AmountFraction? = nil
}

struct Concordium_V2_ProtocolUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A brief message about the update.
  var message_: String = String()

  /// A URL of a document describing the update.
  var specificationURL: String = String()

  /// SHA256 hash of the specification document.
  var specificationHash: Concordium_V2_Sha256Hash {
    get {return _specificationHash ?? Concordium_V2_Sha256Hash()}
    set {_specificationHash = newValue}
  }
  /// Returns true if `specificationHash` has been explicitly set.
  var hasSpecificationHash: Bool {return self._specificationHash != nil}
  /// Clears the value of `specificationHash`. Subsequent reads from it will return its default value.
  mutating func clearSpecificationHash() {self._specificationHash = nil}

  /// Auxiliary data whose interpretation is defined by the new specification.
  var specificationAuxiliaryData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _specificationHash: Concordium_V2_Sha256Hash? = nil
}

/// The minting rate and the distribution of newly-minted CCD among bakers,
/// finalizers, and the foundation account. It must be the case that
/// baking_reward + finalization_reward <= 1. The remaining amount is the
/// platform development charge.
struct Concordium_V2_MintDistributionCpv0: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mint rate per slot.
  var mintPerSlot: Concordium_V2_MintRate {
    get {return _mintPerSlot ?? Concordium_V2_MintRate()}
    set {_mintPerSlot = newValue}
  }
  /// Returns true if `mintPerSlot` has been explicitly set.
  var hasMintPerSlot: Bool {return self._mintPerSlot != nil}
  /// Clears the value of `mintPerSlot`. Subsequent reads from it will return its default value.
  mutating func clearMintPerSlot() {self._mintPerSlot = nil}

  /// The fraction of newly created CCD allocated to baker rewards.
  var bakingReward: Concordium_V2_AmountFraction {
    get {return _bakingReward ?? Concordium_V2_AmountFraction()}
    set {_bakingReward = newValue}
  }
  /// Returns true if `bakingReward` has been explicitly set.
  var hasBakingReward: Bool {return self._bakingReward != nil}
  /// Clears the value of `bakingReward`. Subsequent reads from it will return its default value.
  mutating func clearBakingReward() {self._bakingReward = nil}

  /// The fraction of newly created CCD allocated to finalization rewards.
  var finalizationReward: Concordium_V2_AmountFraction {
    get {return _finalizationReward ?? Concordium_V2_AmountFraction()}
    set {_finalizationReward = newValue}
  }
  /// Returns true if `finalizationReward` has been explicitly set.
  var hasFinalizationReward: Bool {return self._finalizationReward != nil}
  /// Clears the value of `finalizationReward`. Subsequent reads from it will return its default value.
  mutating func clearFinalizationReward() {self._finalizationReward = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mintPerSlot: Concordium_V2_MintRate? = nil
  fileprivate var _bakingReward: Concordium_V2_AmountFraction? = nil
  fileprivate var _finalizationReward: Concordium_V2_AmountFraction? = nil
}

/// Parameters determining the distribution of transaction fees.
struct Concordium_V2_TransactionFeeDistribution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fraction allocated to the baker.
  var baker: Concordium_V2_AmountFraction {
    get {return _baker ?? Concordium_V2_AmountFraction()}
    set {_baker = newValue}
  }
  /// Returns true if `baker` has been explicitly set.
  var hasBaker: Bool {return self._baker != nil}
  /// Clears the value of `baker`. Subsequent reads from it will return its default value.
  mutating func clearBaker() {self._baker = nil}

  /// The fraction allocated to the GAS account.
  var gasAccount: Concordium_V2_AmountFraction {
    get {return _gasAccount ?? Concordium_V2_AmountFraction()}
    set {_gasAccount = newValue}
  }
  /// Returns true if `gasAccount` has been explicitly set.
  var hasGasAccount: Bool {return self._gasAccount != nil}
  /// Clears the value of `gasAccount`. Subsequent reads from it will return its default value.
  mutating func clearGasAccount() {self._gasAccount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baker: Concordium_V2_AmountFraction? = nil
  fileprivate var _gasAccount: Concordium_V2_AmountFraction? = nil
}

/// Distribution of gas rewards for chain parameters version 0 and 1.
struct Concordium_V2_GasRewards: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fraction paid to the baker.
  var baker: Concordium_V2_AmountFraction {
    get {return _baker ?? Concordium_V2_AmountFraction()}
    set {_baker = newValue}
  }
  /// Returns true if `baker` has been explicitly set.
  var hasBaker: Bool {return self._baker != nil}
  /// Clears the value of `baker`. Subsequent reads from it will return its default value.
  mutating func clearBaker() {self._baker = nil}

  /// Fraction paid for including a finalization proof in a block.
  var finalizationProof: Concordium_V2_AmountFraction {
    get {return _finalizationProof ?? Concordium_V2_AmountFraction()}
    set {_finalizationProof = newValue}
  }
  /// Returns true if `finalizationProof` has been explicitly set.
  var hasFinalizationProof: Bool {return self._finalizationProof != nil}
  /// Clears the value of `finalizationProof`. Subsequent reads from it will return its default value.
  mutating func clearFinalizationProof() {self._finalizationProof = nil}

  /// Fraction paid for including each account creation transaction in a block.
  var accountCreation: Concordium_V2_AmountFraction {
    get {return _accountCreation ?? Concordium_V2_AmountFraction()}
    set {_accountCreation = newValue}
  }
  /// Returns true if `accountCreation` has been explicitly set.
  var hasAccountCreation: Bool {return self._accountCreation != nil}
  /// Clears the value of `accountCreation`. Subsequent reads from it will return its default value.
  mutating func clearAccountCreation() {self._accountCreation = nil}

  /// Fraction paid for including an update transaction in a block.
  var chainUpdate: Concordium_V2_AmountFraction {
    get {return _chainUpdate ?? Concordium_V2_AmountFraction()}
    set {_chainUpdate = newValue}
  }
  /// Returns true if `chainUpdate` has been explicitly set.
  var hasChainUpdate: Bool {return self._chainUpdate != nil}
  /// Clears the value of `chainUpdate`. Subsequent reads from it will return its default value.
  mutating func clearChainUpdate() {self._chainUpdate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baker: Concordium_V2_AmountFraction? = nil
  fileprivate var _finalizationProof: Concordium_V2_AmountFraction? = nil
  fileprivate var _accountCreation: Concordium_V2_AmountFraction? = nil
  fileprivate var _chainUpdate: Concordium_V2_AmountFraction? = nil
}

/// Distribution of gas rewards for chain parameters version 2.
struct Concordium_V2_GasRewardsCpv2: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fraction paid to the baker.
  var baker: Concordium_V2_AmountFraction {
    get {return _baker ?? Concordium_V2_AmountFraction()}
    set {_baker = newValue}
  }
  /// Returns true if `baker` has been explicitly set.
  var hasBaker: Bool {return self._baker != nil}
  /// Clears the value of `baker`. Subsequent reads from it will return its default value.
  mutating func clearBaker() {self._baker = nil}

  /// Fraction paid for including each account creation transaction in a block.
  var accountCreation: Concordium_V2_AmountFraction {
    get {return _accountCreation ?? Concordium_V2_AmountFraction()}
    set {_accountCreation = newValue}
  }
  /// Returns true if `accountCreation` has been explicitly set.
  var hasAccountCreation: Bool {return self._accountCreation != nil}
  /// Clears the value of `accountCreation`. Subsequent reads from it will return its default value.
  mutating func clearAccountCreation() {self._accountCreation = nil}

  /// Fraction paid for including an update transaction in a block.
  var chainUpdate: Concordium_V2_AmountFraction {
    get {return _chainUpdate ?? Concordium_V2_AmountFraction()}
    set {_chainUpdate = newValue}
  }
  /// Returns true if `chainUpdate` has been explicitly set.
  var hasChainUpdate: Bool {return self._chainUpdate != nil}
  /// Clears the value of `chainUpdate`. Subsequent reads from it will return its default value.
  mutating func clearChainUpdate() {self._chainUpdate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baker: Concordium_V2_AmountFraction? = nil
  fileprivate var _accountCreation: Concordium_V2_AmountFraction? = nil
  fileprivate var _chainUpdate: Concordium_V2_AmountFraction? = nil
}

/// Minimum stake needed to become a baker. This only applies to protocol version
/// 1-3.
struct Concordium_V2_BakerStakeThreshold: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum threshold required for registering as a baker.
  var bakerStakeThreshold: Concordium_V2_Amount {
    get {return _bakerStakeThreshold ?? Concordium_V2_Amount()}
    set {_bakerStakeThreshold = newValue}
  }
  /// Returns true if `bakerStakeThreshold` has been explicitly set.
  var hasBakerStakeThreshold: Bool {return self._bakerStakeThreshold != nil}
  /// Clears the value of `bakerStakeThreshold`. Subsequent reads from it will return its default value.
  mutating func clearBakerStakeThreshold() {self._bakerStakeThreshold = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bakerStakeThreshold: Concordium_V2_Amount? = nil
}

/// Root updates are the highest kind of key updates. They can update every other set of keys,
/// even themselves. They can only be performed by Root level keys.
struct Concordium_V2_RootUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updateType: Concordium_V2_RootUpdate.OneOf_UpdateType? = nil

  /// The root keys were updated.
  var rootKeysUpdate: Concordium_V2_HigherLevelKeys {
    get {
      if case .rootKeysUpdate(let v)? = updateType {return v}
      return Concordium_V2_HigherLevelKeys()
    }
    set {updateType = .rootKeysUpdate(newValue)}
  }

  /// The level 1 keys were updated.
  var level1KeysUpdate: Concordium_V2_HigherLevelKeys {
    get {
      if case .level1KeysUpdate(let v)? = updateType {return v}
      return Concordium_V2_HigherLevelKeys()
    }
    set {updateType = .level1KeysUpdate(newValue)}
  }

  /// The level 2 keys were updated.
  var level2KeysUpdateV0: Concordium_V2_AuthorizationsV0 {
    get {
      if case .level2KeysUpdateV0(let v)? = updateType {return v}
      return Concordium_V2_AuthorizationsV0()
    }
    set {updateType = .level2KeysUpdateV0(newValue)}
  }

  /// The level 2 keys were updated. This is similar to `level_2_keys_update_v0` except that a few more keys can be updated.
  var level2KeysUpdateV1: Concordium_V2_AuthorizationsV1 {
    get {
      if case .level2KeysUpdateV1(let v)? = updateType {return v}
      return Concordium_V2_AuthorizationsV1()
    }
    set {updateType = .level2KeysUpdateV1(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_UpdateType: Equatable, Sendable {
    /// The root keys were updated.
    case rootKeysUpdate(Concordium_V2_HigherLevelKeys)
    /// The level 1 keys were updated.
    case level1KeysUpdate(Concordium_V2_HigherLevelKeys)
    /// The level 2 keys were updated.
    case level2KeysUpdateV0(Concordium_V2_AuthorizationsV0)
    /// The level 2 keys were updated. This is similar to `level_2_keys_update_v0` except that a few more keys can be updated.
    case level2KeysUpdateV1(Concordium_V2_AuthorizationsV1)

  }

  init() {}
}

/// Level 1 updates are the intermediate update kind.
/// They can update themselves or level 2 keys. They can only be performed by level 1 keys.
struct Concordium_V2_Level1Update: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updateType: Concordium_V2_Level1Update.OneOf_UpdateType? = nil

  /// The level 1 keys were updated.
  var level1KeysUpdate: Concordium_V2_HigherLevelKeys {
    get {
      if case .level1KeysUpdate(let v)? = updateType {return v}
      return Concordium_V2_HigherLevelKeys()
    }
    set {updateType = .level1KeysUpdate(newValue)}
  }

  /// The level 2 keys were updated.
  var level2KeysUpdateV0: Concordium_V2_AuthorizationsV0 {
    get {
      if case .level2KeysUpdateV0(let v)? = updateType {return v}
      return Concordium_V2_AuthorizationsV0()
    }
    set {updateType = .level2KeysUpdateV0(newValue)}
  }

  /// The level 2 keys were updated. This is similar to `level_2_keys_update_v0` except that a few more keys can be updated.
  var level2KeysUpdateV1: Concordium_V2_AuthorizationsV1 {
    get {
      if case .level2KeysUpdateV1(let v)? = updateType {return v}
      return Concordium_V2_AuthorizationsV1()
    }
    set {updateType = .level2KeysUpdateV1(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_UpdateType: Equatable, Sendable {
    /// The level 1 keys were updated.
    case level1KeysUpdate(Concordium_V2_HigherLevelKeys)
    /// The level 2 keys were updated.
    case level2KeysUpdateV0(Concordium_V2_AuthorizationsV0)
    /// The level 2 keys were updated. This is similar to `level_2_keys_update_v0` except that a few more keys can be updated.
    case level2KeysUpdateV1(Concordium_V2_AuthorizationsV1)

  }

  init() {}
}

/// The payload of a chain update.
struct Concordium_V2_UpdatePayload: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Concordium_V2_UpdatePayload.OneOf_Payload? = nil

  /// The protocol version was updated.
  var protocolUpdate: Concordium_V2_ProtocolUpdate {
    get {
      if case .protocolUpdate(let v)? = payload {return v}
      return Concordium_V2_ProtocolUpdate()
    }
    set {payload = .protocolUpdate(newValue)}
  }

  /// The election difficulty was updated.
  var electionDifficultyUpdate: Concordium_V2_ElectionDifficulty {
    get {
      if case .electionDifficultyUpdate(let v)? = payload {return v}
      return Concordium_V2_ElectionDifficulty()
    }
    set {payload = .electionDifficultyUpdate(newValue)}
  }

  /// The euro per energy exchange rate was updated.
  var euroPerEnergyUpdate: Concordium_V2_ExchangeRate {
    get {
      if case .euroPerEnergyUpdate(let v)? = payload {return v}
      return Concordium_V2_ExchangeRate()
    }
    set {payload = .euroPerEnergyUpdate(newValue)}
  }

  /// The microCCD per euro exchange rate was updated.
  var microCcdPerEuroUpdate: Concordium_V2_ExchangeRate {
    get {
      if case .microCcdPerEuroUpdate(let v)? = payload {return v}
      return Concordium_V2_ExchangeRate()
    }
    set {payload = .microCcdPerEuroUpdate(newValue)}
  }

  /// The foundation account address was updated.
  var foundationAccountUpdate: Concordium_V2_AccountAddress {
    get {
      if case .foundationAccountUpdate(let v)? = payload {return v}
      return Concordium_V2_AccountAddress()
    }
    set {payload = .foundationAccountUpdate(newValue)}
  }

  /// The mint distribution was updated.
  var mintDistributionUpdate: Concordium_V2_MintDistributionCpv0 {
    get {
      if case .mintDistributionUpdate(let v)? = payload {return v}
      return Concordium_V2_MintDistributionCpv0()
    }
    set {payload = .mintDistributionUpdate(newValue)}
  }

  /// The transaction fee distribtuion was updated.
  var transactionFeeDistributionUpdate: Concordium_V2_TransactionFeeDistribution {
    get {
      if case .transactionFeeDistributionUpdate(let v)? = payload {return v}
      return Concordium_V2_TransactionFeeDistribution()
    }
    set {payload = .transactionFeeDistributionUpdate(newValue)}
  }

  /// The gas rewards were updated.
  var gasRewardsUpdate: Concordium_V2_GasRewards {
    get {
      if case .gasRewardsUpdate(let v)? = payload {return v}
      return Concordium_V2_GasRewards()
    }
    set {payload = .gasRewardsUpdate(newValue)}
  }

  /// The minimum amount of CCD needed to be come a baker was updated.
  var bakerStakeThresholdUpdate: Concordium_V2_BakerStakeThreshold {
    get {
      if case .bakerStakeThresholdUpdate(let v)? = payload {return v}
      return Concordium_V2_BakerStakeThreshold()
    }
    set {payload = .bakerStakeThresholdUpdate(newValue)}
  }

  /// The root keys were updated.
  var rootUpdate: Concordium_V2_RootUpdate {
    get {
      if case .rootUpdate(let v)? = payload {return v}
      return Concordium_V2_RootUpdate()
    }
    set {payload = .rootUpdate(newValue)}
  }

  /// The level 1 keys were updated.
  var level1Update: Concordium_V2_Level1Update {
    get {
      if case .level1Update(let v)? = payload {return v}
      return Concordium_V2_Level1Update()
    }
    set {payload = .level1Update(newValue)}
  }

  /// An anonymity revoker was added.
  var addAnonymityRevokerUpdate: Concordium_V2_ArInfo {
    get {
      if case .addAnonymityRevokerUpdate(let v)? = payload {return v}
      return Concordium_V2_ArInfo()
    }
    set {payload = .addAnonymityRevokerUpdate(newValue)}
  }

  /// An identity provider was added.
  var addIdentityProviderUpdate: Concordium_V2_IpInfo {
    get {
      if case .addIdentityProviderUpdate(let v)? = payload {return v}
      return Concordium_V2_IpInfo()
    }
    set {payload = .addIdentityProviderUpdate(newValue)}
  }

  /// The cooldown parameters were updated.
  var cooldownParametersCpv1Update: Concordium_V2_CooldownParametersCpv1 {
    get {
      if case .cooldownParametersCpv1Update(let v)? = payload {return v}
      return Concordium_V2_CooldownParametersCpv1()
    }
    set {payload = .cooldownParametersCpv1Update(newValue)}
  }

  /// The pool parameters were updated.
  var poolParametersCpv1Update: Concordium_V2_PoolParametersCpv1 {
    get {
      if case .poolParametersCpv1Update(let v)? = payload {return v}
      return Concordium_V2_PoolParametersCpv1()
    }
    set {payload = .poolParametersCpv1Update(newValue)}
  }

  /// The time parameters were updated.
  var timeParametersCpv1Update: Concordium_V2_TimeParametersCpv1 {
    get {
      if case .timeParametersCpv1Update(let v)? = payload {return v}
      return Concordium_V2_TimeParametersCpv1()
    }
    set {payload = .timeParametersCpv1Update(newValue)}
  }

  /// The mint distribution was updated.
  var mintDistributionCpv1Update: Concordium_V2_MintDistributionCpv1 {
    get {
      if case .mintDistributionCpv1Update(let v)? = payload {return v}
      return Concordium_V2_MintDistributionCpv1()
    }
    set {payload = .mintDistributionCpv1Update(newValue)}
  }

  /// The gas rewards were updated (chain parameters version 2).
  var gasRewardsCpv2Update: Concordium_V2_GasRewardsCpv2 {
    get {
      if case .gasRewardsCpv2Update(let v)? = payload {return v}
      return Concordium_V2_GasRewardsCpv2()
    }
    set {payload = .gasRewardsCpv2Update(newValue)}
  }

  /// The consensus timeouts were updated (chain parameters version 2).
  var timeoutParametersUpdate: Concordium_V2_TimeoutParameters {
    get {
      if case .timeoutParametersUpdate(let v)? = payload {return v}
      return Concordium_V2_TimeoutParameters()
    }
    set {payload = .timeoutParametersUpdate(newValue)}
  }

  /// The minimum time between blocks was updated (chain parameters version 2).
  var minBlockTimeUpdate: Concordium_V2_Duration {
    get {
      if case .minBlockTimeUpdate(let v)? = payload {return v}
      return Concordium_V2_Duration()
    }
    set {payload = .minBlockTimeUpdate(newValue)}
  }

  /// The block energy limit was updated (chain parameters version 2).
  var blockEnergyLimitUpdate: Concordium_V2_Energy {
    get {
      if case .blockEnergyLimitUpdate(let v)? = payload {return v}
      return Concordium_V2_Energy()
    }
    set {payload = .blockEnergyLimitUpdate(newValue)}
  }

  /// Finalization committee parameters (chain parameters version 2).
  var finalizationCommitteeParametersUpdate: Concordium_V2_FinalizationCommitteeParameters {
    get {
      if case .finalizationCommitteeParametersUpdate(let v)? = payload {return v}
      return Concordium_V2_FinalizationCommitteeParameters()
    }
    set {payload = .finalizationCommitteeParametersUpdate(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, Sendable {
    /// The protocol version was updated.
    case protocolUpdate(Concordium_V2_ProtocolUpdate)
    /// The election difficulty was updated.
    case electionDifficultyUpdate(Concordium_V2_ElectionDifficulty)
    /// The euro per energy exchange rate was updated.
    case euroPerEnergyUpdate(Concordium_V2_ExchangeRate)
    /// The microCCD per euro exchange rate was updated.
    case microCcdPerEuroUpdate(Concordium_V2_ExchangeRate)
    /// The foundation account address was updated.
    case foundationAccountUpdate(Concordium_V2_AccountAddress)
    /// The mint distribution was updated.
    case mintDistributionUpdate(Concordium_V2_MintDistributionCpv0)
    /// The transaction fee distribtuion was updated.
    case transactionFeeDistributionUpdate(Concordium_V2_TransactionFeeDistribution)
    /// The gas rewards were updated.
    case gasRewardsUpdate(Concordium_V2_GasRewards)
    /// The minimum amount of CCD needed to be come a baker was updated.
    case bakerStakeThresholdUpdate(Concordium_V2_BakerStakeThreshold)
    /// The root keys were updated.
    case rootUpdate(Concordium_V2_RootUpdate)
    /// The level 1 keys were updated.
    case level1Update(Concordium_V2_Level1Update)
    /// An anonymity revoker was added.
    case addAnonymityRevokerUpdate(Concordium_V2_ArInfo)
    /// An identity provider was added.
    case addIdentityProviderUpdate(Concordium_V2_IpInfo)
    /// The cooldown parameters were updated.
    case cooldownParametersCpv1Update(Concordium_V2_CooldownParametersCpv1)
    /// The pool parameters were updated.
    case poolParametersCpv1Update(Concordium_V2_PoolParametersCpv1)
    /// The time parameters were updated.
    case timeParametersCpv1Update(Concordium_V2_TimeParametersCpv1)
    /// The mint distribution was updated.
    case mintDistributionCpv1Update(Concordium_V2_MintDistributionCpv1)
    /// The gas rewards were updated (chain parameters version 2).
    case gasRewardsCpv2Update(Concordium_V2_GasRewardsCpv2)
    /// The consensus timeouts were updated (chain parameters version 2).
    case timeoutParametersUpdate(Concordium_V2_TimeoutParameters)
    /// The minimum time between blocks was updated (chain parameters version 2).
    case minBlockTimeUpdate(Concordium_V2_Duration)
    /// The block energy limit was updated (chain parameters version 2).
    case blockEnergyLimitUpdate(Concordium_V2_Energy)
    /// Finalization committee parameters (chain parameters version 2).
    case finalizationCommitteeParametersUpdate(Concordium_V2_FinalizationCommitteeParameters)

  }

  init() {}
}

/// Details about an account transaction.
struct Concordium_V2_AccountTransactionDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The cost of the transaction. Paid by the sender.
  var cost: Concordium_V2_Amount {
    get {return _cost ?? Concordium_V2_Amount()}
    set {_cost = newValue}
  }
  /// Returns true if `cost` has been explicitly set.
  var hasCost: Bool {return self._cost != nil}
  /// Clears the value of `cost`. Subsequent reads from it will return its default value.
  mutating func clearCost() {self._cost = nil}

  /// The sender of the transaction.
  var sender: Concordium_V2_AccountAddress {
    get {return _sender ?? Concordium_V2_AccountAddress()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  mutating func clearSender() {self._sender = nil}

  /// The effects of the transaction.
  var effects: Concordium_V2_AccountTransactionEffects {
    get {return _effects ?? Concordium_V2_AccountTransactionEffects()}
    set {_effects = newValue}
  }
  /// Returns true if `effects` has been explicitly set.
  var hasEffects: Bool {return self._effects != nil}
  /// Clears the value of `effects`. Subsequent reads from it will return its default value.
  mutating func clearEffects() {self._effects = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cost: Concordium_V2_Amount? = nil
  fileprivate var _sender: Concordium_V2_AccountAddress? = nil
  fileprivate var _effects: Concordium_V2_AccountTransactionEffects? = nil
}

/// Details of an account creation. These transactions are free, and we only
/// ever get a response for them if the account is created, hence no failure
/// cases.
struct Concordium_V2_AccountCreationDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether this is an initial or normal account.
  var credentialType: Concordium_V2_CredentialType = .initial

  /// Address of the newly created account.
  var address: Concordium_V2_AccountAddress {
    get {return _address ?? Concordium_V2_AccountAddress()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  /// Credential registration ID of the first credential.
  var regID: Concordium_V2_CredentialRegistrationId {
    get {return _regID ?? Concordium_V2_CredentialRegistrationId()}
    set {_regID = newValue}
  }
  /// Returns true if `regID` has been explicitly set.
  var hasRegID: Bool {return self._regID != nil}
  /// Clears the value of `regID`. Subsequent reads from it will return its default value.
  mutating func clearRegID() {self._regID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _address: Concordium_V2_AccountAddress? = nil
  fileprivate var _regID: Concordium_V2_CredentialRegistrationId? = nil
}

/// Transaction time specified as seconds since unix epoch.
struct Concordium_V2_TransactionTime: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Details of an update instruction. These are free, and we only ever get a
/// response for them if the update is successfully enqueued, hence no failure
/// cases.
struct Concordium_V2_UpdateDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time at which the update will be effective.
  var effectiveTime: Concordium_V2_TransactionTime {
    get {return _effectiveTime ?? Concordium_V2_TransactionTime()}
    set {_effectiveTime = newValue}
  }
  /// Returns true if `effectiveTime` has been explicitly set.
  var hasEffectiveTime: Bool {return self._effectiveTime != nil}
  /// Clears the value of `effectiveTime`. Subsequent reads from it will return its default value.
  mutating func clearEffectiveTime() {self._effectiveTime = nil}

  /// The paylaod for the update.
  var payload: Concordium_V2_UpdatePayload {
    get {return _payload ?? Concordium_V2_UpdatePayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _effectiveTime: Concordium_V2_TransactionTime? = nil
  fileprivate var _payload: Concordium_V2_UpdatePayload? = nil
}

/// Summary of the outcome of a block item in structured form.
/// The summary determines which transaction type it was.
struct Concordium_V2_BlockItemSummary: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Index of the transaction in the block where it is included.
  var index: Concordium_V2_BlockItemSummary.TransactionIndex {
    get {return _storage._index ?? Concordium_V2_BlockItemSummary.TransactionIndex()}
    set {_uniqueStorage()._index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  var hasIndex: Bool {return _storage._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  mutating func clearIndex() {_uniqueStorage()._index = nil}

  /// The amount of NRG the transaction cost.
  var energyCost: Concordium_V2_Energy {
    get {return _storage._energyCost ?? Concordium_V2_Energy()}
    set {_uniqueStorage()._energyCost = newValue}
  }
  /// Returns true if `energyCost` has been explicitly set.
  var hasEnergyCost: Bool {return _storage._energyCost != nil}
  /// Clears the value of `energyCost`. Subsequent reads from it will return its default value.
  mutating func clearEnergyCost() {_uniqueStorage()._energyCost = nil}

  /// Hash of the transaction.
  var hash: Concordium_V2_TransactionHash {
    get {return _storage._hash ?? Concordium_V2_TransactionHash()}
    set {_uniqueStorage()._hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return _storage._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {_uniqueStorage()._hash = nil}

  /// Details that are specific to different transaction types.
  var details: OneOf_Details? {
    get {return _storage._details}
    set {_uniqueStorage()._details = newValue}
  }

  /// Details about an account transaction.
  var accountTransaction: Concordium_V2_AccountTransactionDetails {
    get {
      if case .accountTransaction(let v)? = _storage._details {return v}
      return Concordium_V2_AccountTransactionDetails()
    }
    set {_uniqueStorage()._details = .accountTransaction(newValue)}
  }

  /// Details about an account creation.
  var accountCreation: Concordium_V2_AccountCreationDetails {
    get {
      if case .accountCreation(let v)? = _storage._details {return v}
      return Concordium_V2_AccountCreationDetails()
    }
    set {_uniqueStorage()._details = .accountCreation(newValue)}
  }

  /// Details about a chain update.
  var update: Concordium_V2_UpdateDetails {
    get {
      if case .update(let v)? = _storage._details {return v}
      return Concordium_V2_UpdateDetails()
    }
    set {_uniqueStorage()._details = .update(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Details that are specific to different transaction types.
  enum OneOf_Details: Equatable, Sendable {
    /// Details about an account transaction.
    case accountTransaction(Concordium_V2_AccountTransactionDetails)
    /// Details about an account creation.
    case accountCreation(Concordium_V2_AccountCreationDetails)
    /// Details about a chain update.
    case update(Concordium_V2_UpdateDetails)

  }

  struct TransactionIndex: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var value: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The number of chain restarts via a protocol update. An effected
/// protocol update instruction might not change the protocol version
/// specified in the previous field, but it always increments the genesis
/// index.
struct Concordium_V2_GenesisIndex: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response for GetConsensusInfo.
struct Concordium_V2_ConsensusInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hash of the current best block.
  var bestBlock: Concordium_V2_BlockHash {
    get {return _storage._bestBlock ?? Concordium_V2_BlockHash()}
    set {_uniqueStorage()._bestBlock = newValue}
  }
  /// Returns true if `bestBlock` has been explicitly set.
  var hasBestBlock: Bool {return _storage._bestBlock != nil}
  /// Clears the value of `bestBlock`. Subsequent reads from it will return its default value.
  mutating func clearBestBlock() {_uniqueStorage()._bestBlock = nil}

  /// Hash of the (original) genesis block.
  var genesisBlock: Concordium_V2_BlockHash {
    get {return _storage._genesisBlock ?? Concordium_V2_BlockHash()}
    set {_uniqueStorage()._genesisBlock = newValue}
  }
  /// Returns true if `genesisBlock` has been explicitly set.
  var hasGenesisBlock: Bool {return _storage._genesisBlock != nil}
  /// Clears the value of `genesisBlock`. Subsequent reads from it will return its default value.
  mutating func clearGenesisBlock() {_uniqueStorage()._genesisBlock = nil}

  /// Time of the (original) genesis block.
  var genesisTime: Concordium_V2_Timestamp {
    get {return _storage._genesisTime ?? Concordium_V2_Timestamp()}
    set {_uniqueStorage()._genesisTime = newValue}
  }
  /// Returns true if `genesisTime` has been explicitly set.
  var hasGenesisTime: Bool {return _storage._genesisTime != nil}
  /// Clears the value of `genesisTime`. Subsequent reads from it will return its default value.
  mutating func clearGenesisTime() {_uniqueStorage()._genesisTime = nil}

  /// (Current) slot duration in milliseconds. Present only in protocol versions 1-5.
  var slotDuration: Concordium_V2_Duration {
    get {return _storage._slotDuration ?? Concordium_V2_Duration()}
    set {_uniqueStorage()._slotDuration = newValue}
  }
  /// Returns true if `slotDuration` has been explicitly set.
  var hasSlotDuration: Bool {return _storage._slotDuration != nil}
  /// Clears the value of `slotDuration`. Subsequent reads from it will return its default value.
  mutating func clearSlotDuration() {_uniqueStorage()._slotDuration = nil}

  /// (Current) epoch duration in milliseconds.
  var epochDuration: Concordium_V2_Duration {
    get {return _storage._epochDuration ?? Concordium_V2_Duration()}
    set {_uniqueStorage()._epochDuration = newValue}
  }
  /// Returns true if `epochDuration` has been explicitly set.
  var hasEpochDuration: Bool {return _storage._epochDuration != nil}
  /// Clears the value of `epochDuration`. Subsequent reads from it will return its default value.
  mutating func clearEpochDuration() {_uniqueStorage()._epochDuration = nil}

  /// Hash of the last finalized block.
  var lastFinalizedBlock: Concordium_V2_BlockHash {
    get {return _storage._lastFinalizedBlock ?? Concordium_V2_BlockHash()}
    set {_uniqueStorage()._lastFinalizedBlock = newValue}
  }
  /// Returns true if `lastFinalizedBlock` has been explicitly set.
  var hasLastFinalizedBlock: Bool {return _storage._lastFinalizedBlock != nil}
  /// Clears the value of `lastFinalizedBlock`. Subsequent reads from it will return its default value.
  mutating func clearLastFinalizedBlock() {_uniqueStorage()._lastFinalizedBlock = nil}

  /// Absolute height of the best block.
  var bestBlockHeight: Concordium_V2_AbsoluteBlockHeight {
    get {return _storage._bestBlockHeight ?? Concordium_V2_AbsoluteBlockHeight()}
    set {_uniqueStorage()._bestBlockHeight = newValue}
  }
  /// Returns true if `bestBlockHeight` has been explicitly set.
  var hasBestBlockHeight: Bool {return _storage._bestBlockHeight != nil}
  /// Clears the value of `bestBlockHeight`. Subsequent reads from it will return its default value.
  mutating func clearBestBlockHeight() {_uniqueStorage()._bestBlockHeight = nil}

  /// Absolute height of the last finalized block.
  var lastFinalizedBlockHeight: Concordium_V2_AbsoluteBlockHeight {
    get {return _storage._lastFinalizedBlockHeight ?? Concordium_V2_AbsoluteBlockHeight()}
    set {_uniqueStorage()._lastFinalizedBlockHeight = newValue}
  }
  /// Returns true if `lastFinalizedBlockHeight` has been explicitly set.
  var hasLastFinalizedBlockHeight: Bool {return _storage._lastFinalizedBlockHeight != nil}
  /// Clears the value of `lastFinalizedBlockHeight`. Subsequent reads from it will return its default value.
  mutating func clearLastFinalizedBlockHeight() {_uniqueStorage()._lastFinalizedBlockHeight = nil}

  /// Total number of blocks received.
  var blocksReceivedCount: UInt32 {
    get {return _storage._blocksReceivedCount}
    set {_uniqueStorage()._blocksReceivedCount = newValue}
  }

  /// The last time a block was received.
  var blockLastReceivedTime: Concordium_V2_Timestamp {
    get {return _storage._blockLastReceivedTime ?? Concordium_V2_Timestamp()}
    set {_uniqueStorage()._blockLastReceivedTime = newValue}
  }
  /// Returns true if `blockLastReceivedTime` has been explicitly set.
  var hasBlockLastReceivedTime: Bool {return _storage._blockLastReceivedTime != nil}
  /// Clears the value of `blockLastReceivedTime`. Subsequent reads from it will return its default value.
  mutating func clearBlockLastReceivedTime() {_uniqueStorage()._blockLastReceivedTime = nil}

  /// Exponential moving average latency between a block's slot time and received time.
  var blockReceiveLatencyEma: Double {
    get {return _storage._blockReceiveLatencyEma}
    set {_uniqueStorage()._blockReceiveLatencyEma = newValue}
  }

  /// Standard deviation of exponential moving average latency between a block's slot time and received time.
  var blockReceiveLatencyEmsd: Double {
    get {return _storage._blockReceiveLatencyEmsd}
    set {_uniqueStorage()._blockReceiveLatencyEmsd = newValue}
  }

  /// Exponential moving average time between receiving blocks.
  var blockReceivePeriodEma: Double {
    get {return _storage._blockReceivePeriodEma ?? 0}
    set {_uniqueStorage()._blockReceivePeriodEma = newValue}
  }
  /// Returns true if `blockReceivePeriodEma` has been explicitly set.
  var hasBlockReceivePeriodEma: Bool {return _storage._blockReceivePeriodEma != nil}
  /// Clears the value of `blockReceivePeriodEma`. Subsequent reads from it will return its default value.
  mutating func clearBlockReceivePeriodEma() {_uniqueStorage()._blockReceivePeriodEma = nil}

  /// Standard deviation of exponential moving average time between receiving blocks.
  var blockReceivePeriodEmsd: Double {
    get {return _storage._blockReceivePeriodEmsd ?? 0}
    set {_uniqueStorage()._blockReceivePeriodEmsd = newValue}
  }
  /// Returns true if `blockReceivePeriodEmsd` has been explicitly set.
  var hasBlockReceivePeriodEmsd: Bool {return _storage._blockReceivePeriodEmsd != nil}
  /// Clears the value of `blockReceivePeriodEmsd`. Subsequent reads from it will return its default value.
  mutating func clearBlockReceivePeriodEmsd() {_uniqueStorage()._blockReceivePeriodEmsd = nil}

  /// Total number of blocks received and verified.
  var blocksVerifiedCount: UInt32 {
    get {return _storage._blocksVerifiedCount}
    set {_uniqueStorage()._blocksVerifiedCount = newValue}
  }

  /// The last time a block was verified (added to the tree).
  var blockLastArrivedTime: Concordium_V2_Timestamp {
    get {return _storage._blockLastArrivedTime ?? Concordium_V2_Timestamp()}
    set {_uniqueStorage()._blockLastArrivedTime = newValue}
  }
  /// Returns true if `blockLastArrivedTime` has been explicitly set.
  var hasBlockLastArrivedTime: Bool {return _storage._blockLastArrivedTime != nil}
  /// Clears the value of `blockLastArrivedTime`. Subsequent reads from it will return its default value.
  mutating func clearBlockLastArrivedTime() {_uniqueStorage()._blockLastArrivedTime = nil}

  /// Exponential moving average latency between a block's slot time and its arrival.
  var blockArriveLatencyEma: Double {
    get {return _storage._blockArriveLatencyEma}
    set {_uniqueStorage()._blockArriveLatencyEma = newValue}
  }

  /// Standard deviation of exponential moving average latency between a block's slot time and its arrival.
  var blockArriveLatencyEmsd: Double {
    get {return _storage._blockArriveLatencyEmsd}
    set {_uniqueStorage()._blockArriveLatencyEmsd = newValue}
  }

  /// Exponential moving average time between block arrivals.
  var blockArrivePeriodEma: Double {
    get {return _storage._blockArrivePeriodEma ?? 0}
    set {_uniqueStorage()._blockArrivePeriodEma = newValue}
  }
  /// Returns true if `blockArrivePeriodEma` has been explicitly set.
  var hasBlockArrivePeriodEma: Bool {return _storage._blockArrivePeriodEma != nil}
  /// Clears the value of `blockArrivePeriodEma`. Subsequent reads from it will return its default value.
  mutating func clearBlockArrivePeriodEma() {_uniqueStorage()._blockArrivePeriodEma = nil}

  /// Standard deviation of exponential moving average time between block arrivals.
  var blockArrivePeriodEmsd: Double {
    get {return _storage._blockArrivePeriodEmsd ?? 0}
    set {_uniqueStorage()._blockArrivePeriodEmsd = newValue}
  }
  /// Returns true if `blockArrivePeriodEmsd` has been explicitly set.
  var hasBlockArrivePeriodEmsd: Bool {return _storage._blockArrivePeriodEmsd != nil}
  /// Clears the value of `blockArrivePeriodEmsd`. Subsequent reads from it will return its default value.
  mutating func clearBlockArrivePeriodEmsd() {_uniqueStorage()._blockArrivePeriodEmsd = nil}

  /// Exponential moving average number of transactions per block.
  var transactionsPerBlockEma: Double {
    get {return _storage._transactionsPerBlockEma}
    set {_uniqueStorage()._transactionsPerBlockEma = newValue}
  }

  /// Standard deviation of exponential moving average number of transactions per block.
  var transactionsPerBlockEmsd: Double {
    get {return _storage._transactionsPerBlockEmsd}
    set {_uniqueStorage()._transactionsPerBlockEmsd = newValue}
  }

  /// Number of finalizations.
  var finalizationCount: UInt32 {
    get {return _storage._finalizationCount}
    set {_uniqueStorage()._finalizationCount = newValue}
  }

  /// Time of last verified finalization.
  var lastFinalizedTime: Concordium_V2_Timestamp {
    get {return _storage._lastFinalizedTime ?? Concordium_V2_Timestamp()}
    set {_uniqueStorage()._lastFinalizedTime = newValue}
  }
  /// Returns true if `lastFinalizedTime` has been explicitly set.
  var hasLastFinalizedTime: Bool {return _storage._lastFinalizedTime != nil}
  /// Clears the value of `lastFinalizedTime`. Subsequent reads from it will return its default value.
  mutating func clearLastFinalizedTime() {_uniqueStorage()._lastFinalizedTime = nil}

  /// Exponential moving average time between finalizations.
  var finalizationPeriodEma: Double {
    get {return _storage._finalizationPeriodEma ?? 0}
    set {_uniqueStorage()._finalizationPeriodEma = newValue}
  }
  /// Returns true if `finalizationPeriodEma` has been explicitly set.
  var hasFinalizationPeriodEma: Bool {return _storage._finalizationPeriodEma != nil}
  /// Clears the value of `finalizationPeriodEma`. Subsequent reads from it will return its default value.
  mutating func clearFinalizationPeriodEma() {_uniqueStorage()._finalizationPeriodEma = nil}

  /// Standard deviation of exponential moving average time between finalizations.
  var finalizationPeriodEmsd: Double {
    get {return _storage._finalizationPeriodEmsd ?? 0}
    set {_uniqueStorage()._finalizationPeriodEmsd = newValue}
  }
  /// Returns true if `finalizationPeriodEmsd` has been explicitly set.
  var hasFinalizationPeriodEmsd: Bool {return _storage._finalizationPeriodEmsd != nil}
  /// Clears the value of `finalizationPeriodEmsd`. Subsequent reads from it will return its default value.
  mutating func clearFinalizationPeriodEmsd() {_uniqueStorage()._finalizationPeriodEmsd = nil}

  /// Currently active protocol version.
  var protocolVersion: Concordium_V2_ProtocolVersion {
    get {return _storage._protocolVersion}
    set {_uniqueStorage()._protocolVersion = newValue}
  }

  /// The number of chain restarts via a protocol update. A completed
  /// protocol update instruction might not change the protocol version
  /// specified in the previous field, but it always increments the genesis
  /// index.
  var genesisIndex: Concordium_V2_GenesisIndex {
    get {return _storage._genesisIndex ?? Concordium_V2_GenesisIndex()}
    set {_uniqueStorage()._genesisIndex = newValue}
  }
  /// Returns true if `genesisIndex` has been explicitly set.
  var hasGenesisIndex: Bool {return _storage._genesisIndex != nil}
  /// Clears the value of `genesisIndex`. Subsequent reads from it will return its default value.
  mutating func clearGenesisIndex() {_uniqueStorage()._genesisIndex = nil}

  /// Block hash of the genesis block of current era, i.e., since the last protocol update.
  /// Initially this is equal to 'genesis_block'.
  var currentEraGenesisBlock: Concordium_V2_BlockHash {
    get {return _storage._currentEraGenesisBlock ?? Concordium_V2_BlockHash()}
    set {_uniqueStorage()._currentEraGenesisBlock = newValue}
  }
  /// Returns true if `currentEraGenesisBlock` has been explicitly set.
  var hasCurrentEraGenesisBlock: Bool {return _storage._currentEraGenesisBlock != nil}
  /// Clears the value of `currentEraGenesisBlock`. Subsequent reads from it will return its default value.
  mutating func clearCurrentEraGenesisBlock() {_uniqueStorage()._currentEraGenesisBlock = nil}

  /// Time when the current era started.
  var currentEraGenesisTime: Concordium_V2_Timestamp {
    get {return _storage._currentEraGenesisTime ?? Concordium_V2_Timestamp()}
    set {_uniqueStorage()._currentEraGenesisTime = newValue}
  }
  /// Returns true if `currentEraGenesisTime` has been explicitly set.
  var hasCurrentEraGenesisTime: Bool {return _storage._currentEraGenesisTime != nil}
  /// Clears the value of `currentEraGenesisTime`. Subsequent reads from it will return its default value.
  mutating func clearCurrentEraGenesisTime() {_uniqueStorage()._currentEraGenesisTime = nil}

  /// The current duration to wait before a round times out. Present from protocol version 6.
  var currentTimeoutDuration: Concordium_V2_Duration {
    get {return _storage._currentTimeoutDuration ?? Concordium_V2_Duration()}
    set {_uniqueStorage()._currentTimeoutDuration = newValue}
  }
  /// Returns true if `currentTimeoutDuration` has been explicitly set.
  var hasCurrentTimeoutDuration: Bool {return _storage._currentTimeoutDuration != nil}
  /// Clears the value of `currentTimeoutDuration`. Subsequent reads from it will return its default value.
  mutating func clearCurrentTimeoutDuration() {_uniqueStorage()._currentTimeoutDuration = nil}

  /// The current round. Present from protocol version 6.
  var currentRound: Concordium_V2_Round {
    get {return _storage._currentRound ?? Concordium_V2_Round()}
    set {_uniqueStorage()._currentRound = newValue}
  }
  /// Returns true if `currentRound` has been explicitly set.
  var hasCurrentRound: Bool {return _storage._currentRound != nil}
  /// Clears the value of `currentRound`. Subsequent reads from it will return its default value.
  mutating func clearCurrentRound() {_uniqueStorage()._currentRound = nil}

  /// The current epoch. Present from protocol version 6.
  var currentEpoch: Concordium_V2_Epoch {
    get {return _storage._currentEpoch ?? Concordium_V2_Epoch()}
    set {_uniqueStorage()._currentEpoch = newValue}
  }
  /// Returns true if `currentEpoch` has been explicitly set.
  var hasCurrentEpoch: Bool {return _storage._currentEpoch != nil}
  /// Clears the value of `currentEpoch`. Subsequent reads from it will return its default value.
  mutating func clearCurrentEpoch() {_uniqueStorage()._currentEpoch = nil}

  /// The first block in the epoch with timestamp at least this is considered to be the trigger block
  /// for the epoch transition. Present from protocol version 6.
  var triggerBlockTime: Concordium_V2_Timestamp {
    get {return _storage._triggerBlockTime ?? Concordium_V2_Timestamp()}
    set {_uniqueStorage()._triggerBlockTime = newValue}
  }
  /// Returns true if `triggerBlockTime` has been explicitly set.
  var hasTriggerBlockTime: Bool {return _storage._triggerBlockTime != nil}
  /// Clears the value of `triggerBlockTime`. Subsequent reads from it will return its default value.
  mutating func clearTriggerBlockTime() {_uniqueStorage()._triggerBlockTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Information about an arrived block that is part of the streaming response.
struct Concordium_V2_ArrivedBlockInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hash of the block.
  var hash: Concordium_V2_BlockHash {
    get {return _hash ?? Concordium_V2_BlockHash()}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  /// Absolute height of the block, height 0 is the genesis block.
  var height: Concordium_V2_AbsoluteBlockHeight {
    get {return _height ?? Concordium_V2_AbsoluteBlockHeight()}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hash: Concordium_V2_BlockHash? = nil
  fileprivate var _height: Concordium_V2_AbsoluteBlockHeight? = nil
}

/// The response for GetCryptographicParameters.
struct Concordium_V2_CryptographicParameters: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A free-form string used to distinguish between different chains even if they share other parameters.
  var genesisString: String = String()

  /// Generators for the bulletproofs.
  /// It is a serialized list of 256 group elements in the G1 group of the BLS12-381 curve.
  var bulletproofGenerators: Data = Data()

  /// A shared commitment key known to the chain and the account holder (and therefore it is public).
  /// The account holder uses this commitment key to generate commitments to values in the attribute list.
  /// It is a serialized pair of group elements  in the G1 group of the BLS12-381 curve.
  var onChainCommitmentKey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response for GetBlockInfo.
struct Concordium_V2_BlockInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hash of the block.
  var hash: Concordium_V2_BlockHash {
    get {return _storage._hash ?? Concordium_V2_BlockHash()}
    set {_uniqueStorage()._hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return _storage._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {_uniqueStorage()._hash = nil}

  /// Absolute height of the block, height 0 is the genesis block.
  var height: Concordium_V2_AbsoluteBlockHeight {
    get {return _storage._height ?? Concordium_V2_AbsoluteBlockHeight()}
    set {_uniqueStorage()._height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return _storage._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {_uniqueStorage()._height = nil}

  /// The parent block hash. For a re-genesis block, this will be the terminal block of the
  /// previous chain. For the initial genesis block, this will be the hash of the block itself.
  var parentBlock: Concordium_V2_BlockHash {
    get {return _storage._parentBlock ?? Concordium_V2_BlockHash()}
    set {_uniqueStorage()._parentBlock = newValue}
  }
  /// Returns true if `parentBlock` has been explicitly set.
  var hasParentBlock: Bool {return _storage._parentBlock != nil}
  /// Clears the value of `parentBlock`. Subsequent reads from it will return its default value.
  mutating func clearParentBlock() {_uniqueStorage()._parentBlock = nil}

  /// The last finalized block when this block was baked.
  var lastFinalizedBlock: Concordium_V2_BlockHash {
    get {return _storage._lastFinalizedBlock ?? Concordium_V2_BlockHash()}
    set {_uniqueStorage()._lastFinalizedBlock = newValue}
  }
  /// Returns true if `lastFinalizedBlock` has been explicitly set.
  var hasLastFinalizedBlock: Bool {return _storage._lastFinalizedBlock != nil}
  /// Clears the value of `lastFinalizedBlock`. Subsequent reads from it will return its default value.
  mutating func clearLastFinalizedBlock() {_uniqueStorage()._lastFinalizedBlock = nil}

  /// The genesis index for this block. This counts the number of protocol updates that have
  /// preceded this block, and defines the era of the block.
  var genesisIndex: Concordium_V2_GenesisIndex {
    get {return _storage._genesisIndex ?? Concordium_V2_GenesisIndex()}
    set {_uniqueStorage()._genesisIndex = newValue}
  }
  /// Returns true if `genesisIndex` has been explicitly set.
  var hasGenesisIndex: Bool {return _storage._genesisIndex != nil}
  /// Clears the value of `genesisIndex`. Subsequent reads from it will return its default value.
  mutating func clearGenesisIndex() {_uniqueStorage()._genesisIndex = nil}

  /// The height of this block relative to the (re)genesis block of its era.
  var eraBlockHeight: Concordium_V2_BlockHeight {
    get {return _storage._eraBlockHeight ?? Concordium_V2_BlockHeight()}
    set {_uniqueStorage()._eraBlockHeight = newValue}
  }
  /// Returns true if `eraBlockHeight` has been explicitly set.
  var hasEraBlockHeight: Bool {return _storage._eraBlockHeight != nil}
  /// Clears the value of `eraBlockHeight`. Subsequent reads from it will return its default value.
  mutating func clearEraBlockHeight() {_uniqueStorage()._eraBlockHeight = nil}

  /// The time the block was received.
  var receiveTime: Concordium_V2_Timestamp {
    get {return _storage._receiveTime ?? Concordium_V2_Timestamp()}
    set {_uniqueStorage()._receiveTime = newValue}
  }
  /// Returns true if `receiveTime` has been explicitly set.
  var hasReceiveTime: Bool {return _storage._receiveTime != nil}
  /// Clears the value of `receiveTime`. Subsequent reads from it will return its default value.
  mutating func clearReceiveTime() {_uniqueStorage()._receiveTime = nil}

  /// The time the block was verified.
  var arriveTime: Concordium_V2_Timestamp {
    get {return _storage._arriveTime ?? Concordium_V2_Timestamp()}
    set {_uniqueStorage()._arriveTime = newValue}
  }
  /// Returns true if `arriveTime` has been explicitly set.
  var hasArriveTime: Bool {return _storage._arriveTime != nil}
  /// Clears the value of `arriveTime`. Subsequent reads from it will return its default value.
  mutating func clearArriveTime() {_uniqueStorage()._arriveTime = nil}

  /// The slot number in which the block was baked. Present in protocol versions 1-5.
  var slotNumber: Concordium_V2_Slot {
    get {return _storage._slotNumber ?? Concordium_V2_Slot()}
    set {_uniqueStorage()._slotNumber = newValue}
  }
  /// Returns true if `slotNumber` has been explicitly set.
  var hasSlotNumber: Bool {return _storage._slotNumber != nil}
  /// Clears the value of `slotNumber`. Subsequent reads from it will return its default value.
  mutating func clearSlotNumber() {_uniqueStorage()._slotNumber = nil}

  /// The time of the slot in which the block was baked.
  var slotTime: Concordium_V2_Timestamp {
    get {return _storage._slotTime ?? Concordium_V2_Timestamp()}
    set {_uniqueStorage()._slotTime = newValue}
  }
  /// Returns true if `slotTime` has been explicitly set.
  var hasSlotTime: Bool {return _storage._slotTime != nil}
  /// Clears the value of `slotTime`. Subsequent reads from it will return its default value.
  mutating func clearSlotTime() {_uniqueStorage()._slotTime = nil}

  /// The baker id of account baking this block. Not provided for a genesis block.
  var baker: Concordium_V2_BakerId {
    get {return _storage._baker ?? Concordium_V2_BakerId()}
    set {_uniqueStorage()._baker = newValue}
  }
  /// Returns true if `baker` has been explicitly set.
  var hasBaker: Bool {return _storage._baker != nil}
  /// Clears the value of `baker`. Subsequent reads from it will return its default value.
  mutating func clearBaker() {_uniqueStorage()._baker = nil}

  /// Whether the block is finalized.
  var finalized: Bool {
    get {return _storage._finalized}
    set {_uniqueStorage()._finalized = newValue}
  }

  /// The number of transactions in the block.
  var transactionCount: UInt32 {
    get {return _storage._transactionCount}
    set {_uniqueStorage()._transactionCount = newValue}
  }

  /// The energy cost of the transactions in the block.
  var transactionsEnergyCost: Concordium_V2_Energy {
    get {return _storage._transactionsEnergyCost ?? Concordium_V2_Energy()}
    set {_uniqueStorage()._transactionsEnergyCost = newValue}
  }
  /// Returns true if `transactionsEnergyCost` has been explicitly set.
  var hasTransactionsEnergyCost: Bool {return _storage._transactionsEnergyCost != nil}
  /// Clears the value of `transactionsEnergyCost`. Subsequent reads from it will return its default value.
  mutating func clearTransactionsEnergyCost() {_uniqueStorage()._transactionsEnergyCost = nil}

  /// The total byte size of all transactions in the block.
  var transactionsSize: UInt32 {
    get {return _storage._transactionsSize}
    set {_uniqueStorage()._transactionsSize = newValue}
  }

  /// The hash of the block state after this block.
  var stateHash: Concordium_V2_StateHash {
    get {return _storage._stateHash ?? Concordium_V2_StateHash()}
    set {_uniqueStorage()._stateHash = newValue}
  }
  /// Returns true if `stateHash` has been explicitly set.
  var hasStateHash: Bool {return _storage._stateHash != nil}
  /// Clears the value of `stateHash`. Subsequent reads from it will return its default value.
  mutating func clearStateHash() {_uniqueStorage()._stateHash = nil}

  /// Protocol version to which the block belongs.
  var protocolVersion: Concordium_V2_ProtocolVersion {
    get {return _storage._protocolVersion}
    set {_uniqueStorage()._protocolVersion = newValue}
  }

  /// Block round. Present from protocol version 6.
  var round: Concordium_V2_Round {
    get {return _storage._round ?? Concordium_V2_Round()}
    set {_uniqueStorage()._round = newValue}
  }
  /// Returns true if `round` has been explicitly set.
  var hasRound: Bool {return _storage._round != nil}
  /// Clears the value of `round`. Subsequent reads from it will return its default value.
  mutating func clearRound() {_uniqueStorage()._round = nil}

  /// Block epoch. Present from protocol version 6.
  var epoch: Concordium_V2_Epoch {
    get {return _storage._epoch ?? Concordium_V2_Epoch()}
    set {_uniqueStorage()._epoch = newValue}
  }
  /// Returns true if `epoch` has been explicitly set.
  var hasEpoch: Bool {return _storage._epoch != nil}
  /// Clears the value of `epoch`. Subsequent reads from it will return its default value.
  mutating func clearEpoch() {_uniqueStorage()._epoch = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request for GetPoolInfo.
struct Concordium_V2_PoolInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Block in which to query the pool information.
  var blockHash: Concordium_V2_BlockHashInput {
    get {return _blockHash ?? Concordium_V2_BlockHashInput()}
    set {_blockHash = newValue}
  }
  /// Returns true if `blockHash` has been explicitly set.
  var hasBlockHash: Bool {return self._blockHash != nil}
  /// Clears the value of `blockHash`. Subsequent reads from it will return its default value.
  mutating func clearBlockHash() {self._blockHash = nil}

  /// The 'BakerId' of the pool owner.
  var baker: Concordium_V2_BakerId {
    get {return _baker ?? Concordium_V2_BakerId()}
    set {_baker = newValue}
  }
  /// Returns true if `baker` has been explicitly set.
  var hasBaker: Bool {return self._baker != nil}
  /// Clears the value of `baker`. Subsequent reads from it will return its default value.
  mutating func clearBaker() {self._baker = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockHash: Concordium_V2_BlockHashInput? = nil
  fileprivate var _baker: Concordium_V2_BakerId? = nil
}

/// A pending change to a baker pool.
struct Concordium_V2_PoolPendingChange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var change: Concordium_V2_PoolPendingChange.OneOf_Change? = nil

  var reduce: Concordium_V2_PoolPendingChange.Reduce {
    get {
      if case .reduce(let v)? = change {return v}
      return Concordium_V2_PoolPendingChange.Reduce()
    }
    set {change = .reduce(newValue)}
  }

  var remove: Concordium_V2_PoolPendingChange.Remove {
    get {
      if case .remove(let v)? = change {return v}
      return Concordium_V2_PoolPendingChange.Remove()
    }
    set {change = .remove(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Change: Equatable, Sendable {
    case reduce(Concordium_V2_PoolPendingChange.Reduce)
    case remove(Concordium_V2_PoolPendingChange.Remove)

  }

  /// A reduction in baker equity capital is pending.
  struct Reduce: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// New baker equity capital.
    var reducedEquityCapital: Concordium_V2_Amount {
      get {return _reducedEquityCapital ?? Concordium_V2_Amount()}
      set {_reducedEquityCapital = newValue}
    }
    /// Returns true if `reducedEquityCapital` has been explicitly set.
    var hasReducedEquityCapital: Bool {return self._reducedEquityCapital != nil}
    /// Clears the value of `reducedEquityCapital`. Subsequent reads from it will return its default value.
    mutating func clearReducedEquityCapital() {self._reducedEquityCapital = nil}

    /// Timestamp when the change takes effect.
    var effectiveTime: Concordium_V2_Timestamp {
      get {return _effectiveTime ?? Concordium_V2_Timestamp()}
      set {_effectiveTime = newValue}
    }
    /// Returns true if `effectiveTime` has been explicitly set.
    var hasEffectiveTime: Bool {return self._effectiveTime != nil}
    /// Clears the value of `effectiveTime`. Subsequent reads from it will return its default value.
    mutating func clearEffectiveTime() {self._effectiveTime = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _reducedEquityCapital: Concordium_V2_Amount? = nil
    fileprivate var _effectiveTime: Concordium_V2_Timestamp? = nil
  }

  /// Removal of the pool is pending.
  struct Remove: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Timestamp when the change takes effect.
    var effectiveTime: Concordium_V2_Timestamp {
      get {return _effectiveTime ?? Concordium_V2_Timestamp()}
      set {_effectiveTime = newValue}
    }
    /// Returns true if `effectiveTime` has been explicitly set.
    var hasEffectiveTime: Bool {return self._effectiveTime != nil}
    /// Clears the value of `effectiveTime`. Subsequent reads from it will return its default value.
    mutating func clearEffectiveTime() {self._effectiveTime = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _effectiveTime: Concordium_V2_Timestamp? = nil
  }

  init() {}
}

/// Information about a baker pool in the current reward period.
struct Concordium_V2_PoolCurrentPaydayInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of blocks baked in the current reward period.
  var blocksBaked: UInt64 = 0

  /// Whether the baker has contributed a finalization proof in the current reward period.
  var finalizationLive: Bool = false

  /// The transaction fees accruing to the pool in the current reward period.
  var transactionFeesEarned: Concordium_V2_Amount {
    get {return _transactionFeesEarned ?? Concordium_V2_Amount()}
    set {_transactionFeesEarned = newValue}
  }
  /// Returns true if `transactionFeesEarned` has been explicitly set.
  var hasTransactionFeesEarned: Bool {return self._transactionFeesEarned != nil}
  /// Clears the value of `transactionFeesEarned`. Subsequent reads from it will return its default value.
  mutating func clearTransactionFeesEarned() {self._transactionFeesEarned = nil}

  /// The effective stake of the baker in the current reward period.
  var effectiveStake: Concordium_V2_Amount {
    get {return _effectiveStake ?? Concordium_V2_Amount()}
    set {_effectiveStake = newValue}
  }
  /// Returns true if `effectiveStake` has been explicitly set.
  var hasEffectiveStake: Bool {return self._effectiveStake != nil}
  /// Clears the value of `effectiveStake`. Subsequent reads from it will return its default value.
  mutating func clearEffectiveStake() {self._effectiveStake = nil}

  /// The lottery power of the baker in the current reward period.
  var lotteryPower: Double = 0

  /// The effective equity capital of the baker for the current reward period.
  var bakerEquityCapital: Concordium_V2_Amount {
    get {return _bakerEquityCapital ?? Concordium_V2_Amount()}
    set {_bakerEquityCapital = newValue}
  }
  /// Returns true if `bakerEquityCapital` has been explicitly set.
  var hasBakerEquityCapital: Bool {return self._bakerEquityCapital != nil}
  /// Clears the value of `bakerEquityCapital`. Subsequent reads from it will return its default value.
  mutating func clearBakerEquityCapital() {self._bakerEquityCapital = nil}

  /// The effective delegated capital to the pool for the current reward period.
  var delegatedCapital: Concordium_V2_Amount {
    get {return _delegatedCapital ?? Concordium_V2_Amount()}
    set {_delegatedCapital = newValue}
  }
  /// Returns true if `delegatedCapital` has been explicitly set.
  var hasDelegatedCapital: Bool {return self._delegatedCapital != nil}
  /// Clears the value of `delegatedCapital`. Subsequent reads from it will return its default value.
  mutating func clearDelegatedCapital() {self._delegatedCapital = nil}

  /// The commission rates that apply for the current reward period.
  var commissionRates: Concordium_V2_CommissionRates {
    get {return _commissionRates ?? Concordium_V2_CommissionRates()}
    set {_commissionRates = newValue}
  }
  /// Returns true if `commissionRates` has been explicitly set.
  var hasCommissionRates: Bool {return self._commissionRates != nil}
  /// Clears the value of `commissionRates`. Subsequent reads from it will return its default value.
  mutating func clearCommissionRates() {self._commissionRates = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _transactionFeesEarned: Concordium_V2_Amount? = nil
  fileprivate var _effectiveStake: Concordium_V2_Amount? = nil
  fileprivate var _bakerEquityCapital: Concordium_V2_Amount? = nil
  fileprivate var _delegatedCapital: Concordium_V2_Amount? = nil
  fileprivate var _commissionRates: Concordium_V2_CommissionRates? = nil
}

/// Type for the response of GetPoolInfo.
/// Contains information about a given pool at the end of a given block.
/// From protocol version 7, pool removal has immediate effect, however, the
/// pool may still be present for the current (and possibly next) reward period.
/// In this case, the `current_payday_info` field will be set, but the
/// `equity_capital`, `delegated_capital`, `delegated_capital_cap` and,
/// `pool_info` fields will all be absent. The `equity_pending_change` field
/// will also be absent, as stake changes are immediate.
struct Concordium_V2_PoolInfoResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The 'BakerId' of the pool owner.
  var baker: Concordium_V2_BakerId {
    get {return _storage._baker ?? Concordium_V2_BakerId()}
    set {_uniqueStorage()._baker = newValue}
  }
  /// Returns true if `baker` has been explicitly set.
  var hasBaker: Bool {return _storage._baker != nil}
  /// Clears the value of `baker`. Subsequent reads from it will return its default value.
  mutating func clearBaker() {_uniqueStorage()._baker = nil}

  /// The account address of the pool owner.
  var address: Concordium_V2_AccountAddress {
    get {return _storage._address ?? Concordium_V2_AccountAddress()}
    set {_uniqueStorage()._address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return _storage._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {_uniqueStorage()._address = nil}

  /// The equity capital provided by the pool owner. Absent if the pool is removed.
  var equityCapital: Concordium_V2_Amount {
    get {return _storage._equityCapital ?? Concordium_V2_Amount()}
    set {_uniqueStorage()._equityCapital = newValue}
  }
  /// Returns true if `equityCapital` has been explicitly set.
  var hasEquityCapital: Bool {return _storage._equityCapital != nil}
  /// Clears the value of `equityCapital`. Subsequent reads from it will return its default value.
  mutating func clearEquityCapital() {_uniqueStorage()._equityCapital = nil}

  /// The capital delegated to the pool by other accounts. Absent if the pool is removed.
  var delegatedCapital: Concordium_V2_Amount {
    get {return _storage._delegatedCapital ?? Concordium_V2_Amount()}
    set {_uniqueStorage()._delegatedCapital = newValue}
  }
  /// Returns true if `delegatedCapital` has been explicitly set.
  var hasDelegatedCapital: Bool {return _storage._delegatedCapital != nil}
  /// Clears the value of `delegatedCapital`. Subsequent reads from it will return its default value.
  mutating func clearDelegatedCapital() {_uniqueStorage()._delegatedCapital = nil}

  /// The maximum amount that may be delegated to the pool, accounting for leverage and stake limits.
  /// Absent if the pool is removed.
  var delegatedCapitalCap: Concordium_V2_Amount {
    get {return _storage._delegatedCapitalCap ?? Concordium_V2_Amount()}
    set {_uniqueStorage()._delegatedCapitalCap = newValue}
  }
  /// Returns true if `delegatedCapitalCap` has been explicitly set.
  var hasDelegatedCapitalCap: Bool {return _storage._delegatedCapitalCap != nil}
  /// Clears the value of `delegatedCapitalCap`. Subsequent reads from it will return its default value.
  mutating func clearDelegatedCapitalCap() {_uniqueStorage()._delegatedCapitalCap = nil}

  /// The pool info associated with the pool: open status, metadata URL and commission rates.
  /// Absent if the pool is removed.
  var poolInfo: Concordium_V2_BakerPoolInfo {
    get {return _storage._poolInfo ?? Concordium_V2_BakerPoolInfo()}
    set {_uniqueStorage()._poolInfo = newValue}
  }
  /// Returns true if `poolInfo` has been explicitly set.
  var hasPoolInfo: Bool {return _storage._poolInfo != nil}
  /// Clears the value of `poolInfo`. Subsequent reads from it will return its default value.
  mutating func clearPoolInfo() {_uniqueStorage()._poolInfo = nil}

  /// Any pending change to the equity capital.
  /// This is not used from protocol version 7 onwards, as stake changes are immediate.
  var equityPendingChange: Concordium_V2_PoolPendingChange {
    get {return _storage._equityPendingChange ?? Concordium_V2_PoolPendingChange()}
    set {_uniqueStorage()._equityPendingChange = newValue}
  }
  /// Returns true if `equityPendingChange` has been explicitly set.
  var hasEquityPendingChange: Bool {return _storage._equityPendingChange != nil}
  /// Clears the value of `equityPendingChange`. Subsequent reads from it will return its default value.
  mutating func clearEquityPendingChange() {_uniqueStorage()._equityPendingChange = nil}

  /// Information of the pool in the current reward period.
  var currentPaydayInfo: Concordium_V2_PoolCurrentPaydayInfo {
    get {return _storage._currentPaydayInfo ?? Concordium_V2_PoolCurrentPaydayInfo()}
    set {_uniqueStorage()._currentPaydayInfo = newValue}
  }
  /// Returns true if `currentPaydayInfo` has been explicitly set.
  var hasCurrentPaydayInfo: Bool {return _storage._currentPaydayInfo != nil}
  /// Clears the value of `currentPaydayInfo`. Subsequent reads from it will return its default value.
  mutating func clearCurrentPaydayInfo() {_uniqueStorage()._currentPaydayInfo = nil}

  /// Total capital staked across all pools, including passive delegation.
  var allPoolTotalCapital: Concordium_V2_Amount {
    get {return _storage._allPoolTotalCapital ?? Concordium_V2_Amount()}
    set {_uniqueStorage()._allPoolTotalCapital = newValue}
  }
  /// Returns true if `allPoolTotalCapital` has been explicitly set.
  var hasAllPoolTotalCapital: Bool {return _storage._allPoolTotalCapital != nil}
  /// Clears the value of `allPoolTotalCapital`. Subsequent reads from it will return its default value.
  mutating func clearAllPoolTotalCapital() {_uniqueStorage()._allPoolTotalCapital = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Type for the response of GetPassiveDelegationInfo.
/// Contains information about passive delegators at the end of a given block.
struct Concordium_V2_PassiveDelegationInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The total capital delegated passively.
  var delegatedCapital: Concordium_V2_Amount {
    get {return _delegatedCapital ?? Concordium_V2_Amount()}
    set {_delegatedCapital = newValue}
  }
  /// Returns true if `delegatedCapital` has been explicitly set.
  var hasDelegatedCapital: Bool {return self._delegatedCapital != nil}
  /// Clears the value of `delegatedCapital`. Subsequent reads from it will return its default value.
  mutating func clearDelegatedCapital() {self._delegatedCapital = nil}

  /// The passive delegation commission rates.
  var commissionRates: Concordium_V2_CommissionRates {
    get {return _commissionRates ?? Concordium_V2_CommissionRates()}
    set {_commissionRates = newValue}
  }
  /// Returns true if `commissionRates` has been explicitly set.
  var hasCommissionRates: Bool {return self._commissionRates != nil}
  /// Clears the value of `commissionRates`. Subsequent reads from it will return its default value.
  mutating func clearCommissionRates() {self._commissionRates = nil}

  /// The transaction fees accruing to the passive delegators in the current reward period.
  var currentPaydayTransactionFeesEarned: Concordium_V2_Amount {
    get {return _currentPaydayTransactionFeesEarned ?? Concordium_V2_Amount()}
    set {_currentPaydayTransactionFeesEarned = newValue}
  }
  /// Returns true if `currentPaydayTransactionFeesEarned` has been explicitly set.
  var hasCurrentPaydayTransactionFeesEarned: Bool {return self._currentPaydayTransactionFeesEarned != nil}
  /// Clears the value of `currentPaydayTransactionFeesEarned`. Subsequent reads from it will return its default value.
  mutating func clearCurrentPaydayTransactionFeesEarned() {self._currentPaydayTransactionFeesEarned = nil}

  /// The effective delegated capital of passive delegators for the current reward period.
  var currentPaydayDelegatedCapital: Concordium_V2_Amount {
    get {return _currentPaydayDelegatedCapital ?? Concordium_V2_Amount()}
    set {_currentPaydayDelegatedCapital = newValue}
  }
  /// Returns true if `currentPaydayDelegatedCapital` has been explicitly set.
  var hasCurrentPaydayDelegatedCapital: Bool {return self._currentPaydayDelegatedCapital != nil}
  /// Clears the value of `currentPaydayDelegatedCapital`. Subsequent reads from it will return its default value.
  mutating func clearCurrentPaydayDelegatedCapital() {self._currentPaydayDelegatedCapital = nil}

  /// Total capital staked across all pools, including passive delegation.
  var allPoolTotalCapital: Concordium_V2_Amount {
    get {return _allPoolTotalCapital ?? Concordium_V2_Amount()}
    set {_allPoolTotalCapital = newValue}
  }
  /// Returns true if `allPoolTotalCapital` has been explicitly set.
  var hasAllPoolTotalCapital: Bool {return self._allPoolTotalCapital != nil}
  /// Clears the value of `allPoolTotalCapital`. Subsequent reads from it will return its default value.
  mutating func clearAllPoolTotalCapital() {self._allPoolTotalCapital = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _delegatedCapital: Concordium_V2_Amount? = nil
  fileprivate var _commissionRates: Concordium_V2_CommissionRates? = nil
  fileprivate var _currentPaydayTransactionFeesEarned: Concordium_V2_Amount? = nil
  fileprivate var _currentPaydayDelegatedCapital: Concordium_V2_Amount? = nil
  fileprivate var _allPoolTotalCapital: Concordium_V2_Amount? = nil
}

/// Request for GetBlocksAtHeight.
struct Concordium_V2_BlocksAtHeightRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blocksAtHeight: Concordium_V2_BlocksAtHeightRequest.OneOf_BlocksAtHeight? = nil

  var absolute: Concordium_V2_BlocksAtHeightRequest.Absolute {
    get {
      if case .absolute(let v)? = blocksAtHeight {return v}
      return Concordium_V2_BlocksAtHeightRequest.Absolute()
    }
    set {blocksAtHeight = .absolute(newValue)}
  }

  var relative: Concordium_V2_BlocksAtHeightRequest.Relative {
    get {
      if case .relative(let v)? = blocksAtHeight {return v}
      return Concordium_V2_BlocksAtHeightRequest.Relative()
    }
    set {blocksAtHeight = .relative(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_BlocksAtHeight: Equatable, Sendable {
    case absolute(Concordium_V2_BlocksAtHeightRequest.Absolute)
    case relative(Concordium_V2_BlocksAtHeightRequest.Relative)

  }

  /// Request using an absolute block height.
  struct Absolute: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The absolute block height.
    var height: Concordium_V2_AbsoluteBlockHeight {
      get {return _height ?? Concordium_V2_AbsoluteBlockHeight()}
      set {_height = newValue}
    }
    /// Returns true if `height` has been explicitly set.
    var hasHeight: Bool {return self._height != nil}
    /// Clears the value of `height`. Subsequent reads from it will return its default value.
    mutating func clearHeight() {self._height = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _height: Concordium_V2_AbsoluteBlockHeight? = nil
  }

  /// Request using a relative block height.
  struct Relative: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Genesis index to start from.
    var genesisIndex: Concordium_V2_GenesisIndex {
      get {return _genesisIndex ?? Concordium_V2_GenesisIndex()}
      set {_genesisIndex = newValue}
    }
    /// Returns true if `genesisIndex` has been explicitly set.
    var hasGenesisIndex: Bool {return self._genesisIndex != nil}
    /// Clears the value of `genesisIndex`. Subsequent reads from it will return its default value.
    mutating func clearGenesisIndex() {self._genesisIndex = nil}

    /// Height starting from the genesis block at the genesis index.
    var height: Concordium_V2_BlockHeight {
      get {return _height ?? Concordium_V2_BlockHeight()}
      set {_height = newValue}
    }
    /// Returns true if `height` has been explicitly set.
    var hasHeight: Bool {return self._height != nil}
    /// Clears the value of `height`. Subsequent reads from it will return its default value.
    mutating func clearHeight() {self._height = nil}

    /// Whether to return results only from the specified genesis index (`true`),
    /// or allow results from more recent genesis indices as well (`false`).
    var restrict: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _genesisIndex: Concordium_V2_GenesisIndex? = nil
    fileprivate var _height: Concordium_V2_BlockHeight? = nil
  }

  init() {}
}

/// Response for GetBlocksAtHeight.
struct Concordium_V2_BlocksAtHeightResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Live blocks at the given height.
  var blocks: [Concordium_V2_BlockHash] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Type for the response of GetTokenomicsInfo.
/// Contains information related to tokenomics at the end of a given block.
struct Concordium_V2_TokenomicsInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenomics: Concordium_V2_TokenomicsInfo.OneOf_Tokenomics? = nil

  var v0: Concordium_V2_TokenomicsInfo.V0 {
    get {
      if case .v0(let v)? = tokenomics {return v}
      return Concordium_V2_TokenomicsInfo.V0()
    }
    set {tokenomics = .v0(newValue)}
  }

  var v1: Concordium_V2_TokenomicsInfo.V1 {
    get {
      if case .v1(let v)? = tokenomics {return v}
      return Concordium_V2_TokenomicsInfo.V1()
    }
    set {tokenomics = .v1(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Tokenomics: Equatable, Sendable {
    case v0(Concordium_V2_TokenomicsInfo.V0)
    case v1(Concordium_V2_TokenomicsInfo.V1)

  }

  /// Version 0 tokenomics.
  struct V0: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The total CCD in existence.
    var totalAmount: Concordium_V2_Amount {
      get {return _totalAmount ?? Concordium_V2_Amount()}
      set {_totalAmount = newValue}
    }
    /// Returns true if `totalAmount` has been explicitly set.
    var hasTotalAmount: Bool {return self._totalAmount != nil}
    /// Clears the value of `totalAmount`. Subsequent reads from it will return its default value.
    mutating func clearTotalAmount() {self._totalAmount = nil}

    /// The total CCD in encrypted balances.
    var totalEncryptedAmount: Concordium_V2_Amount {
      get {return _totalEncryptedAmount ?? Concordium_V2_Amount()}
      set {_totalEncryptedAmount = newValue}
    }
    /// Returns true if `totalEncryptedAmount` has been explicitly set.
    var hasTotalEncryptedAmount: Bool {return self._totalEncryptedAmount != nil}
    /// Clears the value of `totalEncryptedAmount`. Subsequent reads from it will return its default value.
    mutating func clearTotalEncryptedAmount() {self._totalEncryptedAmount = nil}

    /// The amount in the baking reward account.
    var bakingRewardAccount: Concordium_V2_Amount {
      get {return _bakingRewardAccount ?? Concordium_V2_Amount()}
      set {_bakingRewardAccount = newValue}
    }
    /// Returns true if `bakingRewardAccount` has been explicitly set.
    var hasBakingRewardAccount: Bool {return self._bakingRewardAccount != nil}
    /// Clears the value of `bakingRewardAccount`. Subsequent reads from it will return its default value.
    mutating func clearBakingRewardAccount() {self._bakingRewardAccount = nil}

    /// The amount in the finalization reward account.
    var finalizationRewardAccount: Concordium_V2_Amount {
      get {return _finalizationRewardAccount ?? Concordium_V2_Amount()}
      set {_finalizationRewardAccount = newValue}
    }
    /// Returns true if `finalizationRewardAccount` has been explicitly set.
    var hasFinalizationRewardAccount: Bool {return self._finalizationRewardAccount != nil}
    /// Clears the value of `finalizationRewardAccount`. Subsequent reads from it will return its default value.
    mutating func clearFinalizationRewardAccount() {self._finalizationRewardAccount = nil}

    /// The amount in the GAS account.
    var gasAccount: Concordium_V2_Amount {
      get {return _gasAccount ?? Concordium_V2_Amount()}
      set {_gasAccount = newValue}
    }
    /// Returns true if `gasAccount` has been explicitly set.
    var hasGasAccount: Bool {return self._gasAccount != nil}
    /// Clears the value of `gasAccount`. Subsequent reads from it will return its default value.
    mutating func clearGasAccount() {self._gasAccount = nil}

    /// The protocol version.
    var protocolVersion: Concordium_V2_ProtocolVersion = .protocolVersion1

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _totalAmount: Concordium_V2_Amount? = nil
    fileprivate var _totalEncryptedAmount: Concordium_V2_Amount? = nil
    fileprivate var _bakingRewardAccount: Concordium_V2_Amount? = nil
    fileprivate var _finalizationRewardAccount: Concordium_V2_Amount? = nil
    fileprivate var _gasAccount: Concordium_V2_Amount? = nil
  }

  /// Version 1 tokenomics.
  struct V1: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The total CCD in existence.
    var totalAmount: Concordium_V2_Amount {
      get {return _totalAmount ?? Concordium_V2_Amount()}
      set {_totalAmount = newValue}
    }
    /// Returns true if `totalAmount` has been explicitly set.
    var hasTotalAmount: Bool {return self._totalAmount != nil}
    /// Clears the value of `totalAmount`. Subsequent reads from it will return its default value.
    mutating func clearTotalAmount() {self._totalAmount = nil}

    /// The total CCD in encrypted balances.
    var totalEncryptedAmount: Concordium_V2_Amount {
      get {return _totalEncryptedAmount ?? Concordium_V2_Amount()}
      set {_totalEncryptedAmount = newValue}
    }
    /// Returns true if `totalEncryptedAmount` has been explicitly set.
    var hasTotalEncryptedAmount: Bool {return self._totalEncryptedAmount != nil}
    /// Clears the value of `totalEncryptedAmount`. Subsequent reads from it will return its default value.
    mutating func clearTotalEncryptedAmount() {self._totalEncryptedAmount = nil}

    /// The amount in the baking reward account.
    var bakingRewardAccount: Concordium_V2_Amount {
      get {return _bakingRewardAccount ?? Concordium_V2_Amount()}
      set {_bakingRewardAccount = newValue}
    }
    /// Returns true if `bakingRewardAccount` has been explicitly set.
    var hasBakingRewardAccount: Bool {return self._bakingRewardAccount != nil}
    /// Clears the value of `bakingRewardAccount`. Subsequent reads from it will return its default value.
    mutating func clearBakingRewardAccount() {self._bakingRewardAccount = nil}

    /// The amount in the finalization reward account.
    var finalizationRewardAccount: Concordium_V2_Amount {
      get {return _finalizationRewardAccount ?? Concordium_V2_Amount()}
      set {_finalizationRewardAccount = newValue}
    }
    /// Returns true if `finalizationRewardAccount` has been explicitly set.
    var hasFinalizationRewardAccount: Bool {return self._finalizationRewardAccount != nil}
    /// Clears the value of `finalizationRewardAccount`. Subsequent reads from it will return its default value.
    mutating func clearFinalizationRewardAccount() {self._finalizationRewardAccount = nil}

    /// The amount in the GAS account.
    var gasAccount: Concordium_V2_Amount {
      get {return _gasAccount ?? Concordium_V2_Amount()}
      set {_gasAccount = newValue}
    }
    /// Returns true if `gasAccount` has been explicitly set.
    var hasGasAccount: Bool {return self._gasAccount != nil}
    /// Clears the value of `gasAccount`. Subsequent reads from it will return its default value.
    mutating func clearGasAccount() {self._gasAccount = nil}

    /// The transaction reward fraction accruing to the foundation (to be paid at next payday).
    var foundationTransactionRewards: Concordium_V2_Amount {
      get {return _foundationTransactionRewards ?? Concordium_V2_Amount()}
      set {_foundationTransactionRewards = newValue}
    }
    /// Returns true if `foundationTransactionRewards` has been explicitly set.
    var hasFoundationTransactionRewards: Bool {return self._foundationTransactionRewards != nil}
    /// Clears the value of `foundationTransactionRewards`. Subsequent reads from it will return its default value.
    mutating func clearFoundationTransactionRewards() {self._foundationTransactionRewards = nil}

    /// The time of the next payday.
    var nextPaydayTime: Concordium_V2_Timestamp {
      get {return _nextPaydayTime ?? Concordium_V2_Timestamp()}
      set {_nextPaydayTime = newValue}
    }
    /// Returns true if `nextPaydayTime` has been explicitly set.
    var hasNextPaydayTime: Bool {return self._nextPaydayTime != nil}
    /// Clears the value of `nextPaydayTime`. Subsequent reads from it will return its default value.
    mutating func clearNextPaydayTime() {self._nextPaydayTime = nil}

    /// The rate at which CCD will be minted (as a proportion of the total supply) at the next payday.
    var nextPaydayMintRate: Concordium_V2_MintRate {
      get {return _nextPaydayMintRate ?? Concordium_V2_MintRate()}
      set {_nextPaydayMintRate = newValue}
    }
    /// Returns true if `nextPaydayMintRate` has been explicitly set.
    var hasNextPaydayMintRate: Bool {return self._nextPaydayMintRate != nil}
    /// Clears the value of `nextPaydayMintRate`. Subsequent reads from it will return its default value.
    mutating func clearNextPaydayMintRate() {self._nextPaydayMintRate = nil}

    /// The total capital put up as stake by bakers and delegators.
    var totalStakedCapital: Concordium_V2_Amount {
      get {return _totalStakedCapital ?? Concordium_V2_Amount()}
      set {_totalStakedCapital = newValue}
    }
    /// Returns true if `totalStakedCapital` has been explicitly set.
    var hasTotalStakedCapital: Bool {return self._totalStakedCapital != nil}
    /// Clears the value of `totalStakedCapital`. Subsequent reads from it will return its default value.
    mutating func clearTotalStakedCapital() {self._totalStakedCapital = nil}

    /// The protocol version.
    var protocolVersion: Concordium_V2_ProtocolVersion = .protocolVersion1

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _totalAmount: Concordium_V2_Amount? = nil
    fileprivate var _totalEncryptedAmount: Concordium_V2_Amount? = nil
    fileprivate var _bakingRewardAccount: Concordium_V2_Amount? = nil
    fileprivate var _finalizationRewardAccount: Concordium_V2_Amount? = nil
    fileprivate var _gasAccount: Concordium_V2_Amount? = nil
    fileprivate var _foundationTransactionRewards: Concordium_V2_Amount? = nil
    fileprivate var _nextPaydayTime: Concordium_V2_Timestamp? = nil
    fileprivate var _nextPaydayMintRate: Concordium_V2_MintRate? = nil
    fileprivate var _totalStakedCapital: Concordium_V2_Amount? = nil
  }

  init() {}
}

/// Request for InvokeInstance.
struct Concordium_V2_InvokeInstanceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Block to invoke the contract. The invocation will be at the end of the given block.
  var blockHash: Concordium_V2_BlockHashInput {
    get {return _blockHash ?? Concordium_V2_BlockHashInput()}
    set {_blockHash = newValue}
  }
  /// Returns true if `blockHash` has been explicitly set.
  var hasBlockHash: Bool {return self._blockHash != nil}
  /// Clears the value of `blockHash`. Subsequent reads from it will return its default value.
  mutating func clearBlockHash() {self._blockHash = nil}

  /// Invoker of the contract. If this is not supplied then the contract will be
  /// invoked by an account with address 0, no credentials and sufficient amount
  /// of CCD to cover the transfer amount. If given, the relevant address (either
  /// account or contract) must exist in the blockstate.
  var invoker: Concordium_V2_Address {
    get {return _invoker ?? Concordium_V2_Address()}
    set {_invoker = newValue}
  }
  /// Returns true if `invoker` has been explicitly set.
  var hasInvoker: Bool {return self._invoker != nil}
  /// Clears the value of `invoker`. Subsequent reads from it will return its default value.
  mutating func clearInvoker() {self._invoker = nil}

  /// Address of the contract instance to invoke.
  var instance: Concordium_V2_ContractAddress {
    get {return _instance ?? Concordium_V2_ContractAddress()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  mutating func clearInstance() {self._instance = nil}

  /// Amount to invoke the smart contract instance with.
  var amount: Concordium_V2_Amount {
    get {return _amount ?? Concordium_V2_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  /// The entrypoint of the smart contract instance to invoke.
  var entrypoint: Concordium_V2_ReceiveName {
    get {return _entrypoint ?? Concordium_V2_ReceiveName()}
    set {_entrypoint = newValue}
  }
  /// Returns true if `entrypoint` has been explicitly set.
  var hasEntrypoint: Bool {return self._entrypoint != nil}
  /// Clears the value of `entrypoint`. Subsequent reads from it will return its default value.
  mutating func clearEntrypoint() {self._entrypoint = nil}

  /// The parameter bytes to include in the invocation of the entrypoint.
  var parameter: Concordium_V2_Parameter {
    get {return _parameter ?? Concordium_V2_Parameter()}
    set {_parameter = newValue}
  }
  /// Returns true if `parameter` has been explicitly set.
  var hasParameter: Bool {return self._parameter != nil}
  /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
  mutating func clearParameter() {self._parameter = nil}

  /// And what amount of energy to allow for execution. This cannot exceed
  /// `100_000_000_000`, but in practice it should be much less. The maximum
  /// block energy is typically in the range of a few million.
  var energy: Concordium_V2_Energy {
    get {return _energy ?? Concordium_V2_Energy()}
    set {_energy = newValue}
  }
  /// Returns true if `energy` has been explicitly set.
  var hasEnergy: Bool {return self._energy != nil}
  /// Clears the value of `energy`. Subsequent reads from it will return its default value.
  mutating func clearEnergy() {self._energy = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockHash: Concordium_V2_BlockHashInput? = nil
  fileprivate var _invoker: Concordium_V2_Address? = nil
  fileprivate var _instance: Concordium_V2_ContractAddress? = nil
  fileprivate var _amount: Concordium_V2_Amount? = nil
  fileprivate var _entrypoint: Concordium_V2_ReceiveName? = nil
  fileprivate var _parameter: Concordium_V2_Parameter? = nil
  fileprivate var _energy: Concordium_V2_Energy? = nil
}

/// Response type for InvokeInstance.
struct Concordium_V2_InvokeInstanceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Concordium_V2_InvokeInstanceResponse.OneOf_Result? = nil

  var success: Concordium_V2_InvokeInstanceResponse.Success {
    get {
      if case .success(let v)? = result {return v}
      return Concordium_V2_InvokeInstanceResponse.Success()
    }
    set {result = .success(newValue)}
  }

  var failure: Concordium_V2_InvokeInstanceResponse.Failure {
    get {
      if case .failure(let v)? = result {return v}
      return Concordium_V2_InvokeInstanceResponse.Failure()
    }
    set {result = .failure(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable, Sendable {
    case success(Concordium_V2_InvokeInstanceResponse.Success)
    case failure(Concordium_V2_InvokeInstanceResponse.Failure)

  }

  /// Contract execution failed.
  struct Failure: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If invoking a V0 contract this is not provided, otherwise it is
    /// potentially return value produced by the call unless the call failed with
    /// out of energy or runtime error. If the V1 contract terminated with a
    /// logic error then the return value is present.
    var returnValue: Data {
      get {return _returnValue ?? Data()}
      set {_returnValue = newValue}
    }
    /// Returns true if `returnValue` has been explicitly set.
    var hasReturnValue: Bool {return self._returnValue != nil}
    /// Clears the value of `returnValue`. Subsequent reads from it will return its default value.
    mutating func clearReturnValue() {self._returnValue = nil}

    /// Energy used by the execution.
    var usedEnergy: Concordium_V2_Energy {
      get {return _usedEnergy ?? Concordium_V2_Energy()}
      set {_usedEnergy = newValue}
    }
    /// Returns true if `usedEnergy` has been explicitly set.
    var hasUsedEnergy: Bool {return self._usedEnergy != nil}
    /// Clears the value of `usedEnergy`. Subsequent reads from it will return its default value.
    mutating func clearUsedEnergy() {self._usedEnergy = nil}

    /// Contract execution failed for the given reason.
    var reason: Concordium_V2_RejectReason {
      get {return _reason ?? Concordium_V2_RejectReason()}
      set {_reason = newValue}
    }
    /// Returns true if `reason` has been explicitly set.
    var hasReason: Bool {return self._reason != nil}
    /// Clears the value of `reason`. Subsequent reads from it will return its default value.
    mutating func clearReason() {self._reason = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _returnValue: Data? = nil
    fileprivate var _usedEnergy: Concordium_V2_Energy? = nil
    fileprivate var _reason: Concordium_V2_RejectReason? = nil
  }

  /// Contract execution succeeded.
  struct Success: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If invoking a V0 contract this is absent. Otherwise it is the return
    /// value produced by the contract.
    var returnValue: Data {
      get {return _returnValue ?? Data()}
      set {_returnValue = newValue}
    }
    /// Returns true if `returnValue` has been explicitly set.
    var hasReturnValue: Bool {return self._returnValue != nil}
    /// Clears the value of `returnValue`. Subsequent reads from it will return its default value.
    mutating func clearReturnValue() {self._returnValue = nil}

    /// Energy used by the execution.
    var usedEnergy: Concordium_V2_Energy {
      get {return _usedEnergy ?? Concordium_V2_Energy()}
      set {_usedEnergy = newValue}
    }
    /// Returns true if `usedEnergy` has been explicitly set.
    var hasUsedEnergy: Bool {return self._usedEnergy != nil}
    /// Clears the value of `usedEnergy`. Subsequent reads from it will return its default value.
    mutating func clearUsedEnergy() {self._usedEnergy = nil}

    /// Effects produced by contract execution.
    var effects: [Concordium_V2_ContractTraceElement] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _returnValue: Data? = nil
    fileprivate var _usedEnergy: Concordium_V2_Energy? = nil
  }

  init() {}
}

/// Request for GetPoolDelegators and GetPoolDelegatorsRewardPeriod.
struct Concordium_V2_GetPoolDelegatorsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Block in which to query the delegators.
  var blockHash: Concordium_V2_BlockHashInput {
    get {return _blockHash ?? Concordium_V2_BlockHashInput()}
    set {_blockHash = newValue}
  }
  /// Returns true if `blockHash` has been explicitly set.
  var hasBlockHash: Bool {return self._blockHash != nil}
  /// Clears the value of `blockHash`. Subsequent reads from it will return its default value.
  mutating func clearBlockHash() {self._blockHash = nil}

  /// The 'BakerId' of the pool owner.
  var baker: Concordium_V2_BakerId {
    get {return _baker ?? Concordium_V2_BakerId()}
    set {_baker = newValue}
  }
  /// Returns true if `baker` has been explicitly set.
  var hasBaker: Bool {return self._baker != nil}
  /// Clears the value of `baker`. Subsequent reads from it will return its default value.
  mutating func clearBaker() {self._baker = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockHash: Concordium_V2_BlockHashInput? = nil
  fileprivate var _baker: Concordium_V2_BakerId? = nil
}

/// Stream item for GetPoolDelegators and GetPassiveDelegators.
struct Concordium_V2_DelegatorInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The delegator account address.
  var account: Concordium_V2_AccountAddress {
    get {return _account ?? Concordium_V2_AccountAddress()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  /// The amount of stake currently staked to the pool.
  var stake: Concordium_V2_Amount {
    get {return _stake ?? Concordium_V2_Amount()}
    set {_stake = newValue}
  }
  /// Returns true if `stake` has been explicitly set.
  var hasStake: Bool {return self._stake != nil}
  /// Clears the value of `stake`. Subsequent reads from it will return its default value.
  mutating func clearStake() {self._stake = nil}

  /// Pending change to the current stake of the delegator.
  var pendingChange: Concordium_V2_StakePendingChange {
    get {return _pendingChange ?? Concordium_V2_StakePendingChange()}
    set {_pendingChange = newValue}
  }
  /// Returns true if `pendingChange` has been explicitly set.
  var hasPendingChange: Bool {return self._pendingChange != nil}
  /// Clears the value of `pendingChange`. Subsequent reads from it will return its default value.
  mutating func clearPendingChange() {self._pendingChange = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: Concordium_V2_AccountAddress? = nil
  fileprivate var _stake: Concordium_V2_Amount? = nil
  fileprivate var _pendingChange: Concordium_V2_StakePendingChange? = nil
}

/// Stream item for GetPoolDelegatorsRewardPeriod and GetPassiveDelegatorsRewardPeriod.
struct Concordium_V2_DelegatorRewardPeriodInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The delegator account address.
  var account: Concordium_V2_AccountAddress {
    get {return _account ?? Concordium_V2_AccountAddress()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  /// The amount of stake currently staked to the pool.
  var stake: Concordium_V2_Amount {
    get {return _stake ?? Concordium_V2_Amount()}
    set {_stake = newValue}
  }
  /// Returns true if `stake` has been explicitly set.
  var hasStake: Bool {return self._stake != nil}
  /// Clears the value of `stake`. Subsequent reads from it will return its default value.
  mutating func clearStake() {self._stake = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: Concordium_V2_AccountAddress? = nil
  fileprivate var _stake: Concordium_V2_Amount? = nil
}

/// Response type for GetBranches.
struct Concordium_V2_Branch: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hash of the block.
  var blockHash: Concordium_V2_BlockHash {
    get {return _blockHash ?? Concordium_V2_BlockHash()}
    set {_blockHash = newValue}
  }
  /// Returns true if `blockHash` has been explicitly set.
  var hasBlockHash: Bool {return self._blockHash != nil}
  /// Clears the value of `blockHash`. Subsequent reads from it will return its default value.
  mutating func clearBlockHash() {self._blockHash = nil}

  /// Further blocks branching of this block.
  var children: [Concordium_V2_Branch] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockHash: Concordium_V2_BlockHash? = nil
}

/// The leadership election nonce is an unpredictable value updated once an
/// epoch to make sure that bakers cannot predict too far in the future when
/// they will win the right to bake blocks.
struct Concordium_V2_LeadershipElectionNonce: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response type for GetElectionInfo.
/// Contains information related to baker election for a perticular block.
struct Concordium_V2_ElectionInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Baking lottery election difficulty. Present only in protocol versions 1-5.
  var electionDifficulty: Concordium_V2_ElectionDifficulty {
    get {return _electionDifficulty ?? Concordium_V2_ElectionDifficulty()}
    set {_electionDifficulty = newValue}
  }
  /// Returns true if `electionDifficulty` has been explicitly set.
  var hasElectionDifficulty: Bool {return self._electionDifficulty != nil}
  /// Clears the value of `electionDifficulty`. Subsequent reads from it will return its default value.
  mutating func clearElectionDifficulty() {self._electionDifficulty = nil}

  /// Current leadership election nonce for the lottery.
  var electionNonce: Concordium_V2_LeadershipElectionNonce {
    get {return _electionNonce ?? Concordium_V2_LeadershipElectionNonce()}
    set {_electionNonce = newValue}
  }
  /// Returns true if `electionNonce` has been explicitly set.
  var hasElectionNonce: Bool {return self._electionNonce != nil}
  /// Clears the value of `electionNonce`. Subsequent reads from it will return its default value.
  mutating func clearElectionNonce() {self._electionNonce = nil}

  /// List of the currently eligible bakers.
  var bakerElectionInfo: [Concordium_V2_ElectionInfo.Baker] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Baker: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID of the baker.
    var baker: Concordium_V2_BakerId {
      get {return _baker ?? Concordium_V2_BakerId()}
      set {_baker = newValue}
    }
    /// Returns true if `baker` has been explicitly set.
    var hasBaker: Bool {return self._baker != nil}
    /// Clears the value of `baker`. Subsequent reads from it will return its default value.
    mutating func clearBaker() {self._baker = nil}

    /// The account address of the baker.
    var account: Concordium_V2_AccountAddress {
      get {return _account ?? Concordium_V2_AccountAddress()}
      set {_account = newValue}
    }
    /// Returns true if `account` has been explicitly set.
    var hasAccount: Bool {return self._account != nil}
    /// Clears the value of `account`. Subsequent reads from it will return its default value.
    mutating func clearAccount() {self._account = nil}

    /// The lottery power of the baker, rounded to the nearest representable "double".
    var lotteryPower: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _baker: Concordium_V2_BakerId? = nil
    fileprivate var _account: Concordium_V2_AccountAddress? = nil
  }

  init() {}

  fileprivate var _electionDifficulty: Concordium_V2_ElectionDifficulty? = nil
  fileprivate var _electionNonce: Concordium_V2_LeadershipElectionNonce? = nil
}

/// A protocol generated event that is not directly caused by a transaction. This
/// includes minting new CCD, rewarding different bakers and delegators, etc.
struct Concordium_V2_BlockSpecialEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: Concordium_V2_BlockSpecialEvent.OneOf_Event? = nil

  var bakingRewards: Concordium_V2_BlockSpecialEvent.BakingRewards {
    get {
      if case .bakingRewards(let v)? = event {return v}
      return Concordium_V2_BlockSpecialEvent.BakingRewards()
    }
    set {event = .bakingRewards(newValue)}
  }

  var mint: Concordium_V2_BlockSpecialEvent.Mint {
    get {
      if case .mint(let v)? = event {return v}
      return Concordium_V2_BlockSpecialEvent.Mint()
    }
    set {event = .mint(newValue)}
  }

  var finalizationRewards: Concordium_V2_BlockSpecialEvent.FinalizationRewards {
    get {
      if case .finalizationRewards(let v)? = event {return v}
      return Concordium_V2_BlockSpecialEvent.FinalizationRewards()
    }
    set {event = .finalizationRewards(newValue)}
  }

  var blockReward: Concordium_V2_BlockSpecialEvent.BlockReward {
    get {
      if case .blockReward(let v)? = event {return v}
      return Concordium_V2_BlockSpecialEvent.BlockReward()
    }
    set {event = .blockReward(newValue)}
  }

  var paydayFoundationReward: Concordium_V2_BlockSpecialEvent.PaydayFoundationReward {
    get {
      if case .paydayFoundationReward(let v)? = event {return v}
      return Concordium_V2_BlockSpecialEvent.PaydayFoundationReward()
    }
    set {event = .paydayFoundationReward(newValue)}
  }

  var paydayAccountReward: Concordium_V2_BlockSpecialEvent.PaydayAccountReward {
    get {
      if case .paydayAccountReward(let v)? = event {return v}
      return Concordium_V2_BlockSpecialEvent.PaydayAccountReward()
    }
    set {event = .paydayAccountReward(newValue)}
  }

  var blockAccrueReward: Concordium_V2_BlockSpecialEvent.BlockAccrueReward {
    get {
      if case .blockAccrueReward(let v)? = event {return v}
      return Concordium_V2_BlockSpecialEvent.BlockAccrueReward()
    }
    set {event = .blockAccrueReward(newValue)}
  }

  var paydayPoolReward: Concordium_V2_BlockSpecialEvent.PaydayPoolReward {
    get {
      if case .paydayPoolReward(let v)? = event {return v}
      return Concordium_V2_BlockSpecialEvent.PaydayPoolReward()
    }
    set {event = .paydayPoolReward(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable, Sendable {
    case bakingRewards(Concordium_V2_BlockSpecialEvent.BakingRewards)
    case mint(Concordium_V2_BlockSpecialEvent.Mint)
    case finalizationRewards(Concordium_V2_BlockSpecialEvent.FinalizationRewards)
    case blockReward(Concordium_V2_BlockSpecialEvent.BlockReward)
    case paydayFoundationReward(Concordium_V2_BlockSpecialEvent.PaydayFoundationReward)
    case paydayAccountReward(Concordium_V2_BlockSpecialEvent.PaydayAccountReward)
    case blockAccrueReward(Concordium_V2_BlockSpecialEvent.BlockAccrueReward)
    case paydayPoolReward(Concordium_V2_BlockSpecialEvent.PaydayPoolReward)

  }

  /// A representation of a mapping from an account address to an amount.
  struct AccountAmounts: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var entries: [Concordium_V2_BlockSpecialEvent.AccountAmounts.Entry] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The entry for the map.
    struct Entry: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The key type
      var account: Concordium_V2_AccountAddress {
        get {return _account ?? Concordium_V2_AccountAddress()}
        set {_account = newValue}
      }
      /// Returns true if `account` has been explicitly set.
      var hasAccount: Bool {return self._account != nil}
      /// Clears the value of `account`. Subsequent reads from it will return its default value.
      mutating func clearAccount() {self._account = nil}

      /// The value type
      var amount: Concordium_V2_Amount {
        get {return _amount ?? Concordium_V2_Amount()}
        set {_amount = newValue}
      }
      /// Returns true if `amount` has been explicitly set.
      var hasAmount: Bool {return self._amount != nil}
      /// Clears the value of `amount`. Subsequent reads from it will return its default value.
      mutating func clearAmount() {self._amount = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _account: Concordium_V2_AccountAddress? = nil
      fileprivate var _amount: Concordium_V2_Amount? = nil
    }

    init() {}
  }

  /// Payment to each baker of a previous epoch, in proportion to the number
  /// of blocks they contributed.
  struct BakingRewards: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The amount awarded to each baker.
    var bakerRewards: Concordium_V2_BlockSpecialEvent.AccountAmounts {
      get {return _bakerRewards ?? Concordium_V2_BlockSpecialEvent.AccountAmounts()}
      set {_bakerRewards = newValue}
    }
    /// Returns true if `bakerRewards` has been explicitly set.
    var hasBakerRewards: Bool {return self._bakerRewards != nil}
    /// Clears the value of `bakerRewards`. Subsequent reads from it will return its default value.
    mutating func clearBakerRewards() {self._bakerRewards = nil}

    /// The remaining balance of the baker reward account.
    var remainder: Concordium_V2_Amount {
      get {return _remainder ?? Concordium_V2_Amount()}
      set {_remainder = newValue}
    }
    /// Returns true if `remainder` has been explicitly set.
    var hasRemainder: Bool {return self._remainder != nil}
    /// Clears the value of `remainder`. Subsequent reads from it will return its default value.
    mutating func clearRemainder() {self._remainder = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bakerRewards: Concordium_V2_BlockSpecialEvent.AccountAmounts? = nil
    fileprivate var _remainder: Concordium_V2_Amount? = nil
  }

  /// Minting of new CCD.
  struct Mint: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The amount allocated to the banking reward account.
    var mintBakingReward: Concordium_V2_Amount {
      get {return _mintBakingReward ?? Concordium_V2_Amount()}
      set {_mintBakingReward = newValue}
    }
    /// Returns true if `mintBakingReward` has been explicitly set.
    var hasMintBakingReward: Bool {return self._mintBakingReward != nil}
    /// Clears the value of `mintBakingReward`. Subsequent reads from it will return its default value.
    mutating func clearMintBakingReward() {self._mintBakingReward = nil}

    /// The amount allocated to the finalization reward account.
    var mintFinalizationReward: Concordium_V2_Amount {
      get {return _mintFinalizationReward ?? Concordium_V2_Amount()}
      set {_mintFinalizationReward = newValue}
    }
    /// Returns true if `mintFinalizationReward` has been explicitly set.
    var hasMintFinalizationReward: Bool {return self._mintFinalizationReward != nil}
    /// Clears the value of `mintFinalizationReward`. Subsequent reads from it will return its default value.
    mutating func clearMintFinalizationReward() {self._mintFinalizationReward = nil}

    /// The amount allocated as the platform development charge.
    var mintPlatformDevelopmentCharge: Concordium_V2_Amount {
      get {return _mintPlatformDevelopmentCharge ?? Concordium_V2_Amount()}
      set {_mintPlatformDevelopmentCharge = newValue}
    }
    /// Returns true if `mintPlatformDevelopmentCharge` has been explicitly set.
    var hasMintPlatformDevelopmentCharge: Bool {return self._mintPlatformDevelopmentCharge != nil}
    /// Clears the value of `mintPlatformDevelopmentCharge`. Subsequent reads from it will return its default value.
    mutating func clearMintPlatformDevelopmentCharge() {self._mintPlatformDevelopmentCharge = nil}

    /// The account to which the platform development charge is paid.
    var foundationAccount: Concordium_V2_AccountAddress {
      get {return _foundationAccount ?? Concordium_V2_AccountAddress()}
      set {_foundationAccount = newValue}
    }
    /// Returns true if `foundationAccount` has been explicitly set.
    var hasFoundationAccount: Bool {return self._foundationAccount != nil}
    /// Clears the value of `foundationAccount`. Subsequent reads from it will return its default value.
    mutating func clearFoundationAccount() {self._foundationAccount = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _mintBakingReward: Concordium_V2_Amount? = nil
    fileprivate var _mintFinalizationReward: Concordium_V2_Amount? = nil
    fileprivate var _mintPlatformDevelopmentCharge: Concordium_V2_Amount? = nil
    fileprivate var _foundationAccount: Concordium_V2_AccountAddress? = nil
  }

  /// Payment to each finalizer on inclusion of a finalization record in a block.
  struct FinalizationRewards: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The amount awarded to each finalizer.
    var finalizationRewards: Concordium_V2_BlockSpecialEvent.AccountAmounts {
      get {return _finalizationRewards ?? Concordium_V2_BlockSpecialEvent.AccountAmounts()}
      set {_finalizationRewards = newValue}
    }
    /// Returns true if `finalizationRewards` has been explicitly set.
    var hasFinalizationRewards: Bool {return self._finalizationRewards != nil}
    /// Clears the value of `finalizationRewards`. Subsequent reads from it will return its default value.
    mutating func clearFinalizationRewards() {self._finalizationRewards = nil}

    /// The remaining balance of the finalization reward account.
    var remainder: Concordium_V2_Amount {
      get {return _remainder ?? Concordium_V2_Amount()}
      set {_remainder = newValue}
    }
    /// Returns true if `remainder` has been explicitly set.
    var hasRemainder: Bool {return self._remainder != nil}
    /// Clears the value of `remainder`. Subsequent reads from it will return its default value.
    mutating func clearRemainder() {self._remainder = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _finalizationRewards: Concordium_V2_BlockSpecialEvent.AccountAmounts? = nil
    fileprivate var _remainder: Concordium_V2_Amount? = nil
  }

  /// Disbursement of fees from a block between the GAS account,
  /// the baker, and the foundation. It should always be that:
  ///
  /// ```transaction_fees + old_gas_account = new_gas_account + baker_reward + foundation_charge```
  struct BlockReward: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The total fees paid for transactions in the block.
    var transactionFees: Concordium_V2_Amount {
      get {return _transactionFees ?? Concordium_V2_Amount()}
      set {_transactionFees = newValue}
    }
    /// Returns true if `transactionFees` has been explicitly set.
    var hasTransactionFees: Bool {return self._transactionFees != nil}
    /// Clears the value of `transactionFees`. Subsequent reads from it will return its default value.
    mutating func clearTransactionFees() {self._transactionFees = nil}

    /// The old balance of the GAS account.
    var oldGasAccount: Concordium_V2_Amount {
      get {return _oldGasAccount ?? Concordium_V2_Amount()}
      set {_oldGasAccount = newValue}
    }
    /// Returns true if `oldGasAccount` has been explicitly set.
    var hasOldGasAccount: Bool {return self._oldGasAccount != nil}
    /// Clears the value of `oldGasAccount`. Subsequent reads from it will return its default value.
    mutating func clearOldGasAccount() {self._oldGasAccount = nil}

    /// The new balance of the GAS account.
    var newGasAccount: Concordium_V2_Amount {
      get {return _newGasAccount ?? Concordium_V2_Amount()}
      set {_newGasAccount = newValue}
    }
    /// Returns true if `newGasAccount` has been explicitly set.
    var hasNewGasAccount: Bool {return self._newGasAccount != nil}
    /// Clears the value of `newGasAccount`. Subsequent reads from it will return its default value.
    mutating func clearNewGasAccount() {self._newGasAccount = nil}

    /// The amount awarded to the baker.
    var bakerReward: Concordium_V2_Amount {
      get {return _bakerReward ?? Concordium_V2_Amount()}
      set {_bakerReward = newValue}
    }
    /// Returns true if `bakerReward` has been explicitly set.
    var hasBakerReward: Bool {return self._bakerReward != nil}
    /// Clears the value of `bakerReward`. Subsequent reads from it will return its default value.
    mutating func clearBakerReward() {self._bakerReward = nil}

    /// The amount awarded to the foundation.
    var foundationCharge: Concordium_V2_Amount {
      get {return _foundationCharge ?? Concordium_V2_Amount()}
      set {_foundationCharge = newValue}
    }
    /// Returns true if `foundationCharge` has been explicitly set.
    var hasFoundationCharge: Bool {return self._foundationCharge != nil}
    /// Clears the value of `foundationCharge`. Subsequent reads from it will return its default value.
    mutating func clearFoundationCharge() {self._foundationCharge = nil}

    /// The baker of the block, who receives the award.
    var baker: Concordium_V2_AccountAddress {
      get {return _baker ?? Concordium_V2_AccountAddress()}
      set {_baker = newValue}
    }
    /// Returns true if `baker` has been explicitly set.
    var hasBaker: Bool {return self._baker != nil}
    /// Clears the value of `baker`. Subsequent reads from it will return its default value.
    mutating func clearBaker() {self._baker = nil}

    /// The foundation account.
    var foundationAccount: Concordium_V2_AccountAddress {
      get {return _foundationAccount ?? Concordium_V2_AccountAddress()}
      set {_foundationAccount = newValue}
    }
    /// Returns true if `foundationAccount` has been explicitly set.
    var hasFoundationAccount: Bool {return self._foundationAccount != nil}
    /// Clears the value of `foundationAccount`. Subsequent reads from it will return its default value.
    mutating func clearFoundationAccount() {self._foundationAccount = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _transactionFees: Concordium_V2_Amount? = nil
    fileprivate var _oldGasAccount: Concordium_V2_Amount? = nil
    fileprivate var _newGasAccount: Concordium_V2_Amount? = nil
    fileprivate var _bakerReward: Concordium_V2_Amount? = nil
    fileprivate var _foundationCharge: Concordium_V2_Amount? = nil
    fileprivate var _baker: Concordium_V2_AccountAddress? = nil
    fileprivate var _foundationAccount: Concordium_V2_AccountAddress? = nil
  }

  /// Foundation tax.
  struct PaydayFoundationReward: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The account that got rewarded.
    var foundationAccount: Concordium_V2_AccountAddress {
      get {return _foundationAccount ?? Concordium_V2_AccountAddress()}
      set {_foundationAccount = newValue}
    }
    /// Returns true if `foundationAccount` has been explicitly set.
    var hasFoundationAccount: Bool {return self._foundationAccount != nil}
    /// Clears the value of `foundationAccount`. Subsequent reads from it will return its default value.
    mutating func clearFoundationAccount() {self._foundationAccount = nil}

    /// The transaction fee reward at payday to the account.
    var developmentCharge: Concordium_V2_Amount {
      get {return _developmentCharge ?? Concordium_V2_Amount()}
      set {_developmentCharge = newValue}
    }
    /// Returns true if `developmentCharge` has been explicitly set.
    var hasDevelopmentCharge: Bool {return self._developmentCharge != nil}
    /// Clears the value of `developmentCharge`. Subsequent reads from it will return its default value.
    mutating func clearDevelopmentCharge() {self._developmentCharge = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _foundationAccount: Concordium_V2_AccountAddress? = nil
    fileprivate var _developmentCharge: Concordium_V2_Amount? = nil
  }

  /// Reward payment to the given account.
  struct PaydayAccountReward: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The account that got rewarded.
    var account: Concordium_V2_AccountAddress {
      get {return _account ?? Concordium_V2_AccountAddress()}
      set {_account = newValue}
    }
    /// Returns true if `account` has been explicitly set.
    var hasAccount: Bool {return self._account != nil}
    /// Clears the value of `account`. Subsequent reads from it will return its default value.
    mutating func clearAccount() {self._account = nil}

    /// The transaction fee reward at payday to the account.
    var transactionFees: Concordium_V2_Amount {
      get {return _transactionFees ?? Concordium_V2_Amount()}
      set {_transactionFees = newValue}
    }
    /// Returns true if `transactionFees` has been explicitly set.
    var hasTransactionFees: Bool {return self._transactionFees != nil}
    /// Clears the value of `transactionFees`. Subsequent reads from it will return its default value.
    mutating func clearTransactionFees() {self._transactionFees = nil}

    /// The baking reward at payday to the account.
    var bakerReward: Concordium_V2_Amount {
      get {return _bakerReward ?? Concordium_V2_Amount()}
      set {_bakerReward = newValue}
    }
    /// Returns true if `bakerReward` has been explicitly set.
    var hasBakerReward: Bool {return self._bakerReward != nil}
    /// Clears the value of `bakerReward`. Subsequent reads from it will return its default value.
    mutating func clearBakerReward() {self._bakerReward = nil}

    /// The finalization reward at payday to the account.
    var finalizationReward: Concordium_V2_Amount {
      get {return _finalizationReward ?? Concordium_V2_Amount()}
      set {_finalizationReward = newValue}
    }
    /// Returns true if `finalizationReward` has been explicitly set.
    var hasFinalizationReward: Bool {return self._finalizationReward != nil}
    /// Clears the value of `finalizationReward`. Subsequent reads from it will return its default value.
    mutating func clearFinalizationReward() {self._finalizationReward = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _account: Concordium_V2_AccountAddress? = nil
    fileprivate var _transactionFees: Concordium_V2_Amount? = nil
    fileprivate var _bakerReward: Concordium_V2_Amount? = nil
    fileprivate var _finalizationReward: Concordium_V2_Amount? = nil
  }

  /// Amounts accrued to accounts for each baked block.
  struct BlockAccrueReward: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The total fees paid for transactions in the block.
    var transactionFees: Concordium_V2_Amount {
      get {return _transactionFees ?? Concordium_V2_Amount()}
      set {_transactionFees = newValue}
    }
    /// Returns true if `transactionFees` has been explicitly set.
    var hasTransactionFees: Bool {return self._transactionFees != nil}
    /// Clears the value of `transactionFees`. Subsequent reads from it will return its default value.
    mutating func clearTransactionFees() {self._transactionFees = nil}

    /// The old balance of the GAS account.
    var oldGasAccount: Concordium_V2_Amount {
      get {return _oldGasAccount ?? Concordium_V2_Amount()}
      set {_oldGasAccount = newValue}
    }
    /// Returns true if `oldGasAccount` has been explicitly set.
    var hasOldGasAccount: Bool {return self._oldGasAccount != nil}
    /// Clears the value of `oldGasAccount`. Subsequent reads from it will return its default value.
    mutating func clearOldGasAccount() {self._oldGasAccount = nil}

    /// The new balance of the GAS account.
    var newGasAccount: Concordium_V2_Amount {
      get {return _newGasAccount ?? Concordium_V2_Amount()}
      set {_newGasAccount = newValue}
    }
    /// Returns true if `newGasAccount` has been explicitly set.
    var hasNewGasAccount: Bool {return self._newGasAccount != nil}
    /// Clears the value of `newGasAccount`. Subsequent reads from it will return its default value.
    mutating func clearNewGasAccount() {self._newGasAccount = nil}

    /// The amount awarded to the baker.
    var bakerReward: Concordium_V2_Amount {
      get {return _bakerReward ?? Concordium_V2_Amount()}
      set {_bakerReward = newValue}
    }
    /// Returns true if `bakerReward` has been explicitly set.
    var hasBakerReward: Bool {return self._bakerReward != nil}
    /// Clears the value of `bakerReward`. Subsequent reads from it will return its default value.
    mutating func clearBakerReward() {self._bakerReward = nil}

    /// The amount awarded to the passive delegators.
    var passiveReward: Concordium_V2_Amount {
      get {return _passiveReward ?? Concordium_V2_Amount()}
      set {_passiveReward = newValue}
    }
    /// Returns true if `passiveReward` has been explicitly set.
    var hasPassiveReward: Bool {return self._passiveReward != nil}
    /// Clears the value of `passiveReward`. Subsequent reads from it will return its default value.
    mutating func clearPassiveReward() {self._passiveReward = nil}

    /// The amount awarded to the foundation.
    var foundationCharge: Concordium_V2_Amount {
      get {return _foundationCharge ?? Concordium_V2_Amount()}
      set {_foundationCharge = newValue}
    }
    /// Returns true if `foundationCharge` has been explicitly set.
    var hasFoundationCharge: Bool {return self._foundationCharge != nil}
    /// Clears the value of `foundationCharge`. Subsequent reads from it will return its default value.
    mutating func clearFoundationCharge() {self._foundationCharge = nil}

    /// The baker of the block, who will receive the award.
    var baker: Concordium_V2_BakerId {
      get {return _baker ?? Concordium_V2_BakerId()}
      set {_baker = newValue}
    }
    /// Returns true if `baker` has been explicitly set.
    var hasBaker: Bool {return self._baker != nil}
    /// Clears the value of `baker`. Subsequent reads from it will return its default value.
    mutating func clearBaker() {self._baker = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _transactionFees: Concordium_V2_Amount? = nil
    fileprivate var _oldGasAccount: Concordium_V2_Amount? = nil
    fileprivate var _newGasAccount: Concordium_V2_Amount? = nil
    fileprivate var _bakerReward: Concordium_V2_Amount? = nil
    fileprivate var _passiveReward: Concordium_V2_Amount? = nil
    fileprivate var _foundationCharge: Concordium_V2_Amount? = nil
    fileprivate var _baker: Concordium_V2_BakerId? = nil
  }

  /// Payment distributed to a pool or passive delegators.
  struct PaydayPoolReward: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The pool owner (passive delegators when not present).
    var poolOwner: Concordium_V2_BakerId {
      get {return _poolOwner ?? Concordium_V2_BakerId()}
      set {_poolOwner = newValue}
    }
    /// Returns true if `poolOwner` has been explicitly set.
    var hasPoolOwner: Bool {return self._poolOwner != nil}
    /// Clears the value of `poolOwner`. Subsequent reads from it will return its default value.
    mutating func clearPoolOwner() {self._poolOwner = nil}

    /// Accrued transaction fees for pool.
    var transactionFees: Concordium_V2_Amount {
      get {return _transactionFees ?? Concordium_V2_Amount()}
      set {_transactionFees = newValue}
    }
    /// Returns true if `transactionFees` has been explicitly set.
    var hasTransactionFees: Bool {return self._transactionFees != nil}
    /// Clears the value of `transactionFees`. Subsequent reads from it will return its default value.
    mutating func clearTransactionFees() {self._transactionFees = nil}

    /// Accrued baking rewards for pool.
    var bakerReward: Concordium_V2_Amount {
      get {return _bakerReward ?? Concordium_V2_Amount()}
      set {_bakerReward = newValue}
    }
    /// Returns true if `bakerReward` has been explicitly set.
    var hasBakerReward: Bool {return self._bakerReward != nil}
    /// Clears the value of `bakerReward`. Subsequent reads from it will return its default value.
    mutating func clearBakerReward() {self._bakerReward = nil}

    /// Accrued finalization rewards for pool.
    var finalizationReward: Concordium_V2_Amount {
      get {return _finalizationReward ?? Concordium_V2_Amount()}
      set {_finalizationReward = newValue}
    }
    /// Returns true if `finalizationReward` has been explicitly set.
    var hasFinalizationReward: Bool {return self._finalizationReward != nil}
    /// Clears the value of `finalizationReward`. Subsequent reads from it will return its default value.
    mutating func clearFinalizationReward() {self._finalizationReward = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _poolOwner: Concordium_V2_BakerId? = nil
    fileprivate var _transactionFees: Concordium_V2_Amount? = nil
    fileprivate var _bakerReward: Concordium_V2_Amount? = nil
    fileprivate var _finalizationReward: Concordium_V2_Amount? = nil
  }

  init() {}
}

/// A pending update.
struct Concordium_V2_PendingUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The effective time of the update.
  var effectiveTime: Concordium_V2_TransactionTime {
    get {return _effectiveTime ?? Concordium_V2_TransactionTime()}
    set {_effectiveTime = newValue}
  }
  /// Returns true if `effectiveTime` has been explicitly set.
  var hasEffectiveTime: Bool {return self._effectiveTime != nil}
  /// Clears the value of `effectiveTime`. Subsequent reads from it will return its default value.
  mutating func clearEffectiveTime() {self._effectiveTime = nil}

  /// The effect of the update.
  var effect: Concordium_V2_PendingUpdate.OneOf_Effect? = nil

  /// Updates to the root keys.
  var rootKeys: Concordium_V2_HigherLevelKeys {
    get {
      if case .rootKeys(let v)? = effect {return v}
      return Concordium_V2_HigherLevelKeys()
    }
    set {effect = .rootKeys(newValue)}
  }

  /// Updates to the level 1 keys.
  var level1Keys: Concordium_V2_HigherLevelKeys {
    get {
      if case .level1Keys(let v)? = effect {return v}
      return Concordium_V2_HigherLevelKeys()
    }
    set {effect = .level1Keys(newValue)}
  }

  /// Updates to the level 2 keys.
  var level2KeysCpv0: Concordium_V2_AuthorizationsV0 {
    get {
      if case .level2KeysCpv0(let v)? = effect {return v}
      return Concordium_V2_AuthorizationsV0()
    }
    set {effect = .level2KeysCpv0(newValue)}
  }

  /// Updates to the level 2 keys.
  var level2KeysCpv1: Concordium_V2_AuthorizationsV1 {
    get {
      if case .level2KeysCpv1(let v)? = effect {return v}
      return Concordium_V2_AuthorizationsV1()
    }
    set {effect = .level2KeysCpv1(newValue)}
  }

  /// Protocol updates.
  var `protocol`: Concordium_V2_ProtocolUpdate {
    get {
      if case .protocol(let v)? = effect {return v}
      return Concordium_V2_ProtocolUpdate()
    }
    set {effect = .protocol(newValue)}
  }

  /// Updates to the election difficulty parameter.
  var electionDifficulty: Concordium_V2_ElectionDifficulty {
    get {
      if case .electionDifficulty(let v)? = effect {return v}
      return Concordium_V2_ElectionDifficulty()
    }
    set {effect = .electionDifficulty(newValue)}
  }

  /// Updates to the euro:energy exchange rate.
  var euroPerEnergy: Concordium_V2_ExchangeRate {
    get {
      if case .euroPerEnergy(let v)? = effect {return v}
      return Concordium_V2_ExchangeRate()
    }
    set {effect = .euroPerEnergy(newValue)}
  }

  /// Updates to the CCD:EUR exchange rate.
  var microCcdPerEuro: Concordium_V2_ExchangeRate {
    get {
      if case .microCcdPerEuro(let v)? = effect {return v}
      return Concordium_V2_ExchangeRate()
    }
    set {effect = .microCcdPerEuro(newValue)}
  }

  /// Updates to the foundation account.
  var foundationAccount: Concordium_V2_AccountAddress {
    get {
      if case .foundationAccount(let v)? = effect {return v}
      return Concordium_V2_AccountAddress()
    }
    set {effect = .foundationAccount(newValue)}
  }

  /// Updates to the mint distribution. Is only relevant prior to protocol version 4.
  var mintDistributionCpv0: Concordium_V2_MintDistributionCpv0 {
    get {
      if case .mintDistributionCpv0(let v)? = effect {return v}
      return Concordium_V2_MintDistributionCpv0()
    }
    set {effect = .mintDistributionCpv0(newValue)}
  }

  /// The mint distribution was updated. Introduced in protocol version 4.
  var mintDistributionCpv1: Concordium_V2_MintDistributionCpv1 {
    get {
      if case .mintDistributionCpv1(let v)? = effect {return v}
      return Concordium_V2_MintDistributionCpv1()
    }
    set {effect = .mintDistributionCpv1(newValue)}
  }

  /// Updates to the transaction fee distribution.
  var transactionFeeDistribution: Concordium_V2_TransactionFeeDistribution {
    get {
      if case .transactionFeeDistribution(let v)? = effect {return v}
      return Concordium_V2_TransactionFeeDistribution()
    }
    set {effect = .transactionFeeDistribution(newValue)}
  }

  /// Updates to the GAS rewards.
  var gasRewards: Concordium_V2_GasRewards {
    get {
      if case .gasRewards(let v)? = effect {return v}
      return Concordium_V2_GasRewards()
    }
    set {effect = .gasRewards(newValue)}
  }

  /// Updates baker stake threshold. Is only relevant prior to protocol version 4.
  var poolParametersCpv0: Concordium_V2_BakerStakeThreshold {
    get {
      if case .poolParametersCpv0(let v)? = effect {return v}
      return Concordium_V2_BakerStakeThreshold()
    }
    set {effect = .poolParametersCpv0(newValue)}
  }

  /// Updates pool parameters. Introduced in protocol version 4.
  var poolParametersCpv1: Concordium_V2_PoolParametersCpv1 {
    get {
      if case .poolParametersCpv1(let v)? = effect {return v}
      return Concordium_V2_PoolParametersCpv1()
    }
    set {effect = .poolParametersCpv1(newValue)}
  }

  /// Adds a new anonymity revoker.
  var addAnonymityRevoker: Concordium_V2_ArInfo {
    get {
      if case .addAnonymityRevoker(let v)? = effect {return v}
      return Concordium_V2_ArInfo()
    }
    set {effect = .addAnonymityRevoker(newValue)}
  }

  /// Adds a new identity provider.
  var addIdentityProvider: Concordium_V2_IpInfo {
    get {
      if case .addIdentityProvider(let v)? = effect {return v}
      return Concordium_V2_IpInfo()
    }
    set {effect = .addIdentityProvider(newValue)}
  }

  /// Updates to cooldown parameters for chain parameters version 1 introduced in protocol version 4.
  var cooldownParameters: Concordium_V2_CooldownParametersCpv1 {
    get {
      if case .cooldownParameters(let v)? = effect {return v}
      return Concordium_V2_CooldownParametersCpv1()
    }
    set {effect = .cooldownParameters(newValue)}
  }

  /// Updates to time parameters for chain parameters version 1 introduced in protocol version 4.
  var timeParameters: Concordium_V2_TimeParametersCpv1 {
    get {
      if case .timeParameters(let v)? = effect {return v}
      return Concordium_V2_TimeParametersCpv1()
    }
    set {effect = .timeParameters(newValue)}
  }

  /// Updates to the GAS rewards effective from protocol version 6 (chain parameters version 2).
  var gasRewardsCpv2: Concordium_V2_GasRewardsCpv2 {
    get {
      if case .gasRewardsCpv2(let v)? = effect {return v}
      return Concordium_V2_GasRewardsCpv2()
    }
    set {effect = .gasRewardsCpv2(newValue)}
  }

  /// Updates to the consensus timeouts for chain parameters version 2.
  var timeoutParameters: Concordium_V2_TimeoutParameters {
    get {
      if case .timeoutParameters(let v)? = effect {return v}
      return Concordium_V2_TimeoutParameters()
    }
    set {effect = .timeoutParameters(newValue)}
  }

  /// Updates to the the minimum time between blocks for chain parameters version 2.
  var minBlockTime: Concordium_V2_Duration {
    get {
      if case .minBlockTime(let v)? = effect {return v}
      return Concordium_V2_Duration()
    }
    set {effect = .minBlockTime(newValue)}
  }

  /// Updates to the block energy limit for chain parameters version 2.
  var blockEnergyLimit: Concordium_V2_Energy {
    get {
      if case .blockEnergyLimit(let v)? = effect {return v}
      return Concordium_V2_Energy()
    }
    set {effect = .blockEnergyLimit(newValue)}
  }

  /// Updates to the finalization committee for for chain parameters version 2.
  var finalizationCommitteeParameters: Concordium_V2_FinalizationCommitteeParameters {
    get {
      if case .finalizationCommitteeParameters(let v)? = effect {return v}
      return Concordium_V2_FinalizationCommitteeParameters()
    }
    set {effect = .finalizationCommitteeParameters(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The effect of the update.
  enum OneOf_Effect: Equatable, Sendable {
    /// Updates to the root keys.
    case rootKeys(Concordium_V2_HigherLevelKeys)
    /// Updates to the level 1 keys.
    case level1Keys(Concordium_V2_HigherLevelKeys)
    /// Updates to the level 2 keys.
    case level2KeysCpv0(Concordium_V2_AuthorizationsV0)
    /// Updates to the level 2 keys.
    case level2KeysCpv1(Concordium_V2_AuthorizationsV1)
    /// Protocol updates.
    case `protocol`(Concordium_V2_ProtocolUpdate)
    /// Updates to the election difficulty parameter.
    case electionDifficulty(Concordium_V2_ElectionDifficulty)
    /// Updates to the euro:energy exchange rate.
    case euroPerEnergy(Concordium_V2_ExchangeRate)
    /// Updates to the CCD:EUR exchange rate.
    case microCcdPerEuro(Concordium_V2_ExchangeRate)
    /// Updates to the foundation account.
    case foundationAccount(Concordium_V2_AccountAddress)
    /// Updates to the mint distribution. Is only relevant prior to protocol version 4.
    case mintDistributionCpv0(Concordium_V2_MintDistributionCpv0)
    /// The mint distribution was updated. Introduced in protocol version 4.
    case mintDistributionCpv1(Concordium_V2_MintDistributionCpv1)
    /// Updates to the transaction fee distribution.
    case transactionFeeDistribution(Concordium_V2_TransactionFeeDistribution)
    /// Updates to the GAS rewards.
    case gasRewards(Concordium_V2_GasRewards)
    /// Updates baker stake threshold. Is only relevant prior to protocol version 4.
    case poolParametersCpv0(Concordium_V2_BakerStakeThreshold)
    /// Updates pool parameters. Introduced in protocol version 4.
    case poolParametersCpv1(Concordium_V2_PoolParametersCpv1)
    /// Adds a new anonymity revoker.
    case addAnonymityRevoker(Concordium_V2_ArInfo)
    /// Adds a new identity provider.
    case addIdentityProvider(Concordium_V2_IpInfo)
    /// Updates to cooldown parameters for chain parameters version 1 introduced in protocol version 4.
    case cooldownParameters(Concordium_V2_CooldownParametersCpv1)
    /// Updates to time parameters for chain parameters version 1 introduced in protocol version 4.
    case timeParameters(Concordium_V2_TimeParametersCpv1)
    /// Updates to the GAS rewards effective from protocol version 6 (chain parameters version 2).
    case gasRewardsCpv2(Concordium_V2_GasRewardsCpv2)
    /// Updates to the consensus timeouts for chain parameters version 2.
    case timeoutParameters(Concordium_V2_TimeoutParameters)
    /// Updates to the the minimum time between blocks for chain parameters version 2.
    case minBlockTime(Concordium_V2_Duration)
    /// Updates to the block energy limit for chain parameters version 2.
    case blockEnergyLimit(Concordium_V2_Energy)
    /// Updates to the finalization committee for for chain parameters version 2.
    case finalizationCommitteeParameters(Concordium_V2_FinalizationCommitteeParameters)

  }

  init() {}

  fileprivate var _effectiveTime: Concordium_V2_TransactionTime? = nil
}

/// The response for `GetNextUpdateSequenceNumbers`.
struct Concordium_V2_NextUpdateSequenceNumbers: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Updates to the root keys.
  var rootKeys: Concordium_V2_SequenceNumber {
    get {return _storage._rootKeys ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._rootKeys = newValue}
  }
  /// Returns true if `rootKeys` has been explicitly set.
  var hasRootKeys: Bool {return _storage._rootKeys != nil}
  /// Clears the value of `rootKeys`. Subsequent reads from it will return its default value.
  mutating func clearRootKeys() {_uniqueStorage()._rootKeys = nil}

  /// Updates to the level 1 keys.
  var level1Keys: Concordium_V2_SequenceNumber {
    get {return _storage._level1Keys ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._level1Keys = newValue}
  }
  /// Returns true if `level1Keys` has been explicitly set.
  var hasLevel1Keys: Bool {return _storage._level1Keys != nil}
  /// Clears the value of `level1Keys`. Subsequent reads from it will return its default value.
  mutating func clearLevel1Keys() {_uniqueStorage()._level1Keys = nil}

  /// Updates to the level 2 keys.
  var level2Keys: Concordium_V2_SequenceNumber {
    get {return _storage._level2Keys ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._level2Keys = newValue}
  }
  /// Returns true if `level2Keys` has been explicitly set.
  var hasLevel2Keys: Bool {return _storage._level2Keys != nil}
  /// Clears the value of `level2Keys`. Subsequent reads from it will return its default value.
  mutating func clearLevel2Keys() {_uniqueStorage()._level2Keys = nil}

  /// Protocol updates.
  var `protocol`: Concordium_V2_SequenceNumber {
    get {return _storage._protocol ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._protocol = newValue}
  }
  /// Returns true if ``protocol`` has been explicitly set.
  var hasProtocol: Bool {return _storage._protocol != nil}
  /// Clears the value of ``protocol``. Subsequent reads from it will return its default value.
  mutating func clearProtocol() {_uniqueStorage()._protocol = nil}

  /// Updates to the election difficulty parameter.
  var electionDifficulty: Concordium_V2_SequenceNumber {
    get {return _storage._electionDifficulty ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._electionDifficulty = newValue}
  }
  /// Returns true if `electionDifficulty` has been explicitly set.
  var hasElectionDifficulty: Bool {return _storage._electionDifficulty != nil}
  /// Clears the value of `electionDifficulty`. Subsequent reads from it will return its default value.
  mutating func clearElectionDifficulty() {_uniqueStorage()._electionDifficulty = nil}

  /// Updates to the euro:energy exchange rate.
  var euroPerEnergy: Concordium_V2_SequenceNumber {
    get {return _storage._euroPerEnergy ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._euroPerEnergy = newValue}
  }
  /// Returns true if `euroPerEnergy` has been explicitly set.
  var hasEuroPerEnergy: Bool {return _storage._euroPerEnergy != nil}
  /// Clears the value of `euroPerEnergy`. Subsequent reads from it will return its default value.
  mutating func clearEuroPerEnergy() {_uniqueStorage()._euroPerEnergy = nil}

  /// Updates to the CCD:EUR exchange rate.
  var microCcdPerEuro: Concordium_V2_SequenceNumber {
    get {return _storage._microCcdPerEuro ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._microCcdPerEuro = newValue}
  }
  /// Returns true if `microCcdPerEuro` has been explicitly set.
  var hasMicroCcdPerEuro: Bool {return _storage._microCcdPerEuro != nil}
  /// Clears the value of `microCcdPerEuro`. Subsequent reads from it will return its default value.
  mutating func clearMicroCcdPerEuro() {_uniqueStorage()._microCcdPerEuro = nil}

  /// Updates to the foundation account.
  var foundationAccount: Concordium_V2_SequenceNumber {
    get {return _storage._foundationAccount ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._foundationAccount = newValue}
  }
  /// Returns true if `foundationAccount` has been explicitly set.
  var hasFoundationAccount: Bool {return _storage._foundationAccount != nil}
  /// Clears the value of `foundationAccount`. Subsequent reads from it will return its default value.
  mutating func clearFoundationAccount() {_uniqueStorage()._foundationAccount = nil}

  /// Updates to the mint distribution.
  var mintDistribution: Concordium_V2_SequenceNumber {
    get {return _storage._mintDistribution ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._mintDistribution = newValue}
  }
  /// Returns true if `mintDistribution` has been explicitly set.
  var hasMintDistribution: Bool {return _storage._mintDistribution != nil}
  /// Clears the value of `mintDistribution`. Subsequent reads from it will return its default value.
  mutating func clearMintDistribution() {_uniqueStorage()._mintDistribution = nil}

  /// Updates to the transaction fee distribution.
  var transactionFeeDistribution: Concordium_V2_SequenceNumber {
    get {return _storage._transactionFeeDistribution ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._transactionFeeDistribution = newValue}
  }
  /// Returns true if `transactionFeeDistribution` has been explicitly set.
  var hasTransactionFeeDistribution: Bool {return _storage._transactionFeeDistribution != nil}
  /// Clears the value of `transactionFeeDistribution`. Subsequent reads from it will return its default value.
  mutating func clearTransactionFeeDistribution() {_uniqueStorage()._transactionFeeDistribution = nil}

  /// Updates to the GAS rewards.
  var gasRewards: Concordium_V2_SequenceNumber {
    get {return _storage._gasRewards ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._gasRewards = newValue}
  }
  /// Returns true if `gasRewards` has been explicitly set.
  var hasGasRewards: Bool {return _storage._gasRewards != nil}
  /// Clears the value of `gasRewards`. Subsequent reads from it will return its default value.
  mutating func clearGasRewards() {_uniqueStorage()._gasRewards = nil}

  /// Updates pool parameters.
  var poolParameters: Concordium_V2_SequenceNumber {
    get {return _storage._poolParameters ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._poolParameters = newValue}
  }
  /// Returns true if `poolParameters` has been explicitly set.
  var hasPoolParameters: Bool {return _storage._poolParameters != nil}
  /// Clears the value of `poolParameters`. Subsequent reads from it will return its default value.
  mutating func clearPoolParameters() {_uniqueStorage()._poolParameters = nil}

  /// Adds a new anonymity revoker.
  var addAnonymityRevoker: Concordium_V2_SequenceNumber {
    get {return _storage._addAnonymityRevoker ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._addAnonymityRevoker = newValue}
  }
  /// Returns true if `addAnonymityRevoker` has been explicitly set.
  var hasAddAnonymityRevoker: Bool {return _storage._addAnonymityRevoker != nil}
  /// Clears the value of `addAnonymityRevoker`. Subsequent reads from it will return its default value.
  mutating func clearAddAnonymityRevoker() {_uniqueStorage()._addAnonymityRevoker = nil}

  /// Adds a new identity provider.
  var addIdentityProvider: Concordium_V2_SequenceNumber {
    get {return _storage._addIdentityProvider ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._addIdentityProvider = newValue}
  }
  /// Returns true if `addIdentityProvider` has been explicitly set.
  var hasAddIdentityProvider: Bool {return _storage._addIdentityProvider != nil}
  /// Clears the value of `addIdentityProvider`. Subsequent reads from it will return its default value.
  mutating func clearAddIdentityProvider() {_uniqueStorage()._addIdentityProvider = nil}

  /// Updates to cooldown parameters for chain parameters version 1 introduced in protocol version 4.
  var cooldownParameters: Concordium_V2_SequenceNumber {
    get {return _storage._cooldownParameters ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._cooldownParameters = newValue}
  }
  /// Returns true if `cooldownParameters` has been explicitly set.
  var hasCooldownParameters: Bool {return _storage._cooldownParameters != nil}
  /// Clears the value of `cooldownParameters`. Subsequent reads from it will return its default value.
  mutating func clearCooldownParameters() {_uniqueStorage()._cooldownParameters = nil}

  /// Updates to time parameters for chain parameters version 1 introduced in protocol version 4.
  var timeParameters: Concordium_V2_SequenceNumber {
    get {return _storage._timeParameters ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._timeParameters = newValue}
  }
  /// Returns true if `timeParameters` has been explicitly set.
  var hasTimeParameters: Bool {return _storage._timeParameters != nil}
  /// Clears the value of `timeParameters`. Subsequent reads from it will return its default value.
  mutating func clearTimeParameters() {_uniqueStorage()._timeParameters = nil}

  /// Updates to the timeout parameters
  var timeoutParameters: Concordium_V2_SequenceNumber {
    get {return _storage._timeoutParameters ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._timeoutParameters = newValue}
  }
  /// Returns true if `timeoutParameters` has been explicitly set.
  var hasTimeoutParameters: Bool {return _storage._timeoutParameters != nil}
  /// Clears the value of `timeoutParameters`. Subsequent reads from it will return its default value.
  mutating func clearTimeoutParameters() {_uniqueStorage()._timeoutParameters = nil}

  /// Updates to the the minimum time between blocks for chain parameters version 2.
  var minBlockTime: Concordium_V2_SequenceNumber {
    get {return _storage._minBlockTime ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._minBlockTime = newValue}
  }
  /// Returns true if `minBlockTime` has been explicitly set.
  var hasMinBlockTime: Bool {return _storage._minBlockTime != nil}
  /// Clears the value of `minBlockTime`. Subsequent reads from it will return its default value.
  mutating func clearMinBlockTime() {_uniqueStorage()._minBlockTime = nil}

  /// Updates to the block energy limit for chain parameters version 2.
  var blockEnergyLimit: Concordium_V2_SequenceNumber {
    get {return _storage._blockEnergyLimit ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._blockEnergyLimit = newValue}
  }
  /// Returns true if `blockEnergyLimit` has been explicitly set.
  var hasBlockEnergyLimit: Bool {return _storage._blockEnergyLimit != nil}
  /// Clears the value of `blockEnergyLimit`. Subsequent reads from it will return its default value.
  mutating func clearBlockEnergyLimit() {_uniqueStorage()._blockEnergyLimit = nil}

  /// Updates to the finalization committee parameters
  var finalizationCommitteeParameters: Concordium_V2_SequenceNumber {
    get {return _storage._finalizationCommitteeParameters ?? Concordium_V2_SequenceNumber()}
    set {_uniqueStorage()._finalizationCommitteeParameters = newValue}
  }
  /// Returns true if `finalizationCommitteeParameters` has been explicitly set.
  var hasFinalizationCommitteeParameters: Bool {return _storage._finalizationCommitteeParameters != nil}
  /// Clears the value of `finalizationCommitteeParameters`. Subsequent reads from it will return its default value.
  mutating func clearFinalizationCommitteeParameters() {_uniqueStorage()._finalizationCommitteeParameters = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A request to send a new block item to the chain.
/// An IP address
struct Concordium_V2_IpAddress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A port
/// Valid port numbers are expected thus
/// the value is expected to be in the range (0..u16::MAX).
struct Concordium_V2_Port: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A socket address consisting of
/// an IP + port.
struct Concordium_V2_IpSocketAddress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ip: Concordium_V2_IpAddress {
    get {return _ip ?? Concordium_V2_IpAddress()}
    set {_ip = newValue}
  }
  /// Returns true if `ip` has been explicitly set.
  var hasIp: Bool {return self._ip != nil}
  /// Clears the value of `ip`. Subsequent reads from it will return its default value.
  mutating func clearIp() {self._ip = nil}

  var port: Concordium_V2_Port {
    get {return _port ?? Concordium_V2_Port()}
    set {_port = newValue}
  }
  /// Returns true if `port` has been explicitly set.
  var hasPort: Bool {return self._port != nil}
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  mutating func clearPort() {self._port = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ip: Concordium_V2_IpAddress? = nil
  fileprivate var _port: Concordium_V2_Port? = nil
}

/// A peer id
/// An identifier that the peer wants to be
/// be recoknized by.
/// The underlying value is simply a u64.
/// Note. There is no authenticity of the peer id and
/// as such it is only used for logging purposes.
struct Concordium_V2_PeerId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A banned peer
struct Concordium_V2_BannedPeer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The IP address of the banned peer.
  var ipAddress: Concordium_V2_IpAddress {
    get {return _ipAddress ?? Concordium_V2_IpAddress()}
    set {_ipAddress = newValue}
  }
  /// Returns true if `ipAddress` has been explicitly set.
  var hasIpAddress: Bool {return self._ipAddress != nil}
  /// Clears the value of `ipAddress`. Subsequent reads from it will return its default value.
  mutating func clearIpAddress() {self._ipAddress = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ipAddress: Concordium_V2_IpAddress? = nil
}

/// The banned peers given by
/// their IP addresses.
struct Concordium_V2_BannedPeers: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peers: [Concordium_V2_BannedPeer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A peer to ban specified by its IP.
/// Note. This will ban all peers located behind the
/// specified IP even though they are using different ports.
struct Concordium_V2_PeerToBan: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ipAddress: Concordium_V2_IpAddress {
    get {return _ipAddress ?? Concordium_V2_IpAddress()}
    set {_ipAddress = newValue}
  }
  /// Returns true if `ipAddress` has been explicitly set.
  var hasIpAddress: Bool {return self._ipAddress != nil}
  /// Clears the value of `ipAddress`. Subsequent reads from it will return its default value.
  mutating func clearIpAddress() {self._ipAddress = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ipAddress: Concordium_V2_IpAddress? = nil
}

/// Request to enable dumping of network packages.
struct Concordium_V2_DumpRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Which file to dump the packages into.
  /// Requires a valid path.
  var file: String = String()

  /// Whether the node should dump raw packages.
  var raw: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Peers and their associated network related statistics
struct Concordium_V2_PeersInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peers: [Concordium_V2_PeersInfo.Peer] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A peer that the node is connected to.
  struct Peer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identifier of the peer that it
    /// wishes to be identified by.
    var peerID: Concordium_V2_PeerId {
      get {return _peerID ?? Concordium_V2_PeerId()}
      set {_peerID = newValue}
    }
    /// Returns true if `peerID` has been explicitly set.
    var hasPeerID: Bool {return self._peerID != nil}
    /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
    mutating func clearPeerID() {self._peerID = nil}

    /// The port of the peer.
    var socketAddress: Concordium_V2_IpSocketAddress {
      get {return _socketAddress ?? Concordium_V2_IpSocketAddress()}
      set {_socketAddress = newValue}
    }
    /// Returns true if `socketAddress` has been explicitly set.
    var hasSocketAddress: Bool {return self._socketAddress != nil}
    /// Clears the value of `socketAddress`. Subsequent reads from it will return its default value.
    mutating func clearSocketAddress() {self._socketAddress = nil}

    /// Network related statistics for the peer.
    var networkStats: Concordium_V2_PeersInfo.Peer.NetworkStats {
      get {return _networkStats ?? Concordium_V2_PeersInfo.Peer.NetworkStats()}
      set {_networkStats = newValue}
    }
    /// Returns true if `networkStats` has been explicitly set.
    var hasNetworkStats: Bool {return self._networkStats != nil}
    /// Clears the value of `networkStats`. Subsequent reads from it will return its default value.
    mutating func clearNetworkStats() {self._networkStats = nil}

    /// consensus related information of the peer.
    var consensusInfo: Concordium_V2_PeersInfo.Peer.OneOf_ConsensusInfo? = nil

    /// The peer is of type `Bootstrapper` is not participating in consensus
    /// and thus has no catchup status.
    var bootstrapper: Concordium_V2_Empty {
      get {
        if case .bootstrapper(let v)? = consensusInfo {return v}
        return Concordium_V2_Empty()
      }
      set {consensusInfo = .bootstrapper(newValue)}
    }

    /// The peer is a regular node and have
    /// an associated catchup status.
    var nodeCatchupStatus: Concordium_V2_PeersInfo.Peer.CatchupStatus {
      get {
        if case .nodeCatchupStatus(let v)? = consensusInfo {return v}
        return .uptodate
      }
      set {consensusInfo = .nodeCatchupStatus(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// consensus related information of the peer.
    enum OneOf_ConsensusInfo: Equatable, Sendable {
      /// The peer is of type `Bootstrapper` is not participating in consensus
      /// and thus has no catchup status.
      case bootstrapper(Concordium_V2_Empty)
      /// The peer is a regular node and have
      /// an associated catchup status.
      case nodeCatchupStatus(Concordium_V2_PeersInfo.Peer.CatchupStatus)

    }

    enum CatchupStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int

      /// The peer does not have any data unknown to us. If we receive a message from the
      /// peer that refers to unknown data (e.g., an unknown block) the peer is marked as pending.
      case uptodate // = 0

      /// The peer might have some data unknown to us. A peer can be in this state either because
      /// it sent a message that refers to data unknown to us, or before we have established a baseline with it.
      /// The latter happens during node startup, as well as upon protocol updates until the initial catchup handshake
      /// completes.
      case pending // = 1

      /// The node is currently catching up by requesting blocks from this peer.
      /// There will be at most one peer with this status at a time.
      /// Once the peer has responded to the request, its status will be changed to:
      /// - 'UPTODATE' if the peer has no more data that is not known to us
      /// - 'PENDING' if the node has more data that is unknown to us.
      case catchingup // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .uptodate
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .uptodate
        case 1: self = .pending
        case 2: self = .catchingup
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .uptodate: return 0
        case .pending: return 1
        case .catchingup: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Concordium_V2_PeersInfo.Peer.CatchupStatus] = [
        .uptodate,
        .pending,
        .catchingup,
      ]

    }

    /// Network statistics for the peer
    struct NetworkStats: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The number of messages sent to the peer.
      /// Packets are blocks, transactions, catchup messages, finalization records
      /// and network messages such as pings and peer requests.
      var packetsSent: UInt64 = 0

      /// The number of messages received from the peer.
      /// Packets are blocks, transactions, catchup messages, finalization records
      /// and network messages such as pings and peer requests.
      var packetsReceived: UInt64 = 0

      /// The connection latency (i.e., ping time) in milliseconds.
      var latency: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _peerID: Concordium_V2_PeerId? = nil
    fileprivate var _socketAddress: Concordium_V2_IpSocketAddress? = nil
    fileprivate var _networkStats: Concordium_V2_PeersInfo.Peer.NetworkStats? = nil
  }

  init() {}
}

/// Node info response
/// Contains various information of the
/// enquired node.
struct Concordium_V2_NodeInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of the node.
  var peerVersion: String = String()

  /// local time of the node.
  var localTime: Concordium_V2_Timestamp {
    get {return _localTime ?? Concordium_V2_Timestamp()}
    set {_localTime = newValue}
  }
  /// Returns true if `localTime` has been explicitly set.
  var hasLocalTime: Bool {return self._localTime != nil}
  /// Clears the value of `localTime`. Subsequent reads from it will return its default value.
  mutating func clearLocalTime() {self._localTime = nil}

  /// Number of milliseconds that the node
  /// has been alive.
  var peerUptime: Concordium_V2_Duration {
    get {return _peerUptime ?? Concordium_V2_Duration()}
    set {_peerUptime = newValue}
  }
  /// Returns true if `peerUptime` has been explicitly set.
  var hasPeerUptime: Bool {return self._peerUptime != nil}
  /// Clears the value of `peerUptime`. Subsequent reads from it will return its default value.
  mutating func clearPeerUptime() {self._peerUptime = nil}

  /// Information related to the p2p protocol.
  var networkInfo: Concordium_V2_NodeInfo.NetworkInfo {
    get {return _networkInfo ?? Concordium_V2_NodeInfo.NetworkInfo()}
    set {_networkInfo = newValue}
  }
  /// Returns true if `networkInfo` has been explicitly set.
  var hasNetworkInfo: Bool {return self._networkInfo != nil}
  /// Clears the value of `networkInfo`. Subsequent reads from it will return its default value.
  mutating func clearNetworkInfo() {self._networkInfo = nil}

  /// Details of the node.
  var details: Concordium_V2_NodeInfo.OneOf_Details? = nil

  /// The node is a bootstrapper and is not running consensus.
  var bootstrapper: Concordium_V2_Empty {
    get {
      if case .bootstrapper(let v)? = details {return v}
      return Concordium_V2_Empty()
    }
    set {details = .bootstrapper(newValue)}
  }

  /// The node is a regular node and runs the consensus
  /// protocol.
  var node: Concordium_V2_NodeInfo.Node {
    get {
      if case .node(let v)? = details {return v}
      return Concordium_V2_NodeInfo.Node()
    }
    set {details = .node(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Details of the node.
  enum OneOf_Details: Equatable, Sendable {
    /// The node is a bootstrapper and is not running consensus.
    case bootstrapper(Concordium_V2_Empty)
    /// The node is a regular node and runs the consensus
    /// protocol.
    case node(Concordium_V2_NodeInfo.Node)

  }

  /// Network related information of the node.
  struct NetworkInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The node id.
    var nodeID: Concordium_V2_PeerId {
      get {return _nodeID ?? Concordium_V2_PeerId()}
      set {_nodeID = newValue}
    }
    /// Returns true if `nodeID` has been explicitly set.
    var hasNodeID: Bool {return self._nodeID != nil}
    /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
    mutating func clearNodeID() {self._nodeID = nil}

    /// Total number of packets sent by the node.
    var peerTotalSent: UInt64 = 0

    /// Total number of packets received by the node.
    var peerTotalReceived: UInt64 = 0

    /// Average outbound throughput in bytes per second.
    var avgBpsIn: UInt64 = 0

    /// Average inbound throughput in bytes per second.
    var avgBpsOut: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _nodeID: Concordium_V2_PeerId? = nil
  }

  /// Consensus info for a node configured with baker keys.
  struct BakerConsensusInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bakerID: Concordium_V2_BakerId {
      get {return _bakerID ?? Concordium_V2_BakerId()}
      set {_bakerID = newValue}
    }
    /// Returns true if `bakerID` has been explicitly set.
    var hasBakerID: Bool {return self._bakerID != nil}
    /// Clears the value of `bakerID`. Subsequent reads from it will return its default value.
    mutating func clearBakerID() {self._bakerID = nil}

    /// Status of the baker configured node.
    var status: Concordium_V2_NodeInfo.BakerConsensusInfo.OneOf_Status? = nil

    /// The node is currently not baking.
    var passiveCommitteeInfo: Concordium_V2_NodeInfo.BakerConsensusInfo.PassiveCommitteeInfo {
      get {
        if case .passiveCommitteeInfo(let v)? = status {return v}
        return .notInCommittee
      }
      set {status = .passiveCommitteeInfo(newValue)}
    }

    /// The node is configured with baker keys and
    /// is member of the baking committee.
    var activeBakerCommitteeInfo: Concordium_V2_NodeInfo.BakerConsensusInfo.ActiveBakerCommitteeInfo {
      get {
        if case .activeBakerCommitteeInfo(let v)? = status {return v}
        return Concordium_V2_NodeInfo.BakerConsensusInfo.ActiveBakerCommitteeInfo()
      }
      set {status = .activeBakerCommitteeInfo(newValue)}
    }

    /// The node is configured with baker keys and
    /// is member of the baking and finalization committees.
    var activeFinalizerCommitteeInfo: Concordium_V2_NodeInfo.BakerConsensusInfo.ActiveFinalizerCommitteeInfo {
      get {
        if case .activeFinalizerCommitteeInfo(let v)? = status {return v}
        return Concordium_V2_NodeInfo.BakerConsensusInfo.ActiveFinalizerCommitteeInfo()
      }
      set {status = .activeFinalizerCommitteeInfo(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Status of the baker configured node.
    enum OneOf_Status: Equatable, Sendable {
      /// The node is currently not baking.
      case passiveCommitteeInfo(Concordium_V2_NodeInfo.BakerConsensusInfo.PassiveCommitteeInfo)
      /// The node is configured with baker keys and
      /// is member of the baking committee.
      case activeBakerCommitteeInfo(Concordium_V2_NodeInfo.BakerConsensusInfo.ActiveBakerCommitteeInfo)
      /// The node is configured with baker keys and
      /// is member of the baking and finalization committees.
      case activeFinalizerCommitteeInfo(Concordium_V2_NodeInfo.BakerConsensusInfo.ActiveFinalizerCommitteeInfo)

    }

    /// The committee information of a node configured with
    /// baker keys but somehow the node is _not_ part of the
    /// current baking committee.
    enum PassiveCommitteeInfo: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int

      /// The node is started with baker keys however it is currently not in the baking committee.
      /// The node is __not__ baking.
      case notInCommittee // = 0

      /// The account is registered as a baker but not in the current `Epoch`.
      /// The node is __not__ baking.
      case addedButNotActiveInCommittee // = 1

      /// The node has configured invalid baker keys i.e., the configured
      /// baker keys do not match the current keys on the baker account.
      /// The node is __not__ baking.
      case addedButWrongKeys // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .notInCommittee
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .notInCommittee
        case 1: self = .addedButNotActiveInCommittee
        case 2: self = .addedButWrongKeys
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .notInCommittee: return 0
        case .addedButNotActiveInCommittee: return 1
        case .addedButWrongKeys: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Concordium_V2_NodeInfo.BakerConsensusInfo.PassiveCommitteeInfo] = [
        .notInCommittee,
        .addedButNotActiveInCommittee,
        .addedButWrongKeys,
      ]

    }

    /// Tagging message type for a node that
    /// is configured with baker keys and active in
    /// the current baking committee
    struct ActiveBakerCommitteeInfo: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    /// Tagging message type for a node that
    /// is configured with baker keys and active in
    /// the current finalizer committee (and also baking committee).
    struct ActiveFinalizerCommitteeInfo: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _bakerID: Concordium_V2_BakerId? = nil
  }

  /// The node is a regular node.
  struct Node: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var consensusStatus: Concordium_V2_NodeInfo.Node.OneOf_ConsensusStatus? = nil

    /// The node is not running consensus.
    /// This is the case only when the node is
    /// not supporting the protocol on the chain.
    /// The node does not process blocks.
    var notRunning: Concordium_V2_Empty {
      get {
        if case .notRunning(let v)? = consensusStatus {return v}
        return Concordium_V2_Empty()
      }
      set {consensusStatus = .notRunning(newValue)}
    }

    /// Consensus info for a node that is
    /// not configured with baker keys.
    /// The node is only processing blocks and
    /// relaying blocks and transactions and responding to
    /// catchup messages.
    var passive: Concordium_V2_Empty {
      get {
        if case .passive(let v)? = consensusStatus {return v}
        return Concordium_V2_Empty()
      }
      set {consensusStatus = .passive(newValue)}
    }

    /// The node is configured with baker credentials and consensus is running.
    var active: Concordium_V2_NodeInfo.BakerConsensusInfo {
      get {
        if case .active(let v)? = consensusStatus {return v}
        return Concordium_V2_NodeInfo.BakerConsensusInfo()
      }
      set {consensusStatus = .active(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_ConsensusStatus: Equatable, Sendable {
      /// The node is not running consensus.
      /// This is the case only when the node is
      /// not supporting the protocol on the chain.
      /// The node does not process blocks.
      case notRunning(Concordium_V2_Empty)
      /// Consensus info for a node that is
      /// not configured with baker keys.
      /// The node is only processing blocks and
      /// relaying blocks and transactions and responding to
      /// catchup messages.
      case passive(Concordium_V2_Empty)
      /// The node is configured with baker credentials and consensus is running.
      case active(Concordium_V2_NodeInfo.BakerConsensusInfo)

    }

    init() {}
  }

  init() {}

  fileprivate var _localTime: Concordium_V2_Timestamp? = nil
  fileprivate var _peerUptime: Concordium_V2_Duration? = nil
  fileprivate var _networkInfo: Concordium_V2_NodeInfo.NetworkInfo? = nil
}

struct Concordium_V2_SendBlockItemRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockItem: Concordium_V2_SendBlockItemRequest.OneOf_BlockItem? = nil

  /// Account transactions are messages which are signed and paid for by an account.
  var accountTransaction: Concordium_V2_AccountTransaction {
    get {
      if case .accountTransaction(let v)? = blockItem {return v}
      return Concordium_V2_AccountTransaction()
    }
    set {blockItem = .accountTransaction(newValue)}
  }

  /// Credential deployments create new accounts. They are not paid for
  /// directly by the sender. Instead, bakers are rewarded by the protocol for
  /// including them.
  var credentialDeployment: Concordium_V2_CredentialDeployment {
    get {
      if case .credentialDeployment(let v)? = blockItem {return v}
      return Concordium_V2_CredentialDeployment()
    }
    set {blockItem = .credentialDeployment(newValue)}
  }

  /// Update instructions are messages which can update the chain parameters. Including which keys are allowed
  /// to make future update instructions.
  var updateInstruction: Concordium_V2_UpdateInstruction {
    get {
      if case .updateInstruction(let v)? = blockItem {return v}
      return Concordium_V2_UpdateInstruction()
    }
    set {blockItem = .updateInstruction(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_BlockItem: Equatable, Sendable {
    /// Account transactions are messages which are signed and paid for by an account.
    case accountTransaction(Concordium_V2_AccountTransaction)
    /// Credential deployments create new accounts. They are not paid for
    /// directly by the sender. Instead, bakers are rewarded by the protocol for
    /// including them.
    case credentialDeployment(Concordium_V2_CredentialDeployment)
    /// Update instructions are messages which can update the chain parameters. Including which keys are allowed
    /// to make future update instructions.
    case updateInstruction(Concordium_V2_UpdateInstruction)

  }

  init() {}
}

/// Credential deployments create new accounts. They are not paid for
/// directly by the sender. Instead, bakers are rewarded by the protocol for
/// including them.
struct Concordium_V2_CredentialDeployment: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messageExpiry: Concordium_V2_TransactionTime {
    get {return _messageExpiry ?? Concordium_V2_TransactionTime()}
    set {_messageExpiry = newValue}
  }
  /// Returns true if `messageExpiry` has been explicitly set.
  var hasMessageExpiry: Bool {return self._messageExpiry != nil}
  /// Clears the value of `messageExpiry`. Subsequent reads from it will return its default value.
  mutating func clearMessageExpiry() {self._messageExpiry = nil}

  /// The credential to be added.
  var payload: Concordium_V2_CredentialDeployment.OneOf_Payload? = nil

  /// A raw payload, which is just the encoded payload.
  /// A typed variant might be added in the future.
  var rawPayload: Data {
    get {
      if case .rawPayload(let v)? = payload {return v}
      return Data()
    }
    set {payload = .rawPayload(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The credential to be added.
  enum OneOf_Payload: Equatable, @unchecked Sendable {
    /// A raw payload, which is just the encoded payload.
    /// A typed variant might be added in the future.
    case rawPayload(Data)

  }

  init() {}

  fileprivate var _messageExpiry: Concordium_V2_TransactionTime? = nil
}

/// A single signature. Used when sending block items to a node with
/// `SendBlockItem`.
struct Concordium_V2_Signature: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A signature on an update instruction.
/// The type `UpdateKeysIndex` is not used directly, as messages cannot be keys in maps.
struct Concordium_V2_SignatureMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signatures: Dictionary<UInt32,Concordium_V2_Signature> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Wrapper for a map from indexes to signatures.
/// Needed because protobuf doesn't allow nested maps directly.
/// The keys in the SignatureMap must not exceed 2^8.
struct Concordium_V2_AccountSignatureMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signatures: Dictionary<UInt32,Concordium_V2_Signature> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Concordium_V2_AccountTransactionSignature: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A map from `CredentialIndex` to `SignatureMap`s.
  /// The type `CredentialIndex` is not used directly, as messages cannot be keys in maps.
  /// The map cannot contain more than 2^8 signatures.
  var signatures: Dictionary<UInt32,Concordium_V2_AccountSignatureMap> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Header of an account transaction that contains basic data to check whether
/// the sender and the transaction are valid. The header is shared by all transaction types.
struct Concordium_V2_AccountTransactionHeader: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender of the transaction.
  var sender: Concordium_V2_AccountAddress {
    get {return _sender ?? Concordium_V2_AccountAddress()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  mutating func clearSender() {self._sender = nil}

  /// Sequence number of the transaction.
  var sequenceNumber: Concordium_V2_SequenceNumber {
    get {return _sequenceNumber ?? Concordium_V2_SequenceNumber()}
    set {_sequenceNumber = newValue}
  }
  /// Returns true if `sequenceNumber` has been explicitly set.
  var hasSequenceNumber: Bool {return self._sequenceNumber != nil}
  /// Clears the value of `sequenceNumber`. Subsequent reads from it will return its default value.
  mutating func clearSequenceNumber() {self._sequenceNumber = nil}

  /// Maximum amount of energy the transaction can take to execute.
  var energyAmount: Concordium_V2_Energy {
    get {return _energyAmount ?? Concordium_V2_Energy()}
    set {_energyAmount = newValue}
  }
  /// Returns true if `energyAmount` has been explicitly set.
  var hasEnergyAmount: Bool {return self._energyAmount != nil}
  /// Clears the value of `energyAmount`. Subsequent reads from it will return its default value.
  mutating func clearEnergyAmount() {self._energyAmount = nil}

  /// Latest time the transaction can included in a block.
  var expiry: Concordium_V2_TransactionTime {
    get {return _expiry ?? Concordium_V2_TransactionTime()}
    set {_expiry = newValue}
  }
  /// Returns true if `expiry` has been explicitly set.
  var hasExpiry: Bool {return self._expiry != nil}
  /// Clears the value of `expiry`. Subsequent reads from it will return its default value.
  mutating func clearExpiry() {self._expiry = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sender: Concordium_V2_AccountAddress? = nil
  fileprivate var _sequenceNumber: Concordium_V2_SequenceNumber? = nil
  fileprivate var _energyAmount: Concordium_V2_Energy? = nil
  fileprivate var _expiry: Concordium_V2_TransactionTime? = nil
}

/// Data required to initialize a new contract instance.
struct Concordium_V2_InitContractPayload: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Amount of CCD to send to the instance.
  var amount: Concordium_V2_Amount {
    get {return _amount ?? Concordium_V2_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  /// Reference to the module from which the instance will be created.
  var moduleRef: Concordium_V2_ModuleRef {
    get {return _moduleRef ?? Concordium_V2_ModuleRef()}
    set {_moduleRef = newValue}
  }
  /// Returns true if `moduleRef` has been explicitly set.
  var hasModuleRef: Bool {return self._moduleRef != nil}
  /// Clears the value of `moduleRef`. Subsequent reads from it will return its default value.
  mutating func clearModuleRef() {self._moduleRef = nil}

  /// Name of the contract to initialize. This is expected to be in the format
  /// `init_name`.
  var initName: Concordium_V2_InitName {
    get {return _initName ?? Concordium_V2_InitName()}
    set {_initName = newValue}
  }
  /// Returns true if `initName` has been explicitly set.
  var hasInitName: Bool {return self._initName != nil}
  /// Clears the value of `initName`. Subsequent reads from it will return its default value.
  mutating func clearInitName() {self._initName = nil}

  /// Parameter to call the `init` of the contract with.
  var parameter: Concordium_V2_Parameter {
    get {return _parameter ?? Concordium_V2_Parameter()}
    set {_parameter = newValue}
  }
  /// Returns true if `parameter` has been explicitly set.
  var hasParameter: Bool {return self._parameter != nil}
  /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
  mutating func clearParameter() {self._parameter = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Concordium_V2_Amount? = nil
  fileprivate var _moduleRef: Concordium_V2_ModuleRef? = nil
  fileprivate var _initName: Concordium_V2_InitName? = nil
  fileprivate var _parameter: Concordium_V2_Parameter? = nil
}

/// Data required to update a contract instance.
struct Concordium_V2_UpdateContractPayload: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Amount of CCD to send to the instance.
  var amount: Concordium_V2_Amount {
    get {return _amount ?? Concordium_V2_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  /// Address of the instance to update.
  var address: Concordium_V2_ContractAddress {
    get {return _address ?? Concordium_V2_ContractAddress()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  mutating func clearAddress() {self._address = nil}

  /// Name of the entrypoint to call to update the instance.
  /// This is expected to be in the format `contractName.entrypointName`.
  var receiveName: Concordium_V2_ReceiveName {
    get {return _receiveName ?? Concordium_V2_ReceiveName()}
    set {_receiveName = newValue}
  }
  /// Returns true if `receiveName` has been explicitly set.
  var hasReceiveName: Bool {return self._receiveName != nil}
  /// Clears the value of `receiveName`. Subsequent reads from it will return its default value.
  mutating func clearReceiveName() {self._receiveName = nil}

  /// Parameter to pass to the entrypoint.
  var parameter: Concordium_V2_Parameter {
    get {return _parameter ?? Concordium_V2_Parameter()}
    set {_parameter = newValue}
  }
  /// Returns true if `parameter` has been explicitly set.
  var hasParameter: Bool {return self._parameter != nil}
  /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
  mutating func clearParameter() {self._parameter = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Concordium_V2_Amount? = nil
  fileprivate var _address: Concordium_V2_ContractAddress? = nil
  fileprivate var _receiveName: Concordium_V2_ReceiveName? = nil
  fileprivate var _parameter: Concordium_V2_Parameter? = nil
}

/// Payload of a transfer between two accounts.
struct Concordium_V2_TransferPayload: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Amount of CCD to send.
  var amount: Concordium_V2_Amount {
    get {return _amount ?? Concordium_V2_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  /// Receiver address.
  var receiver: Concordium_V2_AccountAddress {
    get {return _receiver ?? Concordium_V2_AccountAddress()}
    set {_receiver = newValue}
  }
  /// Returns true if `receiver` has been explicitly set.
  var hasReceiver: Bool {return self._receiver != nil}
  /// Clears the value of `receiver`. Subsequent reads from it will return its default value.
  mutating func clearReceiver() {self._receiver = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Concordium_V2_Amount? = nil
  fileprivate var _receiver: Concordium_V2_AccountAddress? = nil
}

/// Payload of a transfer between two accounts with a memo.
struct Concordium_V2_TransferWithMemoPayload: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Amount of CCD to send.
  var amount: Concordium_V2_Amount {
    get {return _amount ?? Concordium_V2_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  /// Receiver address.
  var receiver: Concordium_V2_AccountAddress {
    get {return _receiver ?? Concordium_V2_AccountAddress()}
    set {_receiver = newValue}
  }
  /// Returns true if `receiver` has been explicitly set.
  var hasReceiver: Bool {return self._receiver != nil}
  /// Clears the value of `receiver`. Subsequent reads from it will return its default value.
  mutating func clearReceiver() {self._receiver = nil}

  /// Memo to include with the transfer.
  var memo: Concordium_V2_Memo {
    get {return _memo ?? Concordium_V2_Memo()}
    set {_memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  var hasMemo: Bool {return self._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  mutating func clearMemo() {self._memo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Concordium_V2_Amount? = nil
  fileprivate var _receiver: Concordium_V2_AccountAddress? = nil
  fileprivate var _memo: Concordium_V2_Memo? = nil
}

/// The payload for an account transaction.
struct Concordium_V2_AccountTransactionPayload: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Concordium_V2_AccountTransactionPayload.OneOf_Payload? = nil

  /// A pre-serialized payload in the binary serialization format defined
  /// by the protocol.
  var rawPayload: Data {
    get {
      if case .rawPayload(let v)? = payload {return v}
      return Data()
    }
    set {payload = .rawPayload(newValue)}
  }

  /// A transfer between two accounts. With an optional memo.
  var deployModule: Concordium_V2_VersionedModuleSource {
    get {
      if case .deployModule(let v)? = payload {return v}
      return Concordium_V2_VersionedModuleSource()
    }
    set {payload = .deployModule(newValue)}
  }

  var initContract: Concordium_V2_InitContractPayload {
    get {
      if case .initContract(let v)? = payload {return v}
      return Concordium_V2_InitContractPayload()
    }
    set {payload = .initContract(newValue)}
  }

  var updateContract: Concordium_V2_UpdateContractPayload {
    get {
      if case .updateContract(let v)? = payload {return v}
      return Concordium_V2_UpdateContractPayload()
    }
    set {payload = .updateContract(newValue)}
  }

  var transfer: Concordium_V2_TransferPayload {
    get {
      if case .transfer(let v)? = payload {return v}
      return Concordium_V2_TransferPayload()
    }
    set {payload = .transfer(newValue)}
  }

  var transferWithMemo: Concordium_V2_TransferWithMemoPayload {
    get {
      if case .transferWithMemo(let v)? = payload {return v}
      return Concordium_V2_TransferWithMemoPayload()
    }
    set {payload = .transferWithMemo(newValue)}
  }

  var registerData: Concordium_V2_RegisteredData {
    get {
      if case .registerData(let v)? = payload {return v}
      return Concordium_V2_RegisteredData()
    }
    set {payload = .registerData(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, @unchecked Sendable {
    /// A pre-serialized payload in the binary serialization format defined
    /// by the protocol.
    case rawPayload(Data)
    /// A transfer between two accounts. With an optional memo.
    case deployModule(Concordium_V2_VersionedModuleSource)
    case initContract(Concordium_V2_InitContractPayload)
    case updateContract(Concordium_V2_UpdateContractPayload)
    case transfer(Concordium_V2_TransferPayload)
    case transferWithMemo(Concordium_V2_TransferWithMemoPayload)
    case registerData(Concordium_V2_RegisteredData)

  }

  init() {}
}

/// An unsigned account transaction. This is used with the
/// `GetTransactionSignHash` endpoint to obtain the message to sign.
struct Concordium_V2_PreAccountTransaction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: Concordium_V2_AccountTransactionHeader {
    get {return _header ?? Concordium_V2_AccountTransactionHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var payload: Concordium_V2_AccountTransactionPayload {
    get {return _payload ?? Concordium_V2_AccountTransactionPayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _header: Concordium_V2_AccountTransactionHeader? = nil
  fileprivate var _payload: Concordium_V2_AccountTransactionPayload? = nil
}

/// Account transactions are messages which are signed and paid for by the sender
/// account.
struct Concordium_V2_AccountTransaction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signature: Concordium_V2_AccountTransactionSignature {
    get {return _signature ?? Concordium_V2_AccountTransactionSignature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  mutating func clearSignature() {self._signature = nil}

  var header: Concordium_V2_AccountTransactionHeader {
    get {return _header ?? Concordium_V2_AccountTransactionHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var payload: Concordium_V2_AccountTransactionPayload {
    get {return _payload ?? Concordium_V2_AccountTransactionPayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signature: Concordium_V2_AccountTransactionSignature? = nil
  fileprivate var _header: Concordium_V2_AccountTransactionHeader? = nil
  fileprivate var _payload: Concordium_V2_AccountTransactionPayload? = nil
}

struct Concordium_V2_UpdateInstructionHeader: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequenceNumber: Concordium_V2_UpdateSequenceNumber {
    get {return _sequenceNumber ?? Concordium_V2_UpdateSequenceNumber()}
    set {_sequenceNumber = newValue}
  }
  /// Returns true if `sequenceNumber` has been explicitly set.
  var hasSequenceNumber: Bool {return self._sequenceNumber != nil}
  /// Clears the value of `sequenceNumber`. Subsequent reads from it will return its default value.
  mutating func clearSequenceNumber() {self._sequenceNumber = nil}

  var effectiveTime: Concordium_V2_TransactionTime {
    get {return _effectiveTime ?? Concordium_V2_TransactionTime()}
    set {_effectiveTime = newValue}
  }
  /// Returns true if `effectiveTime` has been explicitly set.
  var hasEffectiveTime: Bool {return self._effectiveTime != nil}
  /// Clears the value of `effectiveTime`. Subsequent reads from it will return its default value.
  mutating func clearEffectiveTime() {self._effectiveTime = nil}

  var timeout: Concordium_V2_TransactionTime {
    get {return _timeout ?? Concordium_V2_TransactionTime()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  mutating func clearTimeout() {self._timeout = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sequenceNumber: Concordium_V2_UpdateSequenceNumber? = nil
  fileprivate var _effectiveTime: Concordium_V2_TransactionTime? = nil
  fileprivate var _timeout: Concordium_V2_TransactionTime? = nil
}

/// The payload for an UpdateInstruction.
struct Concordium_V2_UpdateInstructionPayload: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Concordium_V2_UpdateInstructionPayload.OneOf_Payload? = nil

  /// A raw payload encoded according to the format defined by the protocol.
  var rawPayload: Data {
    get {
      if case .rawPayload(let v)? = payload {return v}
      return Data()
    }
    set {payload = .rawPayload(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable, @unchecked Sendable {
    /// A raw payload encoded according to the format defined by the protocol.
    case rawPayload(Data)

  }

  init() {}
}

struct Concordium_V2_UpdateInstruction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A map from `UpdateKeysIndex` to `Signature`. Keys must not exceed 2^16.
  var signatures: Concordium_V2_SignatureMap {
    get {return _signatures ?? Concordium_V2_SignatureMap()}
    set {_signatures = newValue}
  }
  /// Returns true if `signatures` has been explicitly set.
  var hasSignatures: Bool {return self._signatures != nil}
  /// Clears the value of `signatures`. Subsequent reads from it will return its default value.
  mutating func clearSignatures() {self._signatures = nil}

  var header: Concordium_V2_UpdateInstructionHeader {
    get {return _header ?? Concordium_V2_UpdateInstructionHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  var payload: Concordium_V2_UpdateInstructionPayload {
    get {return _payload ?? Concordium_V2_UpdateInstructionPayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signatures: Concordium_V2_SignatureMap? = nil
  fileprivate var _header: Concordium_V2_UpdateInstructionHeader? = nil
  fileprivate var _payload: Concordium_V2_UpdateInstructionPayload? = nil
}

/// Signature on an account transaction is defined to be the signature on the
/// hash of the `PreAccountTransaction`.
struct Concordium_V2_AccountTransactionSignHash: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The number of credential deployments allowed in a block. This in effect
/// determines the number of accounts that can be created in a block.
struct Concordium_V2_CredentialsPerBlockLimit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Updatable chain parameters that apply to protocol versions 1-3.
struct Concordium_V2_ChainParametersV0: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Election difficulty for consensus lottery.
  var electionDifficulty: Concordium_V2_ElectionDifficulty {
    get {return _storage._electionDifficulty ?? Concordium_V2_ElectionDifficulty()}
    set {_uniqueStorage()._electionDifficulty = newValue}
  }
  /// Returns true if `electionDifficulty` has been explicitly set.
  var hasElectionDifficulty: Bool {return _storage._electionDifficulty != nil}
  /// Clears the value of `electionDifficulty`. Subsequent reads from it will return its default value.
  mutating func clearElectionDifficulty() {_uniqueStorage()._electionDifficulty = nil}

  /// Euro per energy exchange rate.
  var euroPerEnergy: Concordium_V2_ExchangeRate {
    get {return _storage._euroPerEnergy ?? Concordium_V2_ExchangeRate()}
    set {_uniqueStorage()._euroPerEnergy = newValue}
  }
  /// Returns true if `euroPerEnergy` has been explicitly set.
  var hasEuroPerEnergy: Bool {return _storage._euroPerEnergy != nil}
  /// Clears the value of `euroPerEnergy`. Subsequent reads from it will return its default value.
  mutating func clearEuroPerEnergy() {_uniqueStorage()._euroPerEnergy = nil}

  /// Micro CCD per euro exchange rate.
  var microCcdPerEuro: Concordium_V2_ExchangeRate {
    get {return _storage._microCcdPerEuro ?? Concordium_V2_ExchangeRate()}
    set {_uniqueStorage()._microCcdPerEuro = newValue}
  }
  /// Returns true if `microCcdPerEuro` has been explicitly set.
  var hasMicroCcdPerEuro: Bool {return _storage._microCcdPerEuro != nil}
  /// Clears the value of `microCcdPerEuro`. Subsequent reads from it will return its default value.
  mutating func clearMicroCcdPerEuro() {_uniqueStorage()._microCcdPerEuro = nil}

  /// Extra number of epochs before reduction in stake, or baker
  /// deregistration is completed.
  var bakerCooldownEpochs: Concordium_V2_Epoch {
    get {return _storage._bakerCooldownEpochs ?? Concordium_V2_Epoch()}
    set {_uniqueStorage()._bakerCooldownEpochs = newValue}
  }
  /// Returns true if `bakerCooldownEpochs` has been explicitly set.
  var hasBakerCooldownEpochs: Bool {return _storage._bakerCooldownEpochs != nil}
  /// Clears the value of `bakerCooldownEpochs`. Subsequent reads from it will return its default value.
  mutating func clearBakerCooldownEpochs() {_uniqueStorage()._bakerCooldownEpochs = nil}

  /// The limit for the number of account creations in a block.
  var accountCreationLimit: Concordium_V2_CredentialsPerBlockLimit {
    get {return _storage._accountCreationLimit ?? Concordium_V2_CredentialsPerBlockLimit()}
    set {_uniqueStorage()._accountCreationLimit = newValue}
  }
  /// Returns true if `accountCreationLimit` has been explicitly set.
  var hasAccountCreationLimit: Bool {return _storage._accountCreationLimit != nil}
  /// Clears the value of `accountCreationLimit`. Subsequent reads from it will return its default value.
  mutating func clearAccountCreationLimit() {_uniqueStorage()._accountCreationLimit = nil}

  /// Current mint distribution
  var mintDistribution: Concordium_V2_MintDistributionCpv0 {
    get {return _storage._mintDistribution ?? Concordium_V2_MintDistributionCpv0()}
    set {_uniqueStorage()._mintDistribution = newValue}
  }
  /// Returns true if `mintDistribution` has been explicitly set.
  var hasMintDistribution: Bool {return _storage._mintDistribution != nil}
  /// Clears the value of `mintDistribution`. Subsequent reads from it will return its default value.
  mutating func clearMintDistribution() {_uniqueStorage()._mintDistribution = nil}

  /// Current transaction fee distribution.
  var transactionFeeDistribution: Concordium_V2_TransactionFeeDistribution {
    get {return _storage._transactionFeeDistribution ?? Concordium_V2_TransactionFeeDistribution()}
    set {_uniqueStorage()._transactionFeeDistribution = newValue}
  }
  /// Returns true if `transactionFeeDistribution` has been explicitly set.
  var hasTransactionFeeDistribution: Bool {return _storage._transactionFeeDistribution != nil}
  /// Clears the value of `transactionFeeDistribution`. Subsequent reads from it will return its default value.
  mutating func clearTransactionFeeDistribution() {_uniqueStorage()._transactionFeeDistribution = nil}

  /// Current gas reward parameters.
  var gasRewards: Concordium_V2_GasRewards {
    get {return _storage._gasRewards ?? Concordium_V2_GasRewards()}
    set {_uniqueStorage()._gasRewards = newValue}
  }
  /// Returns true if `gasRewards` has been explicitly set.
  var hasGasRewards: Bool {return _storage._gasRewards != nil}
  /// Clears the value of `gasRewards`. Subsequent reads from it will return its default value.
  mutating func clearGasRewards() {_uniqueStorage()._gasRewards = nil}

  /// The foundation account.
  var foundationAccount: Concordium_V2_AccountAddress {
    get {return _storage._foundationAccount ?? Concordium_V2_AccountAddress()}
    set {_uniqueStorage()._foundationAccount = newValue}
  }
  /// Returns true if `foundationAccount` has been explicitly set.
  var hasFoundationAccount: Bool {return _storage._foundationAccount != nil}
  /// Clears the value of `foundationAccount`. Subsequent reads from it will return its default value.
  mutating func clearFoundationAccount() {_uniqueStorage()._foundationAccount = nil}

  /// Minimum threshold for becoming a baker.
  var minimumThresholdForBaking: Concordium_V2_Amount {
    get {return _storage._minimumThresholdForBaking ?? Concordium_V2_Amount()}
    set {_uniqueStorage()._minimumThresholdForBaking = newValue}
  }
  /// Returns true if `minimumThresholdForBaking` has been explicitly set.
  var hasMinimumThresholdForBaking: Bool {return _storage._minimumThresholdForBaking != nil}
  /// Clears the value of `minimumThresholdForBaking`. Subsequent reads from it will return its default value.
  mutating func clearMinimumThresholdForBaking() {_uniqueStorage()._minimumThresholdForBaking = nil}

  /// Keys allowed to do root updates.
  var rootKeys: Concordium_V2_HigherLevelKeys {
    get {return _storage._rootKeys ?? Concordium_V2_HigherLevelKeys()}
    set {_uniqueStorage()._rootKeys = newValue}
  }
  /// Returns true if `rootKeys` has been explicitly set.
  var hasRootKeys: Bool {return _storage._rootKeys != nil}
  /// Clears the value of `rootKeys`. Subsequent reads from it will return its default value.
  mutating func clearRootKeys() {_uniqueStorage()._rootKeys = nil}

  /// Keys allowed to do level1 updates;
  var level1Keys: Concordium_V2_HigherLevelKeys {
    get {return _storage._level1Keys ?? Concordium_V2_HigherLevelKeys()}
    set {_uniqueStorage()._level1Keys = newValue}
  }
  /// Returns true if `level1Keys` has been explicitly set.
  var hasLevel1Keys: Bool {return _storage._level1Keys != nil}
  /// Clears the value of `level1Keys`. Subsequent reads from it will return its default value.
  mutating func clearLevel1Keys() {_uniqueStorage()._level1Keys = nil}

  /// Keys allowed to do parameter updates.
  var level2Keys: Concordium_V2_AuthorizationsV0 {
    get {return _storage._level2Keys ?? Concordium_V2_AuthorizationsV0()}
    set {_uniqueStorage()._level2Keys = newValue}
  }
  /// Returns true if `level2Keys` has been explicitly set.
  var hasLevel2Keys: Bool {return _storage._level2Keys != nil}
  /// Clears the value of `level2Keys`. Subsequent reads from it will return its default value.
  mutating func clearLevel2Keys() {_uniqueStorage()._level2Keys = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Updatable chain parameters that apply to protocol versions 4-5.
struct Concordium_V2_ChainParametersV1: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Election difficulty for consensus lottery.
  var electionDifficulty: Concordium_V2_ElectionDifficulty {
    get {return _storage._electionDifficulty ?? Concordium_V2_ElectionDifficulty()}
    set {_uniqueStorage()._electionDifficulty = newValue}
  }
  /// Returns true if `electionDifficulty` has been explicitly set.
  var hasElectionDifficulty: Bool {return _storage._electionDifficulty != nil}
  /// Clears the value of `electionDifficulty`. Subsequent reads from it will return its default value.
  mutating func clearElectionDifficulty() {_uniqueStorage()._electionDifficulty = nil}

  /// Euro per energy exchange rate.
  var euroPerEnergy: Concordium_V2_ExchangeRate {
    get {return _storage._euroPerEnergy ?? Concordium_V2_ExchangeRate()}
    set {_uniqueStorage()._euroPerEnergy = newValue}
  }
  /// Returns true if `euroPerEnergy` has been explicitly set.
  var hasEuroPerEnergy: Bool {return _storage._euroPerEnergy != nil}
  /// Clears the value of `euroPerEnergy`. Subsequent reads from it will return its default value.
  mutating func clearEuroPerEnergy() {_uniqueStorage()._euroPerEnergy = nil}

  /// Micro CCD per euro exchange rate.
  var microCcdPerEuro: Concordium_V2_ExchangeRate {
    get {return _storage._microCcdPerEuro ?? Concordium_V2_ExchangeRate()}
    set {_uniqueStorage()._microCcdPerEuro = newValue}
  }
  /// Returns true if `microCcdPerEuro` has been explicitly set.
  var hasMicroCcdPerEuro: Bool {return _storage._microCcdPerEuro != nil}
  /// Clears the value of `microCcdPerEuro`. Subsequent reads from it will return its default value.
  mutating func clearMicroCcdPerEuro() {_uniqueStorage()._microCcdPerEuro = nil}

  /// Extra number of epochs before reduction in stake, or baker
  /// deregistration is completed.
  var cooldownParameters: Concordium_V2_CooldownParametersCpv1 {
    get {return _storage._cooldownParameters ?? Concordium_V2_CooldownParametersCpv1()}
    set {_uniqueStorage()._cooldownParameters = newValue}
  }
  /// Returns true if `cooldownParameters` has been explicitly set.
  var hasCooldownParameters: Bool {return _storage._cooldownParameters != nil}
  /// Clears the value of `cooldownParameters`. Subsequent reads from it will return its default value.
  mutating func clearCooldownParameters() {_uniqueStorage()._cooldownParameters = nil}

  /// Current time parameters.
  /// The time parameters indicates the mint rate and the
  /// reward period length, i.e. the time between paydays.
  var timeParameters: Concordium_V2_TimeParametersCpv1 {
    get {return _storage._timeParameters ?? Concordium_V2_TimeParametersCpv1()}
    set {_uniqueStorage()._timeParameters = newValue}
  }
  /// Returns true if `timeParameters` has been explicitly set.
  var hasTimeParameters: Bool {return _storage._timeParameters != nil}
  /// Clears the value of `timeParameters`. Subsequent reads from it will return its default value.
  mutating func clearTimeParameters() {_uniqueStorage()._timeParameters = nil}

  /// The limit for the number of account creations in a block.
  var accountCreationLimit: Concordium_V2_CredentialsPerBlockLimit {
    get {return _storage._accountCreationLimit ?? Concordium_V2_CredentialsPerBlockLimit()}
    set {_uniqueStorage()._accountCreationLimit = newValue}
  }
  /// Returns true if `accountCreationLimit` has been explicitly set.
  var hasAccountCreationLimit: Bool {return _storage._accountCreationLimit != nil}
  /// Clears the value of `accountCreationLimit`. Subsequent reads from it will return its default value.
  mutating func clearAccountCreationLimit() {_uniqueStorage()._accountCreationLimit = nil}

  /// Current mint distribution
  var mintDistribution: Concordium_V2_MintDistributionCpv1 {
    get {return _storage._mintDistribution ?? Concordium_V2_MintDistributionCpv1()}
    set {_uniqueStorage()._mintDistribution = newValue}
  }
  /// Returns true if `mintDistribution` has been explicitly set.
  var hasMintDistribution: Bool {return _storage._mintDistribution != nil}
  /// Clears the value of `mintDistribution`. Subsequent reads from it will return its default value.
  mutating func clearMintDistribution() {_uniqueStorage()._mintDistribution = nil}

  /// Current transaction fee distribution.
  var transactionFeeDistribution: Concordium_V2_TransactionFeeDistribution {
    get {return _storage._transactionFeeDistribution ?? Concordium_V2_TransactionFeeDistribution()}
    set {_uniqueStorage()._transactionFeeDistribution = newValue}
  }
  /// Returns true if `transactionFeeDistribution` has been explicitly set.
  var hasTransactionFeeDistribution: Bool {return _storage._transactionFeeDistribution != nil}
  /// Clears the value of `transactionFeeDistribution`. Subsequent reads from it will return its default value.
  mutating func clearTransactionFeeDistribution() {_uniqueStorage()._transactionFeeDistribution = nil}

  /// Current gas reward parameters.
  var gasRewards: Concordium_V2_GasRewards {
    get {return _storage._gasRewards ?? Concordium_V2_GasRewards()}
    set {_uniqueStorage()._gasRewards = newValue}
  }
  /// Returns true if `gasRewards` has been explicitly set.
  var hasGasRewards: Bool {return _storage._gasRewards != nil}
  /// Clears the value of `gasRewards`. Subsequent reads from it will return its default value.
  mutating func clearGasRewards() {_uniqueStorage()._gasRewards = nil}

  /// The foundation account.
  var foundationAccount: Concordium_V2_AccountAddress {
    get {return _storage._foundationAccount ?? Concordium_V2_AccountAddress()}
    set {_uniqueStorage()._foundationAccount = newValue}
  }
  /// Returns true if `foundationAccount` has been explicitly set.
  var hasFoundationAccount: Bool {return _storage._foundationAccount != nil}
  /// Clears the value of `foundationAccount`. Subsequent reads from it will return its default value.
  mutating func clearFoundationAccount() {_uniqueStorage()._foundationAccount = nil}

  /// Parameters governing baking pools and their commissions.
  var poolParameters: Concordium_V2_PoolParametersCpv1 {
    get {return _storage._poolParameters ?? Concordium_V2_PoolParametersCpv1()}
    set {_uniqueStorage()._poolParameters = newValue}
  }
  /// Returns true if `poolParameters` has been explicitly set.
  var hasPoolParameters: Bool {return _storage._poolParameters != nil}
  /// Clears the value of `poolParameters`. Subsequent reads from it will return its default value.
  mutating func clearPoolParameters() {_uniqueStorage()._poolParameters = nil}

  /// Keys allowed to do root updates.
  var rootKeys: Concordium_V2_HigherLevelKeys {
    get {return _storage._rootKeys ?? Concordium_V2_HigherLevelKeys()}
    set {_uniqueStorage()._rootKeys = newValue}
  }
  /// Returns true if `rootKeys` has been explicitly set.
  var hasRootKeys: Bool {return _storage._rootKeys != nil}
  /// Clears the value of `rootKeys`. Subsequent reads from it will return its default value.
  mutating func clearRootKeys() {_uniqueStorage()._rootKeys = nil}

  /// Keys allowed to do level1 updates;
  var level1Keys: Concordium_V2_HigherLevelKeys {
    get {return _storage._level1Keys ?? Concordium_V2_HigherLevelKeys()}
    set {_uniqueStorage()._level1Keys = newValue}
  }
  /// Returns true if `level1Keys` has been explicitly set.
  var hasLevel1Keys: Bool {return _storage._level1Keys != nil}
  /// Clears the value of `level1Keys`. Subsequent reads from it will return its default value.
  mutating func clearLevel1Keys() {_uniqueStorage()._level1Keys = nil}

  /// Keys allowed to do parameter updates.
  var level2Keys: Concordium_V2_AuthorizationsV1 {
    get {return _storage._level2Keys ?? Concordium_V2_AuthorizationsV1()}
    set {_uniqueStorage()._level2Keys = newValue}
  }
  /// Returns true if `level2Keys` has been explicitly set.
  var hasLevel2Keys: Bool {return _storage._level2Keys != nil}
  /// Clears the value of `level2Keys`. Subsequent reads from it will return its default value.
  mutating func clearLevel2Keys() {_uniqueStorage()._level2Keys = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Updatable chain parameters that apply to protocol versions 6.
struct Concordium_V2_ChainParametersV2: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Consensus parameters.
  var consensusParameters: Concordium_V2_ConsensusParametersV1 {
    get {return _storage._consensusParameters ?? Concordium_V2_ConsensusParametersV1()}
    set {_uniqueStorage()._consensusParameters = newValue}
  }
  /// Returns true if `consensusParameters` has been explicitly set.
  var hasConsensusParameters: Bool {return _storage._consensusParameters != nil}
  /// Clears the value of `consensusParameters`. Subsequent reads from it will return its default value.
  mutating func clearConsensusParameters() {_uniqueStorage()._consensusParameters = nil}

  /// Euro per energy exchange rate.
  var euroPerEnergy: Concordium_V2_ExchangeRate {
    get {return _storage._euroPerEnergy ?? Concordium_V2_ExchangeRate()}
    set {_uniqueStorage()._euroPerEnergy = newValue}
  }
  /// Returns true if `euroPerEnergy` has been explicitly set.
  var hasEuroPerEnergy: Bool {return _storage._euroPerEnergy != nil}
  /// Clears the value of `euroPerEnergy`. Subsequent reads from it will return its default value.
  mutating func clearEuroPerEnergy() {_uniqueStorage()._euroPerEnergy = nil}

  /// Micro CCD per euro exchange rate.
  var microCcdPerEuro: Concordium_V2_ExchangeRate {
    get {return _storage._microCcdPerEuro ?? Concordium_V2_ExchangeRate()}
    set {_uniqueStorage()._microCcdPerEuro = newValue}
  }
  /// Returns true if `microCcdPerEuro` has been explicitly set.
  var hasMicroCcdPerEuro: Bool {return _storage._microCcdPerEuro != nil}
  /// Clears the value of `microCcdPerEuro`. Subsequent reads from it will return its default value.
  mutating func clearMicroCcdPerEuro() {_uniqueStorage()._microCcdPerEuro = nil}

  /// Extra number of epochs before reduction in stake, or baker
  /// deregistration is completed.
  var cooldownParameters: Concordium_V2_CooldownParametersCpv1 {
    get {return _storage._cooldownParameters ?? Concordium_V2_CooldownParametersCpv1()}
    set {_uniqueStorage()._cooldownParameters = newValue}
  }
  /// Returns true if `cooldownParameters` has been explicitly set.
  var hasCooldownParameters: Bool {return _storage._cooldownParameters != nil}
  /// Clears the value of `cooldownParameters`. Subsequent reads from it will return its default value.
  mutating func clearCooldownParameters() {_uniqueStorage()._cooldownParameters = nil}

  /// Current time parameters.
  /// The time parameters indicates the mint rate and the
  /// reward period length, i.e. the time between paydays.
  var timeParameters: Concordium_V2_TimeParametersCpv1 {
    get {return _storage._timeParameters ?? Concordium_V2_TimeParametersCpv1()}
    set {_uniqueStorage()._timeParameters = newValue}
  }
  /// Returns true if `timeParameters` has been explicitly set.
  var hasTimeParameters: Bool {return _storage._timeParameters != nil}
  /// Clears the value of `timeParameters`. Subsequent reads from it will return its default value.
  mutating func clearTimeParameters() {_uniqueStorage()._timeParameters = nil}

  /// The limit for the number of account creations in a block.
  var accountCreationLimit: Concordium_V2_CredentialsPerBlockLimit {
    get {return _storage._accountCreationLimit ?? Concordium_V2_CredentialsPerBlockLimit()}
    set {_uniqueStorage()._accountCreationLimit = newValue}
  }
  /// Returns true if `accountCreationLimit` has been explicitly set.
  var hasAccountCreationLimit: Bool {return _storage._accountCreationLimit != nil}
  /// Clears the value of `accountCreationLimit`. Subsequent reads from it will return its default value.
  mutating func clearAccountCreationLimit() {_uniqueStorage()._accountCreationLimit = nil}

  /// Current mint distribution
  var mintDistribution: Concordium_V2_MintDistributionCpv1 {
    get {return _storage._mintDistribution ?? Concordium_V2_MintDistributionCpv1()}
    set {_uniqueStorage()._mintDistribution = newValue}
  }
  /// Returns true if `mintDistribution` has been explicitly set.
  var hasMintDistribution: Bool {return _storage._mintDistribution != nil}
  /// Clears the value of `mintDistribution`. Subsequent reads from it will return its default value.
  mutating func clearMintDistribution() {_uniqueStorage()._mintDistribution = nil}

  /// Current transaction fee distribution.
  var transactionFeeDistribution: Concordium_V2_TransactionFeeDistribution {
    get {return _storage._transactionFeeDistribution ?? Concordium_V2_TransactionFeeDistribution()}
    set {_uniqueStorage()._transactionFeeDistribution = newValue}
  }
  /// Returns true if `transactionFeeDistribution` has been explicitly set.
  var hasTransactionFeeDistribution: Bool {return _storage._transactionFeeDistribution != nil}
  /// Clears the value of `transactionFeeDistribution`. Subsequent reads from it will return its default value.
  mutating func clearTransactionFeeDistribution() {_uniqueStorage()._transactionFeeDistribution = nil}

  /// Current gas reward parameters.
  var gasRewards: Concordium_V2_GasRewardsCpv2 {
    get {return _storage._gasRewards ?? Concordium_V2_GasRewardsCpv2()}
    set {_uniqueStorage()._gasRewards = newValue}
  }
  /// Returns true if `gasRewards` has been explicitly set.
  var hasGasRewards: Bool {return _storage._gasRewards != nil}
  /// Clears the value of `gasRewards`. Subsequent reads from it will return its default value.
  mutating func clearGasRewards() {_uniqueStorage()._gasRewards = nil}

  /// The foundation account.
  var foundationAccount: Concordium_V2_AccountAddress {
    get {return _storage._foundationAccount ?? Concordium_V2_AccountAddress()}
    set {_uniqueStorage()._foundationAccount = newValue}
  }
  /// Returns true if `foundationAccount` has been explicitly set.
  var hasFoundationAccount: Bool {return _storage._foundationAccount != nil}
  /// Clears the value of `foundationAccount`. Subsequent reads from it will return its default value.
  mutating func clearFoundationAccount() {_uniqueStorage()._foundationAccount = nil}

  /// Parameters governing baking pools and their commissions.
  var poolParameters: Concordium_V2_PoolParametersCpv1 {
    get {return _storage._poolParameters ?? Concordium_V2_PoolParametersCpv1()}
    set {_uniqueStorage()._poolParameters = newValue}
  }
  /// Returns true if `poolParameters` has been explicitly set.
  var hasPoolParameters: Bool {return _storage._poolParameters != nil}
  /// Clears the value of `poolParameters`. Subsequent reads from it will return its default value.
  mutating func clearPoolParameters() {_uniqueStorage()._poolParameters = nil}

  /// Keys allowed to do root updates.
  var rootKeys: Concordium_V2_HigherLevelKeys {
    get {return _storage._rootKeys ?? Concordium_V2_HigherLevelKeys()}
    set {_uniqueStorage()._rootKeys = newValue}
  }
  /// Returns true if `rootKeys` has been explicitly set.
  var hasRootKeys: Bool {return _storage._rootKeys != nil}
  /// Clears the value of `rootKeys`. Subsequent reads from it will return its default value.
  mutating func clearRootKeys() {_uniqueStorage()._rootKeys = nil}

  /// Keys allowed to do level1 updates;
  var level1Keys: Concordium_V2_HigherLevelKeys {
    get {return _storage._level1Keys ?? Concordium_V2_HigherLevelKeys()}
    set {_uniqueStorage()._level1Keys = newValue}
  }
  /// Returns true if `level1Keys` has been explicitly set.
  var hasLevel1Keys: Bool {return _storage._level1Keys != nil}
  /// Clears the value of `level1Keys`. Subsequent reads from it will return its default value.
  mutating func clearLevel1Keys() {_uniqueStorage()._level1Keys = nil}

  /// Keys allowed to do parameter updates.
  var level2Keys: Concordium_V2_AuthorizationsV1 {
    get {return _storage._level2Keys ?? Concordium_V2_AuthorizationsV1()}
    set {_uniqueStorage()._level2Keys = newValue}
  }
  /// Returns true if `level2Keys` has been explicitly set.
  var hasLevel2Keys: Bool {return _storage._level2Keys != nil}
  /// Clears the value of `level2Keys`. Subsequent reads from it will return its default value.
  mutating func clearLevel2Keys() {_uniqueStorage()._level2Keys = nil}

  /// Finalization committee parameters
  var finalizationCommitteeParameters: Concordium_V2_FinalizationCommitteeParameters {
    get {return _storage._finalizationCommitteeParameters ?? Concordium_V2_FinalizationCommitteeParameters()}
    set {_uniqueStorage()._finalizationCommitteeParameters = newValue}
  }
  /// Returns true if `finalizationCommitteeParameters` has been explicitly set.
  var hasFinalizationCommitteeParameters: Bool {return _storage._finalizationCommitteeParameters != nil}
  /// Clears the value of `finalizationCommitteeParameters`. Subsequent reads from it will return its default value.
  mutating func clearFinalizationCommitteeParameters() {_uniqueStorage()._finalizationCommitteeParameters = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Chain parameters.
struct Concordium_V2_ChainParameters: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parameters: Concordium_V2_ChainParameters.OneOf_Parameters? = nil

  /// Chain parameters that apply when the block is a protocol version 1-3 block.
  var v0: Concordium_V2_ChainParametersV0 {
    get {
      if case .v0(let v)? = parameters {return v}
      return Concordium_V2_ChainParametersV0()
    }
    set {parameters = .v0(newValue)}
  }

  /// Chain parameters that apply when the block is a protocol version 4-5 block.
  var v1: Concordium_V2_ChainParametersV1 {
    get {
      if case .v1(let v)? = parameters {return v}
      return Concordium_V2_ChainParametersV1()
    }
    set {parameters = .v1(newValue)}
  }

  /// Chain parameters that apply when the block is a protocol version 6- block.
  var v2: Concordium_V2_ChainParametersV2 {
    get {
      if case .v2(let v)? = parameters {return v}
      return Concordium_V2_ChainParametersV2()
    }
    set {parameters = .v2(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Parameters: Equatable, Sendable {
    /// Chain parameters that apply when the block is a protocol version 1-3 block.
    case v0(Concordium_V2_ChainParametersV0)
    /// Chain parameters that apply when the block is a protocol version 4-5 block.
    case v1(Concordium_V2_ChainParametersV1)
    /// Chain parameters that apply when the block is a protocol version 6- block.
    case v2(Concordium_V2_ChainParametersV2)

  }

  init() {}
}

/// Details about a finalizer for the finalization round.
struct Concordium_V2_FinalizationSummaryParty: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Baker ID. Every finalizer is in particular a baker.
  var baker: Concordium_V2_BakerId {
    get {return _baker ?? Concordium_V2_BakerId()}
    set {_baker = newValue}
  }
  /// Returns true if `baker` has been explicitly set.
  var hasBaker: Bool {return self._baker != nil}
  /// Clears the value of `baker`. Subsequent reads from it will return its default value.
  mutating func clearBaker() {self._baker = nil}

  /// The weight of the finalizer in the committee. This is an "absolute" weight.
  var weight: UInt64 = 0

  /// Whether the finalizer's signature was present on the particular finalization record.
  var signed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baker: Concordium_V2_BakerId? = nil
}

/// Index of the finalization round. This increases on each successfully
/// completed finalization.
struct Concordium_V2_FinalizationIndex: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Details about a finalization record included in a block.
struct Concordium_V2_FinalizationSummary: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Block that was finalized by the finalization record.
  var block: Concordium_V2_BlockHash {
    get {return _block ?? Concordium_V2_BlockHash()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {self._block = nil}

  /// Index of the finalization round that finalized the block.
  var index: Concordium_V2_FinalizationIndex {
    get {return _index ?? Concordium_V2_FinalizationIndex()}
    set {_index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  var hasIndex: Bool {return self._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  mutating func clearIndex() {self._index = nil}

  /// Finalization delay used for the finalization round.
  var delay: Concordium_V2_BlockHeight {
    get {return _delay ?? Concordium_V2_BlockHeight()}
    set {_delay = newValue}
  }
  /// Returns true if `delay` has been explicitly set.
  var hasDelay: Bool {return self._delay != nil}
  /// Clears the value of `delay`. Subsequent reads from it will return its default value.
  mutating func clearDelay() {self._delay = nil}

  /// List of all finalizers with information about whether they signed the
  /// finalization record or not.
  var finalizers: [Concordium_V2_FinalizationSummaryParty] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _block: Concordium_V2_BlockHash? = nil
  fileprivate var _index: Concordium_V2_FinalizationIndex? = nil
  fileprivate var _delay: Concordium_V2_BlockHeight? = nil
}

/// Finalization summary that may or may not be part of the block.
struct Concordium_V2_BlockFinalizationSummary: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var summary: Concordium_V2_BlockFinalizationSummary.OneOf_Summary? = nil

  /// There is no finalization data in the block.
  var none: Concordium_V2_Empty {
    get {
      if case .none(let v)? = summary {return v}
      return Concordium_V2_Empty()
    }
    set {summary = .none(newValue)}
  }

  /// There is a single finalization record with the block.
  var record: Concordium_V2_FinalizationSummary {
    get {
      if case .record(let v)? = summary {return v}
      return Concordium_V2_FinalizationSummary()
    }
    set {summary = .record(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Summary: Equatable, Sendable {
    /// There is no finalization data in the block.
    case none(Concordium_V2_Empty)
    /// There is a single finalization record with the block.
    case record(Concordium_V2_FinalizationSummary)

  }

  init() {}
}

struct Concordium_V2_BlockItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hash of the block item that identifies it to the chain.
  var hash: Concordium_V2_TransactionHash {
    get {return _hash ?? Concordium_V2_TransactionHash()}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  var blockItem: Concordium_V2_BlockItem.OneOf_BlockItem? = nil

  /// Account transactions are messages which are signed and paid for by an account.
  var accountTransaction: Concordium_V2_AccountTransaction {
    get {
      if case .accountTransaction(let v)? = blockItem {return v}
      return Concordium_V2_AccountTransaction()
    }
    set {blockItem = .accountTransaction(newValue)}
  }

  /// Credential deployments create new accounts. They are not paid for
  /// directly by the sender. Instead, bakers are rewarded by the protocol for
  /// including them.
  var credentialDeployment: Concordium_V2_CredentialDeployment {
    get {
      if case .credentialDeployment(let v)? = blockItem {return v}
      return Concordium_V2_CredentialDeployment()
    }
    set {blockItem = .credentialDeployment(newValue)}
  }

  /// Update instructions are messages which can update the chain parameters. Including which keys are allowed
  /// to make future update instructions.
  var updateInstruction: Concordium_V2_UpdateInstruction {
    get {
      if case .updateInstruction(let v)? = blockItem {return v}
      return Concordium_V2_UpdateInstruction()
    }
    set {blockItem = .updateInstruction(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_BlockItem: Equatable, Sendable {
    /// Account transactions are messages which are signed and paid for by an account.
    case accountTransaction(Concordium_V2_AccountTransaction)
    /// Credential deployments create new accounts. They are not paid for
    /// directly by the sender. Instead, bakers are rewarded by the protocol for
    /// including them.
    case credentialDeployment(Concordium_V2_CredentialDeployment)
    /// Update instructions are messages which can update the chain parameters. Including which keys are allowed
    /// to make future update instructions.
    case updateInstruction(Concordium_V2_UpdateInstruction)

  }

  init() {}

  fileprivate var _hash: Concordium_V2_TransactionHash? = nil
}

/// Information about a particular baker with respect to
/// the current reward period.
struct Concordium_V2_BakerRewardPeriodInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The baker id and public keys for the baker.
  var baker: Concordium_V2_BakerInfo {
    get {return _baker ?? Concordium_V2_BakerInfo()}
    set {_baker = newValue}
  }
  /// Returns true if `baker` has been explicitly set.
  var hasBaker: Bool {return self._baker != nil}
  /// Clears the value of `baker`. Subsequent reads from it will return its default value.
  mutating func clearBaker() {self._baker = nil}

  /// The effective stake of the baker for the consensus protocol.
  /// The returned amount accounts for delegation, capital bounds and leverage bounds.
  var effectiveStake: Concordium_V2_Amount {
    get {return _effectiveStake ?? Concordium_V2_Amount()}
    set {_effectiveStake = newValue}
  }
  /// Returns true if `effectiveStake` has been explicitly set.
  var hasEffectiveStake: Bool {return self._effectiveStake != nil}
  /// Clears the value of `effectiveStake`. Subsequent reads from it will return its default value.
  mutating func clearEffectiveStake() {self._effectiveStake = nil}

  /// The effective commission rate for the baker that applies for the reward period.
  var commissionRates: Concordium_V2_CommissionRates {
    get {return _commissionRates ?? Concordium_V2_CommissionRates()}
    set {_commissionRates = newValue}
  }
  /// Returns true if `commissionRates` has been explicitly set.
  var hasCommissionRates: Bool {return self._commissionRates != nil}
  /// Clears the value of `commissionRates`. Subsequent reads from it will return its default value.
  mutating func clearCommissionRates() {self._commissionRates = nil}

  /// The amount staked by the baker itself.
  var equityCapital: Concordium_V2_Amount {
    get {return _equityCapital ?? Concordium_V2_Amount()}
    set {_equityCapital = newValue}
  }
  /// Returns true if `equityCapital` has been explicitly set.
  var hasEquityCapital: Bool {return self._equityCapital != nil}
  /// Clears the value of `equityCapital`. Subsequent reads from it will return its default value.
  mutating func clearEquityCapital() {self._equityCapital = nil}

  /// The total amount of capital delegated to this baker pool.
  var delegatedCapital: Concordium_V2_Amount {
    get {return _delegatedCapital ?? Concordium_V2_Amount()}
    set {_delegatedCapital = newValue}
  }
  /// Returns true if `delegatedCapital` has been explicitly set.
  var hasDelegatedCapital: Bool {return self._delegatedCapital != nil}
  /// Clears the value of `delegatedCapital`. Subsequent reads from it will return its default value.
  mutating func clearDelegatedCapital() {self._delegatedCapital = nil}

  /// Whether the baker is a finalizer or not.
  var isFinalizer: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _baker: Concordium_V2_BakerInfo? = nil
  fileprivate var _effectiveStake: Concordium_V2_Amount? = nil
  fileprivate var _commissionRates: Concordium_V2_CommissionRates? = nil
  fileprivate var _equityCapital: Concordium_V2_Amount? = nil
  fileprivate var _delegatedCapital: Concordium_V2_Amount? = nil
}

/// The signature of a 'QuorumCertificate'.
struct Concordium_V2_QuorumSignature: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The bytes representing the raw aggregate signature.
  /// The bytes have a fixed length of 48 bytes.
  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A quorum certificate is the certificate that the
/// finalization comittee issues in order to certify a block.
/// A block must be certified before it will be part of the
/// authorative part of the chain.
struct Concordium_V2_QuorumCertificate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hash of the block that the quorum certificate refers to.
  var blockHash: Concordium_V2_BlockHash {
    get {return _blockHash ?? Concordium_V2_BlockHash()}
    set {_blockHash = newValue}
  }
  /// Returns true if `blockHash` has been explicitly set.
  var hasBlockHash: Bool {return self._blockHash != nil}
  /// Clears the value of `blockHash`. Subsequent reads from it will return its default value.
  mutating func clearBlockHash() {self._blockHash = nil}

  /// The round of the block.
  var round: Concordium_V2_Round {
    get {return _round ?? Concordium_V2_Round()}
    set {_round = newValue}
  }
  /// Returns true if `round` has been explicitly set.
  var hasRound: Bool {return self._round != nil}
  /// Clears the value of `round`. Subsequent reads from it will return its default value.
  mutating func clearRound() {self._round = nil}

  /// The epoch of the block.
  var epoch: Concordium_V2_Epoch {
    get {return _epoch ?? Concordium_V2_Epoch()}
    set {_epoch = newValue}
  }
  /// Returns true if `epoch` has been explicitly set.
  var hasEpoch: Bool {return self._epoch != nil}
  /// Clears the value of `epoch`. Subsequent reads from it will return its default value.
  mutating func clearEpoch() {self._epoch = nil}

  /// The aggregated signature by the finalization committee on the block.
  var aggregateSignature: Concordium_V2_QuorumSignature {
    get {return _aggregateSignature ?? Concordium_V2_QuorumSignature()}
    set {_aggregateSignature = newValue}
  }
  /// Returns true if `aggregateSignature` has been explicitly set.
  var hasAggregateSignature: Bool {return self._aggregateSignature != nil}
  /// Clears the value of `aggregateSignature`. Subsequent reads from it will return its default value.
  mutating func clearAggregateSignature() {self._aggregateSignature = nil}

  /// A list of the finalizers that formed the quorum certificate
  /// i.e., the ones who have contributed to the 'aggregate_siganture'.
  /// The finalizers are identified by their baker id as this is stable
  /// across protocols and epochs.
  var signatories: [Concordium_V2_BakerId] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockHash: Concordium_V2_BlockHash? = nil
  fileprivate var _round: Concordium_V2_Round? = nil
  fileprivate var _epoch: Concordium_V2_Epoch? = nil
  fileprivate var _aggregateSignature: Concordium_V2_QuorumSignature? = nil
}

/// The finalizer round is a map from a 'Round'
/// to the list of finalizers (identified by their 'BakerId') that signed
/// off the round.
struct Concordium_V2_FinalizerRound: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The round that was signed off.
  var round: Concordium_V2_Round {
    get {return _round ?? Concordium_V2_Round()}
    set {_round = newValue}
  }
  /// Returns true if `round` has been explicitly set.
  var hasRound: Bool {return self._round != nil}
  /// Clears the value of `round`. Subsequent reads from it will return its default value.
  mutating func clearRound() {self._round = nil}

  /// The finalizers (identified by their 'BakerId' that
  /// signed off the in 'round'.
  var finalizers: [Concordium_V2_BakerId] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _round: Concordium_V2_Round? = nil
}

/// The signature of a 'TimeoutCertificate'.
struct Concordium_V2_TimeoutSignature: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The bytes representing the raw aggregate signature.
  /// The bytes have a fixed length of 48 bytes.
  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A timeout certificate is the certificate that the
/// finalization committee issues when a round times out,
/// thus making it possible for the protocol to proceed to the
/// next round.
struct Concordium_V2_TimeoutCertificate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The round that timed out.
  var round: Concordium_V2_Round {
    get {return _round ?? Concordium_V2_Round()}
    set {_round = newValue}
  }
  /// Returns true if `round` has been explicitly set.
  var hasRound: Bool {return self._round != nil}
  /// Clears the value of `round`. Subsequent reads from it will return its default value.
  mutating func clearRound() {self._round = nil}

  /// The minimum epoch of which signatures are included
  /// in the 'aggregate_signature'.
  var minEpoch: Concordium_V2_Epoch {
    get {return _minEpoch ?? Concordium_V2_Epoch()}
    set {_minEpoch = newValue}
  }
  /// Returns true if `minEpoch` has been explicitly set.
  var hasMinEpoch: Bool {return self._minEpoch != nil}
  /// Clears the value of `minEpoch`. Subsequent reads from it will return its default value.
  mutating func clearMinEpoch() {self._minEpoch = nil}

  /// The rounds of which finalizers have their best
  /// QCs in the 'min_epoch'.
  var qcRoundsFirstEpoch: [Concordium_V2_FinalizerRound] = []

  /// The rounds of which finalizers have their best
  /// QCs in the epoch 'min_epoch' + 1.
  var qcRoundsSecondEpoch: [Concordium_V2_FinalizerRound] = []

  /// The aggregated signature by the finalization committee that witnessed
  /// the 'round' timed out.
  var aggregateSignature: Concordium_V2_TimeoutSignature {
    get {return _aggregateSignature ?? Concordium_V2_TimeoutSignature()}
    set {_aggregateSignature = newValue}
  }
  /// Returns true if `aggregateSignature` has been explicitly set.
  var hasAggregateSignature: Bool {return self._aggregateSignature != nil}
  /// Clears the value of `aggregateSignature`. Subsequent reads from it will return its default value.
  mutating func clearAggregateSignature() {self._aggregateSignature = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _round: Concordium_V2_Round? = nil
  fileprivate var _minEpoch: Concordium_V2_Epoch? = nil
  fileprivate var _aggregateSignature: Concordium_V2_TimeoutSignature? = nil
}

/// A proof that establishes that the successor block of
/// a 'EpochFinalizationEntry' is the immediate successor of
/// the finalized block.
struct Concordium_V2_SuccessorProof: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The proof represented as raw bytes.
  /// The bytes have a fixed length of 32 bytes.
  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The epoch finalization entry is the proof that
/// makes the protocol able to advance to a new epoch.
/// I.e. the 'EpochFinalizationEntry' is present if and only if
/// the block is the first block of a new 'Epoch'.
struct Concordium_V2_EpochFinalizationEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The quorum certificate for the finalized block.
  var finalizedQc: Concordium_V2_QuorumCertificate {
    get {return _finalizedQc ?? Concordium_V2_QuorumCertificate()}
    set {_finalizedQc = newValue}
  }
  /// Returns true if `finalizedQc` has been explicitly set.
  var hasFinalizedQc: Bool {return self._finalizedQc != nil}
  /// Clears the value of `finalizedQc`. Subsequent reads from it will return its default value.
  mutating func clearFinalizedQc() {self._finalizedQc = nil}

  /// The quorum certificate for the block that finalizes
  /// the block that 'finalized_qc' points to.
  var successorQc: Concordium_V2_QuorumCertificate {
    get {return _successorQc ?? Concordium_V2_QuorumCertificate()}
    set {_successorQc = newValue}
  }
  /// Returns true if `successorQc` has been explicitly set.
  var hasSuccessorQc: Bool {return self._successorQc != nil}
  /// Clears the value of `successorQc`. Subsequent reads from it will return its default value.
  mutating func clearSuccessorQc() {self._successorQc = nil}

  /// A proof that the successor block is an immediate
  /// successor of the finalized block.
  var successorProof: Concordium_V2_SuccessorProof {
    get {return _successorProof ?? Concordium_V2_SuccessorProof()}
    set {_successorProof = newValue}
  }
  /// Returns true if `successorProof` has been explicitly set.
  var hasSuccessorProof: Bool {return self._successorProof != nil}
  /// Clears the value of `successorProof`. Subsequent reads from it will return its default value.
  mutating func clearSuccessorProof() {self._successorProof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _finalizedQc: Concordium_V2_QuorumCertificate? = nil
  fileprivate var _successorQc: Concordium_V2_QuorumCertificate? = nil
  fileprivate var _successorProof: Concordium_V2_SuccessorProof? = nil
}

/// Certificates for a block for protocols supporting
/// ConcordiumBFT.
struct Concordium_V2_BlockCertificates: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The quorum certificate. Is present if and only if the block is
  /// not a genesis block.
  var quorumCertificate: Concordium_V2_QuorumCertificate {
    get {return _storage._quorumCertificate ?? Concordium_V2_QuorumCertificate()}
    set {_uniqueStorage()._quorumCertificate = newValue}
  }
  /// Returns true if `quorumCertificate` has been explicitly set.
  var hasQuorumCertificate: Bool {return _storage._quorumCertificate != nil}
  /// Clears the value of `quorumCertificate`. Subsequent reads from it will return its default value.
  mutating func clearQuorumCertificate() {_uniqueStorage()._quorumCertificate = nil}

  /// The timeout certificate. Is present only if the round prior to the
  /// round of the block timed out.
  var timeoutCertificate: Concordium_V2_TimeoutCertificate {
    get {return _storage._timeoutCertificate ?? Concordium_V2_TimeoutCertificate()}
    set {_uniqueStorage()._timeoutCertificate = newValue}
  }
  /// Returns true if `timeoutCertificate` has been explicitly set.
  var hasTimeoutCertificate: Bool {return _storage._timeoutCertificate != nil}
  /// Clears the value of `timeoutCertificate`. Subsequent reads from it will return its default value.
  mutating func clearTimeoutCertificate() {_uniqueStorage()._timeoutCertificate = nil}

  /// The epoch finalization entry. Is present only if the block initiates
  /// a new epoch.
  var epochFinalizationEntry: Concordium_V2_EpochFinalizationEntry {
    get {return _storage._epochFinalizationEntry ?? Concordium_V2_EpochFinalizationEntry()}
    set {_uniqueStorage()._epochFinalizationEntry = newValue}
  }
  /// Returns true if `epochFinalizationEntry` has been explicitly set.
  var hasEpochFinalizationEntry: Bool {return _storage._epochFinalizationEntry != nil}
  /// Clears the value of `epochFinalizationEntry`. Subsequent reads from it will return its default value.
  mutating func clearEpochFinalizationEntry() {_uniqueStorage()._epochFinalizationEntry = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Details of which baker won the lottery in a given round in consensus version 1.
struct Concordium_V2_WinningBaker: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The round number.
  var round: Concordium_V2_Round {
    get {return _round ?? Concordium_V2_Round()}
    set {_round = newValue}
  }
  /// Returns true if `round` has been explicitly set.
  var hasRound: Bool {return self._round != nil}
  /// Clears the value of `round`. Subsequent reads from it will return its default value.
  mutating func clearRound() {self._round = nil}

  /// The baker that won the round.
  var winner: Concordium_V2_BakerId {
    get {return _winner ?? Concordium_V2_BakerId()}
    set {_winner = newValue}
  }
  /// Returns true if `winner` has been explicitly set.
  var hasWinner: Bool {return self._winner != nil}
  /// Clears the value of `winner`. Subsequent reads from it will return its default value.
  mutating func clearWinner() {self._winner = nil}

  /// True if the baker produced a block in this round on the finalized chain, and False otherwise.
  var present: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _round: Concordium_V2_Round? = nil
  fileprivate var _winner: Concordium_V2_BakerId? = nil
}

/// An operation to dry run.  The first operation in a dry-run sequence should be
/// `load_block_state`: any other operation will be met with `NoState` until a
/// state is successfully loaded.
struct Concordium_V2_DryRunRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: Concordium_V2_DryRunRequest.OneOf_Request? = nil

  /// Load the state of the specified block to use for subsequent requests.
  /// The state is taken at the end of execution of the block, and the block’s
  /// timestamp is used as the current timestamp.
  ///
  /// The energy cost for this operation is 2000.
  var loadBlockState: Concordium_V2_BlockHashInput {
    get {
      if case .loadBlockState(let v)? = request {return v}
      return Concordium_V2_BlockHashInput()
    }
    set {request = .loadBlockState(newValue)}
  }

  /// Run a query on the state.
  var stateQuery: Concordium_V2_DryRunStateQuery {
    get {
      if case .stateQuery(let v)? = request {return v}
      return Concordium_V2_DryRunStateQuery()
    }
    set {request = .stateQuery(newValue)}
  }

  /// Run a (non-transaction) operation to modify the state.
  var stateOperation: Concordium_V2_DryRunStateOperation {
    get {
      if case .stateOperation(let v)? = request {return v}
      return Concordium_V2_DryRunStateOperation()
    }
    set {request = .stateOperation(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    /// Load the state of the specified block to use for subsequent requests.
    /// The state is taken at the end of execution of the block, and the block’s
    /// timestamp is used as the current timestamp.
    ///
    /// The energy cost for this operation is 2000.
    case loadBlockState(Concordium_V2_BlockHashInput)
    /// Run a query on the state.
    case stateQuery(Concordium_V2_DryRunStateQuery)
    /// Run a (non-transaction) operation to modify the state.
    case stateOperation(Concordium_V2_DryRunStateOperation)

  }

  init() {}
}

/// Run a query as part of a dry run. Queries do not update the block state.
struct Concordium_V2_DryRunStateQuery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var query: Concordium_V2_DryRunStateQuery.OneOf_Query? = nil

  /// Look up information on a particular account.
  ///
  /// The energy cost for this query is 200.
  var getAccountInfo: Concordium_V2_AccountIdentifierInput {
    get {
      if case .getAccountInfo(let v)? = query {return v}
      return Concordium_V2_AccountIdentifierInput()
    }
    set {query = .getAccountInfo(newValue)}
  }

  /// Look up information about a particular smart contract.
  ///
  /// The energy cost for this query is 200.
  var getInstanceInfo: Concordium_V2_ContractAddress {
    get {
      if case .getInstanceInfo(let v)? = query {return v}
      return Concordium_V2_ContractAddress()
    }
    set {query = .getInstanceInfo(newValue)}
  }

  /// Invoke an entrypoint on a smart contract instance.
  /// No changes made to the state are retained at the completion of the operation.
  ///
  /// The energy cost for this query is 200 plus the energy used by the smart contract
  /// execution.
  var invokeInstance: Concordium_V2_DryRunInvokeInstance {
    get {
      if case .invokeInstance(let v)? = query {return v}
      return Concordium_V2_DryRunInvokeInstance()
    }
    set {query = .invokeInstance(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Query: Equatable, Sendable {
    /// Look up information on a particular account.
    ///
    /// The energy cost for this query is 200.
    case getAccountInfo(Concordium_V2_AccountIdentifierInput)
    /// Look up information about a particular smart contract.
    ///
    /// The energy cost for this query is 200.
    case getInstanceInfo(Concordium_V2_ContractAddress)
    /// Invoke an entrypoint on a smart contract instance.
    /// No changes made to the state are retained at the completion of the operation.
    ///
    /// The energy cost for this query is 200 plus the energy used by the smart contract
    /// execution.
    case invokeInstance(Concordium_V2_DryRunInvokeInstance)

  }

  init() {}
}

/// Invoke an entrypoint on a smart contract instance.
struct Concordium_V2_DryRunInvokeInstance: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Invoker of the contract. If this is not supplied then the contract will be
  /// invoked by an account with address 0, no credentials and sufficient amount
  /// of CCD to cover the transfer amount. If given, the relevant address (either
  /// account or contract) must exist in the blockstate.
  var invoker: Concordium_V2_Address {
    get {return _invoker ?? Concordium_V2_Address()}
    set {_invoker = newValue}
  }
  /// Returns true if `invoker` has been explicitly set.
  var hasInvoker: Bool {return self._invoker != nil}
  /// Clears the value of `invoker`. Subsequent reads from it will return its default value.
  mutating func clearInvoker() {self._invoker = nil}

  /// Address of the contract instance to invoke.
  var instance: Concordium_V2_ContractAddress {
    get {return _instance ?? Concordium_V2_ContractAddress()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  mutating func clearInstance() {self._instance = nil}

  /// Amount to invoke the smart contract instance with.
  var amount: Concordium_V2_Amount {
    get {return _amount ?? Concordium_V2_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  /// The entrypoint of the smart contract instance to invoke.
  var entrypoint: Concordium_V2_ReceiveName {
    get {return _entrypoint ?? Concordium_V2_ReceiveName()}
    set {_entrypoint = newValue}
  }
  /// Returns true if `entrypoint` has been explicitly set.
  var hasEntrypoint: Bool {return self._entrypoint != nil}
  /// Clears the value of `entrypoint`. Subsequent reads from it will return its default value.
  mutating func clearEntrypoint() {self._entrypoint = nil}

  /// The parameter bytes to include in the invocation of the entrypoint.
  var parameter: Concordium_V2_Parameter {
    get {return _parameter ?? Concordium_V2_Parameter()}
    set {_parameter = newValue}
  }
  /// Returns true if `parameter` has been explicitly set.
  var hasParameter: Bool {return self._parameter != nil}
  /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
  mutating func clearParameter() {self._parameter = nil}

  /// The maximum energy to allow for the invocation. Note that the node imposes an energy
  /// quota that is enforced in addition to this limit.
  var energy: Concordium_V2_Energy {
    get {return _energy ?? Concordium_V2_Energy()}
    set {_energy = newValue}
  }
  /// Returns true if `energy` has been explicitly set.
  var hasEnergy: Bool {return self._energy != nil}
  /// Clears the value of `energy`. Subsequent reads from it will return its default value.
  mutating func clearEnergy() {self._energy = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _invoker: Concordium_V2_Address? = nil
  fileprivate var _instance: Concordium_V2_ContractAddress? = nil
  fileprivate var _amount: Concordium_V2_Amount? = nil
  fileprivate var _entrypoint: Concordium_V2_ReceiveName? = nil
  fileprivate var _parameter: Concordium_V2_Parameter? = nil
  fileprivate var _energy: Concordium_V2_Energy? = nil
}

/// An operation that can update the state as part of a dry run.
struct Concordium_V2_DryRunStateOperation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operation: Concordium_V2_DryRunStateOperation.OneOf_Operation? = nil

  /// Sets the current block time to the given timestamp for the purposes of future
  /// transactions.
  ///
  /// The energy cost of this operation is 50.
  var setTimestamp: Concordium_V2_Timestamp {
    get {
      if case .setTimestamp(let v)? = operation {return v}
      return Concordium_V2_Timestamp()
    }
    set {operation = .setTimestamp(newValue)}
  }

  /// Add a specified amount of newly-minted CCDs to a specified account.
  /// The amount cannot cause the total circulating supply to overflow.
  ///
  /// The energy cost of this operation is 400.
  var mintToAccount: Concordium_V2_DryRunMintToAccount {
    get {
      if case .mintToAccount(let v)? = operation {return v}
      return Concordium_V2_DryRunMintToAccount()
    }
    set {operation = .mintToAccount(newValue)}
  }

  /// Dry run a transaction, updating the state if it succeeds.
  ///
  /// The energy cost of this operation is 400 plus the energy used by executing the
  /// transaction.
  var runTransaction: Concordium_V2_DryRunTransaction {
    get {
      if case .runTransaction(let v)? = operation {return v}
      return Concordium_V2_DryRunTransaction()
    }
    set {operation = .runTransaction(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Operation: Equatable, Sendable {
    /// Sets the current block time to the given timestamp for the purposes of future
    /// transactions.
    ///
    /// The energy cost of this operation is 50.
    case setTimestamp(Concordium_V2_Timestamp)
    /// Add a specified amount of newly-minted CCDs to a specified account.
    /// The amount cannot cause the total circulating supply to overflow.
    ///
    /// The energy cost of this operation is 400.
    case mintToAccount(Concordium_V2_DryRunMintToAccount)
    /// Dry run a transaction, updating the state if it succeeds.
    ///
    /// The energy cost of this operation is 400 plus the energy used by executing the
    /// transaction.
    case runTransaction(Concordium_V2_DryRunTransaction)

  }

  init() {}
}

/// Mint a specified amount and credit it to the specified account as part of a dry run.
struct Concordium_V2_DryRunMintToAccount: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account to mint to.
  var account: Concordium_V2_AccountAddress {
    get {return _account ?? Concordium_V2_AccountAddress()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  /// The amount to mint and credit to the account.
  var amount: Concordium_V2_Amount {
    get {return _amount ?? Concordium_V2_Amount()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: Concordium_V2_AccountAddress? = nil
  fileprivate var _amount: Concordium_V2_Amount? = nil
}

/// Dry run an account transaction
struct Concordium_V2_DryRunTransaction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account to use as the sender of the transaction.
  var sender: Concordium_V2_AccountAddress {
    get {return _sender ?? Concordium_V2_AccountAddress()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  mutating func clearSender() {self._sender = nil}

  /// The energy limit set for executing the transaction.
  var energyAmount: Concordium_V2_Energy {
    get {return _energyAmount ?? Concordium_V2_Energy()}
    set {_energyAmount = newValue}
  }
  /// Returns true if `energyAmount` has been explicitly set.
  var hasEnergyAmount: Bool {return self._energyAmount != nil}
  /// Clears the value of `energyAmount`. Subsequent reads from it will return its default value.
  mutating func clearEnergyAmount() {self._energyAmount = nil}

  /// The payload of the transaction.
  var payload: Concordium_V2_AccountTransactionPayload {
    get {return _payload ?? Concordium_V2_AccountTransactionPayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  /// Which credentials and keys should be treated as having signed the transaction.
  /// If none is given, then the transaction is treated as having one signature for credential 0,
  /// key 0. Therefore, this is only required when the transaction is from a multi-signature
  /// account. There are two reasons why you might want to specify signatures:
  ///   * The cost of the transaction depends on the number of signatures, so if you want to
  ///     get the correct cost for a multi-signature transaction, then specifying the signatures
  ///     supports this.
  ///   * When changing account keys on a multi-credential account, the transaction must be signed
  ///     by the credential whose keys are being changed.
  ///
  /// Note that the signature thresholds are not checked as part of the dry run. Duplicated
  /// signatures are only counted once.
  var signatures: [Concordium_V2_DryRunSignature] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sender: Concordium_V2_AccountAddress? = nil
  fileprivate var _energyAmount: Concordium_V2_Energy? = nil
  fileprivate var _payload: Concordium_V2_AccountTransactionPayload? = nil
}

/// A dry run signature is a pair of a credential index and key index, identifying the credential
/// and key that is presumed to have signed the transaction. No actual cryptographic signature is
/// included.
struct Concordium_V2_DryRunSignature: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Credential index. Must not exceed 255.
  var credential: UInt32 = 0

  /// Key index. Must not exceed 255.
  var key: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A response to a `DryRunRequest`.
struct Concordium_V2_DryRunResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Concordium_V2_DryRunResponse.OneOf_Response? = nil

  /// The request produced an error. The request otherwise has no effect on the state.
  var error: Concordium_V2_DryRunErrorResponse {
    get {
      if case .error(let v)? = response {return v}
      return Concordium_V2_DryRunErrorResponse()
    }
    set {response = .error(newValue)}
  }

  /// The request was successful.
  var success: Concordium_V2_DryRunSuccessResponse {
    get {
      if case .success(let v)? = response {return v}
      return Concordium_V2_DryRunSuccessResponse()
    }
    set {response = .success(newValue)}
  }

  /// The remaining available energy quota after the dry run operation.
  var quotaRemaining: Concordium_V2_Energy {
    get {return _quotaRemaining ?? Concordium_V2_Energy()}
    set {_quotaRemaining = newValue}
  }
  /// Returns true if `quotaRemaining` has been explicitly set.
  var hasQuotaRemaining: Bool {return self._quotaRemaining != nil}
  /// Clears the value of `quotaRemaining`. Subsequent reads from it will return its default value.
  mutating func clearQuotaRemaining() {self._quotaRemaining = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    /// The request produced an error. The request otherwise has no effect on the state.
    case error(Concordium_V2_DryRunErrorResponse)
    /// The request was successful.
    case success(Concordium_V2_DryRunSuccessResponse)

  }

  init() {}

  fileprivate var _quotaRemaining: Concordium_V2_Energy? = nil
}

struct Concordium_V2_DryRunErrorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: Concordium_V2_DryRunErrorResponse.OneOf_Error? = nil

  /// The current block state is undefined. It should be initialized with
  /// a 'load_block_state' request before any other operations.
  var noState: Concordium_V2_DryRunErrorResponse.NoState {
    get {
      if case .noState(let v)? = error {return v}
      return Concordium_V2_DryRunErrorResponse.NoState()
    }
    set {error = .noState(newValue)}
  }

  /// The requested block was not found, so its state could not be loaded.
  /// Response to 'load_block_state'.
  var blockNotFound: Concordium_V2_DryRunErrorResponse.BlockNotFound {
    get {
      if case .blockNotFound(let v)? = error {return v}
      return Concordium_V2_DryRunErrorResponse.BlockNotFound()
    }
    set {error = .blockNotFound(newValue)}
  }

  /// The specified account was not found.
  /// Response to 'get_account_info', 'mint_to_account' and 'run_transaction'.
  var accountNotFound: Concordium_V2_DryRunErrorResponse.AccountNotFound {
    get {
      if case .accountNotFound(let v)? = error {return v}
      return Concordium_V2_DryRunErrorResponse.AccountNotFound()
    }
    set {error = .accountNotFound(newValue)}
  }

  /// The specified instance was not found.
  /// Response to 'get_instance_info'.
  var instanceNotFound: Concordium_V2_DryRunErrorResponse.InstanceNotFound {
    get {
      if case .instanceNotFound(let v)? = error {return v}
      return Concordium_V2_DryRunErrorResponse.InstanceNotFound()
    }
    set {error = .instanceNotFound(newValue)}
  }

  /// The amount to mint would overflow the total CCD supply.
  /// Response to 'mint_to_account'.
  var amountOverLimit: Concordium_V2_DryRunErrorResponse.AmountOverLimit {
    get {
      if case .amountOverLimit(let v)? = error {return v}
      return Concordium_V2_DryRunErrorResponse.AmountOverLimit()
    }
    set {error = .amountOverLimit(newValue)}
  }

  /// The balance of the sender account is not sufficient to pay for the operation.
  /// Response to 'run_transaction'.
  var balanceInsufficient: Concordium_V2_DryRunErrorResponse.BalanceInsufficient {
    get {
      if case .balanceInsufficient(let v)? = error {return v}
      return Concordium_V2_DryRunErrorResponse.BalanceInsufficient()
    }
    set {error = .balanceInsufficient(newValue)}
  }

  /// The energy supplied for the transaction was not sufficient to perform the basic checks.
  /// Response to 'run_transaction'.
  var energyInsufficient: Concordium_V2_DryRunErrorResponse.EnergyInsufficient {
    get {
      if case .energyInsufficient(let v)? = error {return v}
      return Concordium_V2_DryRunErrorResponse.EnergyInsufficient()
    }
    set {error = .energyInsufficient(newValue)}
  }

  /// The contract invocation failed.
  /// Response to 'invoke_instance'.
  var invokeFailed: Concordium_V2_DryRunErrorResponse.InvokeFailure {
    get {
      if case .invokeFailed(let v)? = error {return v}
      return Concordium_V2_DryRunErrorResponse.InvokeFailure()
    }
    set {error = .invokeFailed(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Error: Equatable, Sendable {
    /// The current block state is undefined. It should be initialized with
    /// a 'load_block_state' request before any other operations.
    case noState(Concordium_V2_DryRunErrorResponse.NoState)
    /// The requested block was not found, so its state could not be loaded.
    /// Response to 'load_block_state'.
    case blockNotFound(Concordium_V2_DryRunErrorResponse.BlockNotFound)
    /// The specified account was not found.
    /// Response to 'get_account_info', 'mint_to_account' and 'run_transaction'.
    case accountNotFound(Concordium_V2_DryRunErrorResponse.AccountNotFound)
    /// The specified instance was not found.
    /// Response to 'get_instance_info'.
    case instanceNotFound(Concordium_V2_DryRunErrorResponse.InstanceNotFound)
    /// The amount to mint would overflow the total CCD supply.
    /// Response to 'mint_to_account'.
    case amountOverLimit(Concordium_V2_DryRunErrorResponse.AmountOverLimit)
    /// The balance of the sender account is not sufficient to pay for the operation.
    /// Response to 'run_transaction'.
    case balanceInsufficient(Concordium_V2_DryRunErrorResponse.BalanceInsufficient)
    /// The energy supplied for the transaction was not sufficient to perform the basic checks.
    /// Response to 'run_transaction'.
    case energyInsufficient(Concordium_V2_DryRunErrorResponse.EnergyInsufficient)
    /// The contract invocation failed.
    /// Response to 'invoke_instance'.
    case invokeFailed(Concordium_V2_DryRunErrorResponse.InvokeFailure)

  }

  /// The current block state is undefined. It should be initialized with
  /// a 'load_block_state' request before any other operations.
  struct NoState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// The requested block was not found, so its state could not be loaded.
  struct BlockNotFound: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// The specified account was not found.
  struct AccountNotFound: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// The specified instance was not found.
  struct InstanceNotFound: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// The amount that was requested to be minted would overflow the total supply.
  struct AmountOverLimit: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The maximum amount that can be minted without overflowing the supply.
    var amountLimit: Concordium_V2_Amount {
      get {return _amountLimit ?? Concordium_V2_Amount()}
      set {_amountLimit = newValue}
    }
    /// Returns true if `amountLimit` has been explicitly set.
    var hasAmountLimit: Bool {return self._amountLimit != nil}
    /// Clears the value of `amountLimit`. Subsequent reads from it will return its default value.
    mutating func clearAmountLimit() {self._amountLimit = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _amountLimit: Concordium_V2_Amount? = nil
  }

  /// The sender account for the transaction has insufficient balance to pay the preliminary fees
  /// for the transaction to be included in a block.
  struct BalanceInsufficient: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The minimum balance required to perform the operation.
    var requiredAmount: Concordium_V2_Amount {
      get {return _requiredAmount ?? Concordium_V2_Amount()}
      set {_requiredAmount = newValue}
    }
    /// Returns true if `requiredAmount` has been explicitly set.
    var hasRequiredAmount: Bool {return self._requiredAmount != nil}
    /// Clears the value of `requiredAmount`. Subsequent reads from it will return its default value.
    mutating func clearRequiredAmount() {self._requiredAmount = nil}

    /// The currently-available balance on the account to pay for the operation.
    var availableAmount: Concordium_V2_Amount {
      get {return _availableAmount ?? Concordium_V2_Amount()}
      set {_availableAmount = newValue}
    }
    /// Returns true if `availableAmount` has been explicitly set.
    var hasAvailableAmount: Bool {return self._availableAmount != nil}
    /// Clears the value of `availableAmount`. Subsequent reads from it will return its default value.
    mutating func clearAvailableAmount() {self._availableAmount = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _requiredAmount: Concordium_V2_Amount? = nil
    fileprivate var _availableAmount: Concordium_V2_Amount? = nil
  }

  /// The energy made available for the transaction is insufficient to cover the basic processing
  /// required to include a transaction in a block.
  struct EnergyInsufficient: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The minimum energy required for the transaction to be included in the chain.
    /// Note that, even if the energy supplied for the transaction is enough to prevent a
    /// `EnergyInsufficient`, the transaction can still be rejected for having
    /// insufficient energy. In that case, a `TransactionExecuted` response will be
    /// produced, but indicate the transaction was rejected.
    var energyRequired: Concordium_V2_Energy {
      get {return _energyRequired ?? Concordium_V2_Energy()}
      set {_energyRequired = newValue}
    }
    /// Returns true if `energyRequired` has been explicitly set.
    var hasEnergyRequired: Bool {return self._energyRequired != nil}
    /// Clears the value of `energyRequired`. Subsequent reads from it will return its default value.
    mutating func clearEnergyRequired() {self._energyRequired = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _energyRequired: Concordium_V2_Energy? = nil
  }

  /// Invoking the smart contract instance failed.
  struct InvokeFailure: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If invoking a V0 contract this is not provided, otherwise it is
    /// potentially return value produced by the call unless the call failed with
    /// out of energy or runtime error. If the V1 contract terminated with a
    /// logic error then the return value is present.
    var returnValue: Data {
      get {return _returnValue ?? Data()}
      set {_returnValue = newValue}
    }
    /// Returns true if `returnValue` has been explicitly set.
    var hasReturnValue: Bool {return self._returnValue != nil}
    /// Clears the value of `returnValue`. Subsequent reads from it will return its default value.
    mutating func clearReturnValue() {self._returnValue = nil}

    /// Energy used by the execution.
    var usedEnergy: Concordium_V2_Energy {
      get {return _usedEnergy ?? Concordium_V2_Energy()}
      set {_usedEnergy = newValue}
    }
    /// Returns true if `usedEnergy` has been explicitly set.
    var hasUsedEnergy: Bool {return self._usedEnergy != nil}
    /// Clears the value of `usedEnergy`. Subsequent reads from it will return its default value.
    mutating func clearUsedEnergy() {self._usedEnergy = nil}

    /// Contract execution failed for the given reason.
    var reason: Concordium_V2_RejectReason {
      get {return _reason ?? Concordium_V2_RejectReason()}
      set {_reason = newValue}
    }
    /// Returns true if `reason` has been explicitly set.
    var hasReason: Bool {return self._reason != nil}
    /// Clears the value of `reason`. Subsequent reads from it will return its default value.
    mutating func clearReason() {self._reason = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _returnValue: Data? = nil
    fileprivate var _usedEnergy: Concordium_V2_Energy? = nil
    fileprivate var _reason: Concordium_V2_RejectReason? = nil
  }

  init() {}
}

/// The dry run operation completed successfully.
struct Concordium_V2_DryRunSuccessResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Concordium_V2_DryRunSuccessResponse.OneOf_Response? = nil

  /// The state from the specified block was successfully loaded.
  /// Response to 'load_block_state'.
  var blockStateLoaded: Concordium_V2_DryRunSuccessResponse.BlockStateLoaded {
    get {
      if case .blockStateLoaded(let v)? = response {return v}
      return Concordium_V2_DryRunSuccessResponse.BlockStateLoaded()
    }
    set {response = .blockStateLoaded(newValue)}
  }

  /// Details of the requested account.
  /// Response to 'get_account_info'.
  var accountInfo: Concordium_V2_AccountInfo {
    get {
      if case .accountInfo(let v)? = response {return v}
      return Concordium_V2_AccountInfo()
    }
    set {response = .accountInfo(newValue)}
  }

  /// Details of the requested smart contract instance.
  /// Response to 'get_instance_info'.
  var instanceInfo: Concordium_V2_InstanceInfo {
    get {
      if case .instanceInfo(let v)? = response {return v}
      return Concordium_V2_InstanceInfo()
    }
    set {response = .instanceInfo(newValue)}
  }

  /// The smart contract instance was invoked successfully.
  var invokeSucceeded: Concordium_V2_DryRunSuccessResponse.InvokeSuccess {
    get {
      if case .invokeSucceeded(let v)? = response {return v}
      return Concordium_V2_DryRunSuccessResponse.InvokeSuccess()
    }
    set {response = .invokeSucceeded(newValue)}
  }

  /// The current timestamp was set successfully.
  /// Response to 'set_timestamp'.
  var timestampSet: Concordium_V2_DryRunSuccessResponse.TimestampSet {
    get {
      if case .timestampSet(let v)? = response {return v}
      return Concordium_V2_DryRunSuccessResponse.TimestampSet()
    }
    set {response = .timestampSet(newValue)}
  }

  /// The specified amount was minted and credited to the account.
  /// Response to 'mint_to_account'.
  var mintedToAccount: Concordium_V2_DryRunSuccessResponse.MintedToAccount {
    get {
      if case .mintedToAccount(let v)? = response {return v}
      return Concordium_V2_DryRunSuccessResponse.MintedToAccount()
    }
    set {response = .mintedToAccount(newValue)}
  }

  /// The specified transaction was executed. Note that the transaction could still have
  /// been rejected.
  /// Response to 'run_transaction'.
  var transactionExecuted: Concordium_V2_DryRunSuccessResponse.TransactionExecuted {
    get {
      if case .transactionExecuted(let v)? = response {return v}
      return Concordium_V2_DryRunSuccessResponse.TransactionExecuted()
    }
    set {response = .transactionExecuted(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    /// The state from the specified block was successfully loaded.
    /// Response to 'load_block_state'.
    case blockStateLoaded(Concordium_V2_DryRunSuccessResponse.BlockStateLoaded)
    /// Details of the requested account.
    /// Response to 'get_account_info'.
    case accountInfo(Concordium_V2_AccountInfo)
    /// Details of the requested smart contract instance.
    /// Response to 'get_instance_info'.
    case instanceInfo(Concordium_V2_InstanceInfo)
    /// The smart contract instance was invoked successfully.
    case invokeSucceeded(Concordium_V2_DryRunSuccessResponse.InvokeSuccess)
    /// The current timestamp was set successfully.
    /// Response to 'set_timestamp'.
    case timestampSet(Concordium_V2_DryRunSuccessResponse.TimestampSet)
    /// The specified amount was minted and credited to the account.
    /// Response to 'mint_to_account'.
    case mintedToAccount(Concordium_V2_DryRunSuccessResponse.MintedToAccount)
    /// The specified transaction was executed. Note that the transaction could still have
    /// been rejected.
    /// Response to 'run_transaction'.
    case transactionExecuted(Concordium_V2_DryRunSuccessResponse.TransactionExecuted)

  }

  /// The block state at the specified block was successfully loaded.
  struct BlockStateLoaded: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The timestamp of the block, taken to be the current timestamp.
    var currentTimestamp: Concordium_V2_Timestamp {
      get {return _currentTimestamp ?? Concordium_V2_Timestamp()}
      set {_currentTimestamp = newValue}
    }
    /// Returns true if `currentTimestamp` has been explicitly set.
    var hasCurrentTimestamp: Bool {return self._currentTimestamp != nil}
    /// Clears the value of `currentTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearCurrentTimestamp() {self._currentTimestamp = nil}

    /// The hash of the block that was loaded.
    var blockHash: Concordium_V2_BlockHash {
      get {return _blockHash ?? Concordium_V2_BlockHash()}
      set {_blockHash = newValue}
    }
    /// Returns true if `blockHash` has been explicitly set.
    var hasBlockHash: Bool {return self._blockHash != nil}
    /// Clears the value of `blockHash`. Subsequent reads from it will return its default value.
    mutating func clearBlockHash() {self._blockHash = nil}

    /// The protocol version at the specified block. The behavior of operations can vary across
    /// protocol versions.
    var protocolVersion: Concordium_V2_ProtocolVersion = .protocolVersion1

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _currentTimestamp: Concordium_V2_Timestamp? = nil
    fileprivate var _blockHash: Concordium_V2_BlockHash? = nil
  }

  /// The current apparent timestamp was updated to the specified value.
  struct TimestampSet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// The specified amount was minted to the specified account.
  struct MintedToAccount: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// The transaction was executed.
  struct TransactionExecuted: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The amount of energy actually expended in executing the transaction.
    var energyCost: Concordium_V2_Energy {
      get {return _energyCost ?? Concordium_V2_Energy()}
      set {_energyCost = newValue}
    }
    /// Returns true if `energyCost` has been explicitly set.
    var hasEnergyCost: Bool {return self._energyCost != nil}
    /// Clears the value of `energyCost`. Subsequent reads from it will return its default value.
    mutating func clearEnergyCost() {self._energyCost = nil}

    /// The details of the outcome of the transaction.
    var details: Concordium_V2_AccountTransactionDetails {
      get {return _details ?? Concordium_V2_AccountTransactionDetails()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    var hasDetails: Bool {return self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    mutating func clearDetails() {self._details = nil}

    /// If this is an invocation of a V1 contract that produced a return value, this is that
    /// value. Otherwise it is absent.
    var returnValue: Data {
      get {return _returnValue ?? Data()}
      set {_returnValue = newValue}
    }
    /// Returns true if `returnValue` has been explicitly set.
    var hasReturnValue: Bool {return self._returnValue != nil}
    /// Clears the value of `returnValue`. Subsequent reads from it will return its default value.
    mutating func clearReturnValue() {self._returnValue = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _energyCost: Concordium_V2_Energy? = nil
    fileprivate var _details: Concordium_V2_AccountTransactionDetails? = nil
    fileprivate var _returnValue: Data? = nil
  }

  /// The smart contract instance was invoked successfully.
  struct InvokeSuccess: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If invoking a V0 contract this is absent. Otherwise it is the return
    /// value produced by the contract.
    var returnValue: Data {
      get {return _returnValue ?? Data()}
      set {_returnValue = newValue}
    }
    /// Returns true if `returnValue` has been explicitly set.
    var hasReturnValue: Bool {return self._returnValue != nil}
    /// Clears the value of `returnValue`. Subsequent reads from it will return its default value.
    mutating func clearReturnValue() {self._returnValue = nil}

    /// Energy used by the execution.
    var usedEnergy: Concordium_V2_Energy {
      get {return _usedEnergy ?? Concordium_V2_Energy()}
      set {_usedEnergy = newValue}
    }
    /// Returns true if `usedEnergy` has been explicitly set.
    var hasUsedEnergy: Bool {return self._usedEnergy != nil}
    /// Clears the value of `usedEnergy`. Subsequent reads from it will return its default value.
    mutating func clearUsedEnergy() {self._usedEnergy = nil}

    /// Effects produced by contract execution.
    var effects: [Concordium_V2_ContractTraceElement] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _returnValue: Data? = nil
    fileprivate var _usedEnergy: Concordium_V2_Energy? = nil
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "concordium.v2"

extension Concordium_V2_OpenStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPEN_STATUS_OPEN_FOR_ALL"),
    1: .same(proto: "OPEN_STATUS_CLOSED_FOR_NEW"),
    2: .same(proto: "OPEN_STATUS_CLOSED_FOR_ALL"),
  ]
}

extension Concordium_V2_ContractVersion: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "V0"),
    1: .same(proto: "V1"),
  ]
}

extension Concordium_V2_CredentialType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CREDENTIAL_TYPE_INITIAL"),
    1: .same(proto: "CREDENTIAL_TYPE_NORMAL"),
  ]
}

extension Concordium_V2_UpdateType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPDATE_PROTOCOL"),
    1: .same(proto: "UPDATE_ELECTION_DIFFICULTY"),
    2: .same(proto: "UPDATE_EURO_PER_ENERGY"),
    3: .same(proto: "UPDATE_MICRO_CCD_PER_EURO"),
    4: .same(proto: "UPDATE_FOUNDATION_ACCOUNT"),
    5: .same(proto: "UPDATE_MINT_DISTRIBUTION"),
    6: .same(proto: "UPDATE_TRANSACTION_FEE_DISTRIBUTION"),
    7: .same(proto: "UPDATE_GAS_REWARDS"),
    8: .same(proto: "UPDATE_POOL_PARAMETERS"),
    9: .same(proto: "ADD_ANONYMITY_REVOKER"),
    10: .same(proto: "ADD_IDENTITY_PROVIDER"),
    11: .same(proto: "UPDATE_ROOT_KEYS"),
    12: .same(proto: "UPDATE_LEVEL1_KEYS"),
    13: .same(proto: "UPDATE_LEVEL2_KEYS"),
    14: .same(proto: "UPDATE_COOLDOWN_PARAMETERS"),
    15: .same(proto: "UPDATE_TIME_PARAMETERS"),
    16: .same(proto: "UPDATE_TIMEOUT_PARAMETERS"),
    17: .same(proto: "UPDATE_MIN_BLOCK_TIME"),
    18: .same(proto: "UPDATE_BLOCK_ENERGY_LIMIT"),
    19: .same(proto: "UPDATE_FINALIZATION_COMMITTEE_PARAMETERS"),
  ]
}

extension Concordium_V2_TransactionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEPLOY_MODULE"),
    1: .same(proto: "INIT_CONTRACT"),
    2: .same(proto: "UPDATE"),
    3: .same(proto: "TRANSFER"),
    4: .same(proto: "ADD_BAKER"),
    5: .same(proto: "REMOVE_BAKER"),
    6: .same(proto: "UPDATE_BAKER_STAKE"),
    7: .same(proto: "UPDATE_BAKER_RESTAKE_EARNINGS"),
    8: .same(proto: "UPDATE_BAKER_KEYS"),
    9: .same(proto: "UPDATE_CREDENTIAL_KEYS"),
    10: .same(proto: "ENCRYPTED_AMOUNT_TRANSFER"),
    11: .same(proto: "TRANSFER_TO_ENCRYPTED"),
    12: .same(proto: "TRANSFER_TO_PUBLIC"),
    13: .same(proto: "TRANSFER_WITH_SCHEDULE"),
    14: .same(proto: "UPDATE_CREDENTIALS"),
    15: .same(proto: "REGISTER_DATA"),
    16: .same(proto: "TRANSFER_WITH_MEMO"),
    17: .same(proto: "ENCRYPTED_AMOUNT_TRANSFER_WITH_MEMO"),
    18: .same(proto: "TRANSFER_WITH_SCHEDULE_AND_MEMO"),
    19: .same(proto: "CONFIGURE_BAKER"),
    20: .same(proto: "CONFIGURE_DELEGATION"),
  ]
}

extension Concordium_V2_ProtocolVersion: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROTOCOL_VERSION_1"),
    1: .same(proto: "PROTOCOL_VERSION_2"),
    2: .same(proto: "PROTOCOL_VERSION_3"),
    3: .same(proto: "PROTOCOL_VERSION_4"),
    4: .same(proto: "PROTOCOL_VERSION_5"),
    5: .same(proto: "PROTOCOL_VERSION_6"),
    6: .same(proto: "PROTOCOL_VERSION_7"),
  ]
}

extension Concordium_V2_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Empty, rhs: Concordium_V2_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockHash"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockHash, rhs: Concordium_V2_BlockHash) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Sha256Hash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Sha256Hash"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Sha256Hash, rhs: Concordium_V2_Sha256Hash) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_TransactionHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionHash"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_TransactionHash, rhs: Concordium_V2_TransactionHash) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_StateHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StateHash"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_StateHash, rhs: Concordium_V2_StateHash) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AbsoluteBlockHeight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AbsoluteBlockHeight"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AbsoluteBlockHeight, rhs: Concordium_V2_AbsoluteBlockHeight) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockHeight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockHeight"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockHeight, rhs: Concordium_V2_BlockHeight) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BakerId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerId, rhs: Concordium_V2_BakerId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountIndex"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountIndex, rhs: Concordium_V2_AccountIndex) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ModuleRef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModuleRef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ModuleRef, rhs: Concordium_V2_ModuleRef) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_VersionedModuleSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VersionedModuleSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v0"),
    2: .same(proto: "v1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_VersionedModuleSource.ModuleSourceV0?
        var hadOneofValue = false
        if let current = self.module {
          hadOneofValue = true
          if case .v0(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.module = .v0(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_VersionedModuleSource.ModuleSourceV1?
        var hadOneofValue = false
        if let current = self.module {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.module = .v1(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.module {
    case .v0?: try {
      guard case .v0(let v)? = self.module else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .v1?: try {
      guard case .v1(let v)? = self.module else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_VersionedModuleSource, rhs: Concordium_V2_VersionedModuleSource) -> Bool {
    if lhs.module != rhs.module {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_VersionedModuleSource.ModuleSourceV0: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_VersionedModuleSource.protoMessageName + ".ModuleSourceV0"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_VersionedModuleSource.ModuleSourceV0, rhs: Concordium_V2_VersionedModuleSource.ModuleSourceV0) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_VersionedModuleSource.ModuleSourceV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_VersionedModuleSource.protoMessageName + ".ModuleSourceV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_VersionedModuleSource.ModuleSourceV1, rhs: Concordium_V2_VersionedModuleSource.ModuleSourceV1) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Timestamp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Timestamp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Timestamp, rhs: Concordium_V2_Timestamp) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Release: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Release"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "amount"),
    3: .same(proto: "transactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Release, rhs: Concordium_V2_Release) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_NewRelease: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewRelease"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_NewRelease, rhs: Concordium_V2_NewRelease) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ReleaseSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReleaseSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "schedules"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._total) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.schedules) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._total {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.schedules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.schedules, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ReleaseSchedule, rhs: Concordium_V2_ReleaseSchedule) -> Bool {
    if lhs._total != rhs._total {return false}
    if lhs.schedules != rhs.schedules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_EncryptedAmount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptedAmount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_EncryptedAmount, rhs: Concordium_V2_EncryptedAmount) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_EncryptedBalance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptedBalance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "self_amount"),
    2: .standard(proto: "start_index"),
    3: .standard(proto: "aggregated_amount"),
    4: .standard(proto: "num_aggregated"),
    5: .standard(proto: "incoming_amounts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._selfAmount) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.startIndex) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._aggregatedAmount) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._numAggregated) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.incomingAmounts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._selfAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.startIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.startIndex, fieldNumber: 2)
    }
    try { if let v = self._aggregatedAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._numAggregated {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    if !self.incomingAmounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.incomingAmounts, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_EncryptedBalance, rhs: Concordium_V2_EncryptedBalance) -> Bool {
    if lhs._selfAmount != rhs._selfAmount {return false}
    if lhs.startIndex != rhs.startIndex {return false}
    if lhs._aggregatedAmount != rhs._aggregatedAmount {return false}
    if lhs._numAggregated != rhs._numAggregated {return false}
    if lhs.incomingAmounts != rhs.incomingAmounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DelegationTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelegationTarget"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "passive"),
    2: .same(proto: "baker"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .passive(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .passive(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_BakerId?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .baker(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .baker(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.target {
    case .passive?: try {
      guard case .passive(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .baker?: try {
      guard case .baker(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DelegationTarget, rhs: Concordium_V2_DelegationTarget) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerElectionVerifyKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BakerElectionVerifyKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerElectionVerifyKey, rhs: Concordium_V2_BakerElectionVerifyKey) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerSignatureVerifyKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BakerSignatureVerifyKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerSignatureVerifyKey, rhs: Concordium_V2_BakerSignatureVerifyKey) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerAggregationVerifyKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BakerAggregationVerifyKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerAggregationVerifyKey, rhs: Concordium_V2_BakerAggregationVerifyKey) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BakerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_id"),
    2: .standard(proto: "election_key"),
    3: .standard(proto: "signature_key"),
    4: .standard(proto: "aggregation_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._electionKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signatureKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._aggregationKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._electionKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signatureKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._aggregationKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerInfo, rhs: Concordium_V2_BakerInfo) -> Bool {
    if lhs._bakerID != rhs._bakerID {return false}
    if lhs._electionKey != rhs._electionKey {return false}
    if lhs._signatureKey != rhs._signatureKey {return false}
    if lhs._aggregationKey != rhs._aggregationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_StakePendingChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StakePendingChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reduce"),
    2: .same(proto: "remove"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_StakePendingChange.Reduce?
        var hadOneofValue = false
        if let current = self.change {
          hadOneofValue = true
          if case .reduce(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.change = .reduce(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_Timestamp?
        var hadOneofValue = false
        if let current = self.change {
          hadOneofValue = true
          if case .remove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.change = .remove(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.change {
    case .reduce?: try {
      guard case .reduce(let v)? = self.change else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .remove?: try {
      guard case .remove(let v)? = self.change else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_StakePendingChange, rhs: Concordium_V2_StakePendingChange) -> Bool {
    if lhs.change != rhs.change {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_StakePendingChange.Reduce: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_StakePendingChange.protoMessageName + ".Reduce"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_stake"),
    2: .standard(proto: "effective_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._newStake) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._effectiveTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._newStake {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._effectiveTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_StakePendingChange.Reduce, rhs: Concordium_V2_StakePendingChange.Reduce) -> Bool {
    if lhs._newStake != rhs._newStake {return false}
    if lhs._effectiveTime != rhs._effectiveTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AmountFraction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AmountFraction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parts_per_hundred_thousand"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.partsPerHundredThousand) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.partsPerHundredThousand != 0 {
      try visitor.visitSingularUInt32Field(value: self.partsPerHundredThousand, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AmountFraction, rhs: Concordium_V2_AmountFraction) -> Bool {
    if lhs.partsPerHundredThousand != rhs.partsPerHundredThousand {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_CommissionRates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommissionRates"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "finalization"),
    2: .same(proto: "baking"),
    3: .same(proto: "transaction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._finalization) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._baking) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._finalization {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._baking {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_CommissionRates, rhs: Concordium_V2_CommissionRates) -> Bool {
    if lhs._finalization != rhs._finalization {return false}
    if lhs._baking != rhs._baking {return false}
    if lhs._transaction != rhs._transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerPoolInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BakerPoolInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "open_status"),
    2: .same(proto: "url"),
    3: .standard(proto: "commission_rates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.openStatus) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._commissionRates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.openStatus != .openForAll {
      try visitor.visitSingularEnumField(value: self.openStatus, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try { if let v = self._commissionRates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerPoolInfo, rhs: Concordium_V2_BakerPoolInfo) -> Bool {
    if lhs.openStatus != rhs.openStatus {return false}
    if lhs.url != rhs.url {return false}
    if lhs._commissionRates != rhs._commissionRates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountStakingInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountStakingInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "baker"),
    2: .same(proto: "delegator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_AccountStakingInfo.Baker?
        var hadOneofValue = false
        if let current = self.stakingInfo {
          hadOneofValue = true
          if case .baker(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stakingInfo = .baker(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_AccountStakingInfo.Delegator?
        var hadOneofValue = false
        if let current = self.stakingInfo {
          hadOneofValue = true
          if case .delegator(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stakingInfo = .delegator(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.stakingInfo {
    case .baker?: try {
      guard case .baker(let v)? = self.stakingInfo else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .delegator?: try {
      guard case .delegator(let v)? = self.stakingInfo else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountStakingInfo, rhs: Concordium_V2_AccountStakingInfo) -> Bool {
    if lhs.stakingInfo != rhs.stakingInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountStakingInfo.Baker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_AccountStakingInfo.protoMessageName + ".Baker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staked_amount"),
    2: .standard(proto: "restake_earnings"),
    3: .standard(proto: "baker_info"),
    4: .standard(proto: "pending_change"),
    5: .standard(proto: "pool_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stakedAmount) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.restakeEarnings) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bakerInfo) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._pendingChange) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._poolInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stakedAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.restakeEarnings != false {
      try visitor.visitSingularBoolField(value: self.restakeEarnings, fieldNumber: 2)
    }
    try { if let v = self._bakerInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pendingChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._poolInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountStakingInfo.Baker, rhs: Concordium_V2_AccountStakingInfo.Baker) -> Bool {
    if lhs._stakedAmount != rhs._stakedAmount {return false}
    if lhs.restakeEarnings != rhs.restakeEarnings {return false}
    if lhs._bakerInfo != rhs._bakerInfo {return false}
    if lhs._pendingChange != rhs._pendingChange {return false}
    if lhs._poolInfo != rhs._poolInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountStakingInfo.Delegator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_AccountStakingInfo.protoMessageName + ".Delegator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staked_amount"),
    2: .standard(proto: "restake_earnings"),
    3: .same(proto: "target"),
    4: .standard(proto: "pending_change"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stakedAmount) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.restakeEarnings) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._target) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._pendingChange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stakedAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.restakeEarnings != false {
      try visitor.visitSingularBoolField(value: self.restakeEarnings, fieldNumber: 2)
    }
    try { if let v = self._target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pendingChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountStakingInfo.Delegator, rhs: Concordium_V2_AccountStakingInfo.Delegator) -> Bool {
    if lhs._stakedAmount != rhs._stakedAmount {return false}
    if lhs.restakeEarnings != rhs.restakeEarnings {return false}
    if lhs._target != rhs._target {return false}
    if lhs._pendingChange != rhs._pendingChange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_SequenceNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SequenceNumber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_SequenceNumber, rhs: Concordium_V2_SequenceNumber) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_UpdateSequenceNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateSequenceNumber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_UpdateSequenceNumber, rhs: Concordium_V2_UpdateSequenceNumber) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Amount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Amount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Amount, rhs: Concordium_V2_Amount) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_CredentialIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CredentialIndex"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_CredentialIndex, rhs: Concordium_V2_CredentialIndex) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_SignatureThreshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignatureThreshold"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_SignatureThreshold, rhs: Concordium_V2_SignatureThreshold) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountThreshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountThreshold"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountThreshold, rhs: Concordium_V2_AccountThreshold) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_EncryptionKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptionKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_EncryptionKey, rhs: Concordium_V2_EncryptionKey) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountAddress, rhs: Concordium_V2_AccountAddress) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Address"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "contract"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_AccountAddress?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .account(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .account(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_ContractAddress?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .contract(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .contract(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .account?: try {
      guard case .account(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .contract?: try {
      guard case .contract(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Address, rhs: Concordium_V2_Address) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountVerifyKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountVerifyKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ed25519_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .ed25519Key(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .ed25519Key(let v)? = self.key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountVerifyKey, rhs: Concordium_V2_AccountVerifyKey) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_CredentialPublicKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CredentialPublicKeys"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    2: .same(proto: "threshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Concordium_V2_AccountVerifyKey>.self, value: &self.keys) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._threshold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.keys.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Concordium_V2_AccountVerifyKey>.self, value: self.keys, fieldNumber: 1)
    }
    try { if let v = self._threshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_CredentialPublicKeys, rhs: Concordium_V2_CredentialPublicKeys) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs._threshold != rhs._threshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_CredentialRegistrationId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CredentialRegistrationId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_CredentialRegistrationId, rhs: Concordium_V2_CredentialRegistrationId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_IdentityProviderIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IdentityProviderIdentity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_IdentityProviderIdentity, rhs: Concordium_V2_IdentityProviderIdentity) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_YearMonth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".YearMonth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.year) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.month) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.month != 0 {
      try visitor.visitSingularUInt32Field(value: self.month, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_YearMonth, rhs: Concordium_V2_YearMonth) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Policy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_at"),
    2: .standard(proto: "valid_to"),
    3: .same(proto: "attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._validTo) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt32,SwiftProtobuf.ProtobufBytes>.self, value: &self.attributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._validTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt32,SwiftProtobuf.ProtobufBytes>.self, value: self.attributes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Policy, rhs: Concordium_V2_Policy) -> Bool {
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._validTo != rhs._validTo {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InitialCredentialValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitialCredentialValues"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    2: .standard(proto: "cred_id"),
    3: .standard(proto: "ip_id"),
    4: .same(proto: "policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keys) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._credID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._ipID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._policy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keys {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._credID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ipID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._policy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InitialCredentialValues, rhs: Concordium_V2_InitialCredentialValues) -> Bool {
    if lhs._keys != rhs._keys {return false}
    if lhs._credID != rhs._credID {return false}
    if lhs._ipID != rhs._ipID {return false}
    if lhs._policy != rhs._policy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ChainArData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainArData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enc_id_cred_pub_share"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encIDCredPubShare) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encIDCredPubShare.isEmpty {
      try visitor.visitSingularBytesField(value: self.encIDCredPubShare, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ChainArData, rhs: Concordium_V2_ChainArData) -> Bool {
    if lhs.encIDCredPubShare != rhs.encIDCredPubShare {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ArThreshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArThreshold"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ArThreshold, rhs: Concordium_V2_ArThreshold) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Commitment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Commitment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Commitment, rhs: Concordium_V2_Commitment) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_CredentialCommitments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CredentialCommitments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prf"),
    2: .standard(proto: "cred_counter"),
    3: .standard(proto: "max_accounts"),
    4: .same(proto: "attributes"),
    5: .standard(proto: "id_cred_sec_sharing_coeff"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._prf) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._credCounter) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._maxAccounts) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Concordium_V2_Commitment>.self, value: &self.attributes) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.idCredSecSharingCoeff) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._credCounter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._maxAccounts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Concordium_V2_Commitment>.self, value: self.attributes, fieldNumber: 4)
    }
    if !self.idCredSecSharingCoeff.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.idCredSecSharingCoeff, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_CredentialCommitments, rhs: Concordium_V2_CredentialCommitments) -> Bool {
    if lhs._prf != rhs._prf {return false}
    if lhs._credCounter != rhs._credCounter {return false}
    if lhs._maxAccounts != rhs._maxAccounts {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.idCredSecSharingCoeff != rhs.idCredSecSharingCoeff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_NormalCredentialValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NormalCredentialValues"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    2: .standard(proto: "cred_id"),
    3: .standard(proto: "ip_id"),
    4: .same(proto: "policy"),
    5: .standard(proto: "ar_threshold"),
    6: .standard(proto: "ar_data"),
    7: .same(proto: "commitments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keys) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._credID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._ipID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._policy) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._arThreshold) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Concordium_V2_ChainArData>.self, value: &self.arData) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._commitments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keys {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._credID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ipID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._policy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._arThreshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.arData.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Concordium_V2_ChainArData>.self, value: self.arData, fieldNumber: 6)
    }
    try { if let v = self._commitments {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_NormalCredentialValues, rhs: Concordium_V2_NormalCredentialValues) -> Bool {
    if lhs._keys != rhs._keys {return false}
    if lhs._credID != rhs._credID {return false}
    if lhs._ipID != rhs._ipID {return false}
    if lhs._policy != rhs._policy {return false}
    if lhs._arThreshold != rhs._arThreshold {return false}
    if lhs.arData != rhs.arData {return false}
    if lhs._commitments != rhs._commitments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "initial"),
    2: .same(proto: "normal"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_InitialCredentialValues?
        var hadOneofValue = false
        if let current = self.credentialValues {
          hadOneofValue = true
          if case .initial(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credentialValues = .initial(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_NormalCredentialValues?
        var hadOneofValue = false
        if let current = self.credentialValues {
          hadOneofValue = true
          if case .normal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.credentialValues = .normal(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.credentialValues {
    case .initial?: try {
      guard case .initial(let v)? = self.credentialValues else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .normal?: try {
      guard case .normal(let v)? = self.credentialValues else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountCredential, rhs: Concordium_V2_AccountCredential) -> Bool {
    if lhs.credentialValues != rhs.credentialValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Cooldown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Cooldown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "end_time"),
    2: .same(proto: "amount"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.status != .cooldown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Cooldown, rhs: Concordium_V2_Cooldown) -> Bool {
    if lhs._endTime != rhs._endTime {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Cooldown.CooldownStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COOLDOWN"),
    1: .same(proto: "PRE_COOLDOWN"),
    2: .same(proto: "PRE_PRE_COOLDOWN"),
  ]
}

extension Concordium_V2_AccountInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
    2: .same(proto: "amount"),
    3: .same(proto: "schedule"),
    4: .same(proto: "creds"),
    5: .same(proto: "threshold"),
    6: .standard(proto: "encrypted_balance"),
    7: .standard(proto: "encryption_key"),
    8: .same(proto: "index"),
    9: .same(proto: "stake"),
    10: .same(proto: "address"),
    11: .same(proto: "cooldowns"),
    12: .standard(proto: "available_balance"),
  ]

  fileprivate class _StorageClass {
    var _sequenceNumber: Concordium_V2_SequenceNumber? = nil
    var _amount: Concordium_V2_Amount? = nil
    var _schedule: Concordium_V2_ReleaseSchedule? = nil
    var _creds: Dictionary<UInt32,Concordium_V2_AccountCredential> = [:]
    var _threshold: Concordium_V2_AccountThreshold? = nil
    var _encryptedBalance: Concordium_V2_EncryptedBalance? = nil
    var _encryptionKey: Concordium_V2_EncryptionKey? = nil
    var _index: Concordium_V2_AccountIndex? = nil
    var _stake: Concordium_V2_AccountStakingInfo? = nil
    var _address: Concordium_V2_AccountAddress? = nil
    var _cooldowns: [Concordium_V2_Cooldown] = []
    var _availableBalance: Concordium_V2_Amount? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _sequenceNumber = source._sequenceNumber
      _amount = source._amount
      _schedule = source._schedule
      _creds = source._creds
      _threshold = source._threshold
      _encryptedBalance = source._encryptedBalance
      _encryptionKey = source._encryptionKey
      _index = source._index
      _stake = source._stake
      _address = source._address
      _cooldowns = source._cooldowns
      _availableBalance = source._availableBalance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._sequenceNumber) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._amount) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._schedule) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Concordium_V2_AccountCredential>.self, value: &_storage._creds) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._threshold) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._encryptedBalance) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._encryptionKey) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._index) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._stake) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._address) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._cooldowns) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._availableBalance) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._sequenceNumber {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._schedule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._creds.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Concordium_V2_AccountCredential>.self, value: _storage._creds, fieldNumber: 4)
      }
      try { if let v = _storage._threshold {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._encryptedBalance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._encryptionKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._index {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._stake {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._address {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._cooldowns.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cooldowns, fieldNumber: 11)
      }
      try { if let v = _storage._availableBalance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountInfo, rhs: Concordium_V2_AccountInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sequenceNumber != rhs_storage._sequenceNumber {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._schedule != rhs_storage._schedule {return false}
        if _storage._creds != rhs_storage._creds {return false}
        if _storage._threshold != rhs_storage._threshold {return false}
        if _storage._encryptedBalance != rhs_storage._encryptedBalance {return false}
        if _storage._encryptionKey != rhs_storage._encryptionKey {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._stake != rhs_storage._stake {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._cooldowns != rhs_storage._cooldowns {return false}
        if _storage._availableBalance != rhs_storage._availableBalance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockHashInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockHashInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "best"),
    2: .standard(proto: "last_final"),
    3: .same(proto: "given"),
    4: .standard(proto: "absolute_height"),
    5: .standard(proto: "relative_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.blockHashInput {
          hadOneofValue = true
          if case .best(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blockHashInput = .best(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.blockHashInput {
          hadOneofValue = true
          if case .lastFinal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blockHashInput = .lastFinal(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_BlockHash?
        var hadOneofValue = false
        if let current = self.blockHashInput {
          hadOneofValue = true
          if case .given(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blockHashInput = .given(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_AbsoluteBlockHeight?
        var hadOneofValue = false
        if let current = self.blockHashInput {
          hadOneofValue = true
          if case .absoluteHeight(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blockHashInput = .absoluteHeight(v)
        }
      }()
      case 5: try {
        var v: Concordium_V2_BlockHashInput.RelativeHeight?
        var hadOneofValue = false
        if let current = self.blockHashInput {
          hadOneofValue = true
          if case .relativeHeight(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blockHashInput = .relativeHeight(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.blockHashInput {
    case .best?: try {
      guard case .best(let v)? = self.blockHashInput else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .lastFinal?: try {
      guard case .lastFinal(let v)? = self.blockHashInput else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .given?: try {
      guard case .given(let v)? = self.blockHashInput else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .absoluteHeight?: try {
      guard case .absoluteHeight(let v)? = self.blockHashInput else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .relativeHeight?: try {
      guard case .relativeHeight(let v)? = self.blockHashInput else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockHashInput, rhs: Concordium_V2_BlockHashInput) -> Bool {
    if lhs.blockHashInput != rhs.blockHashInput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockHashInput.RelativeHeight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlockHashInput.protoMessageName + ".RelativeHeight"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "genesis_index"),
    2: .same(proto: "height"),
    3: .same(proto: "restrict"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._genesisIndex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._height) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.restrict) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._genesisIndex {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.restrict != false {
      try visitor.visitSingularBoolField(value: self.restrict, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockHashInput.RelativeHeight, rhs: Concordium_V2_BlockHashInput.RelativeHeight) -> Bool {
    if lhs._genesisIndex != rhs._genesisIndex {return false}
    if lhs._height != rhs._height {return false}
    if lhs.restrict != rhs.restrict {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_EpochRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EpochRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "relative_epoch"),
    2: .standard(proto: "block_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_EpochRequest.RelativeEpoch?
        var hadOneofValue = false
        if let current = self.epochRequestInput {
          hadOneofValue = true
          if case .relativeEpoch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.epochRequestInput = .relativeEpoch(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_BlockHashInput?
        var hadOneofValue = false
        if let current = self.epochRequestInput {
          hadOneofValue = true
          if case .blockHash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.epochRequestInput = .blockHash(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.epochRequestInput {
    case .relativeEpoch?: try {
      guard case .relativeEpoch(let v)? = self.epochRequestInput else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .blockHash?: try {
      guard case .blockHash(let v)? = self.epochRequestInput else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_EpochRequest, rhs: Concordium_V2_EpochRequest) -> Bool {
    if lhs.epochRequestInput != rhs.epochRequestInput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_EpochRequest.RelativeEpoch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_EpochRequest.protoMessageName + ".RelativeEpoch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "genesis_index"),
    2: .same(proto: "epoch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._genesisIndex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._epoch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._genesisIndex {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._epoch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_EpochRequest.RelativeEpoch, rhs: Concordium_V2_EpochRequest.RelativeEpoch) -> Bool {
    if lhs._genesisIndex != rhs._genesisIndex {return false}
    if lhs._epoch != rhs._epoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountIdentifierInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountIdentifierInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "cred_id"),
    3: .standard(proto: "account_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_AccountAddress?
        var hadOneofValue = false
        if let current = self.accountIdentifierInput {
          hadOneofValue = true
          if case .address(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.accountIdentifierInput = .address(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_CredentialRegistrationId?
        var hadOneofValue = false
        if let current = self.accountIdentifierInput {
          hadOneofValue = true
          if case .credID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.accountIdentifierInput = .credID(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_AccountIndex?
        var hadOneofValue = false
        if let current = self.accountIdentifierInput {
          hadOneofValue = true
          if case .accountIndex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.accountIdentifierInput = .accountIndex(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.accountIdentifierInput {
    case .address?: try {
      guard case .address(let v)? = self.accountIdentifierInput else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .credID?: try {
      guard case .credID(let v)? = self.accountIdentifierInput else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .accountIndex?: try {
      guard case .accountIndex(let v)? = self.accountIdentifierInput else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountIdentifierInput, rhs: Concordium_V2_AccountIdentifierInput) -> Bool {
    if lhs.accountIdentifierInput != rhs.accountIdentifierInput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_hash"),
    2: .standard(proto: "account_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blockHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountInfoRequest, rhs: Concordium_V2_AccountInfoRequest) -> Bool {
    if lhs._blockHash != rhs._blockHash {return false}
    if lhs._accountIdentifier != rhs._accountIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_FinalizedBlockInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalizedBlockInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._hash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_FinalizedBlockInfo, rhs: Concordium_V2_FinalizedBlockInfo) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs._height != rhs._height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AncestorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AncestorsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_hash"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blockHash) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AncestorsRequest, rhs: Concordium_V2_AncestorsRequest) -> Bool {
    if lhs._blockHash != rhs._blockHash {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ModuleSourceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModuleSourceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_hash"),
    2: .standard(proto: "module_ref"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blockHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._moduleRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._moduleRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ModuleSourceRequest, rhs: Concordium_V2_ModuleSourceRequest) -> Bool {
    if lhs._blockHash != rhs._blockHash {return false}
    if lhs._moduleRef != rhs._moduleRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ContractAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "subindex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.subindex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 1)
    }
    if self.subindex != 0 {
      try visitor.visitSingularUInt64Field(value: self.subindex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ContractAddress, rhs: Concordium_V2_ContractAddress) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.subindex != rhs.subindex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InstanceInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstanceInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_hash"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blockHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InstanceInfoRequest, rhs: Concordium_V2_InstanceInfoRequest) -> Bool {
    if lhs._blockHash != rhs._blockHash {return false}
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InstanceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstanceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v0"),
    2: .same(proto: "v1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_InstanceInfo.V0?
        var hadOneofValue = false
        if let current = self.version {
          hadOneofValue = true
          if case .v0(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.version = .v0(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_InstanceInfo.V1?
        var hadOneofValue = false
        if let current = self.version {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.version = .v1(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.version {
    case .v0?: try {
      guard case .v0(let v)? = self.version else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .v1?: try {
      guard case .v1(let v)? = self.version else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InstanceInfo, rhs: Concordium_V2_InstanceInfo) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InstanceInfo.V0: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_InstanceInfo.protoMessageName + ".V0"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
    2: .same(proto: "owner"),
    3: .same(proto: "amount"),
    4: .same(proto: "methods"),
    5: .same(proto: "name"),
    6: .standard(proto: "source_module"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._model) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.methods) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sourceModule) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._model {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.methods.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.methods, fieldNumber: 4)
    }
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._sourceModule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InstanceInfo.V0, rhs: Concordium_V2_InstanceInfo.V0) -> Bool {
    if lhs._model != rhs._model {return false}
    if lhs._owner != rhs._owner {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.methods != rhs.methods {return false}
    if lhs._name != rhs._name {return false}
    if lhs._sourceModule != rhs._sourceModule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InstanceInfo.V1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_InstanceInfo.protoMessageName + ".V1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "owner"),
    3: .same(proto: "amount"),
    4: .same(proto: "methods"),
    5: .same(proto: "name"),
    6: .standard(proto: "source_module"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._owner) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.methods) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sourceModule) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._owner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.methods.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.methods, fieldNumber: 4)
    }
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._sourceModule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InstanceInfo.V1, rhs: Concordium_V2_InstanceInfo.V1) -> Bool {
    if lhs._owner != rhs._owner {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.methods != rhs.methods {return false}
    if lhs._name != rhs._name {return false}
    if lhs._sourceModule != rhs._sourceModule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InstanceStateKVPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstanceStateKVPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InstanceStateKVPair, rhs: Concordium_V2_InstanceStateKVPair) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InstanceStateLookupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstanceStateLookupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_hash"),
    2: .same(proto: "address"),
    3: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blockHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InstanceStateLookupRequest, rhs: Concordium_V2_InstanceStateLookupRequest) -> Bool {
    if lhs._blockHash != rhs._blockHash {return false}
    if lhs._address != rhs._address {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InstanceStateValueAtKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstanceStateValueAtKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InstanceStateValueAtKey, rhs: Concordium_V2_InstanceStateValueAtKey) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ReceiveName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceiveName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ReceiveName, rhs: Concordium_V2_ReceiveName) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InitName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InitName, rhs: Concordium_V2_InitName) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Parameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Parameter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Parameter, rhs: Concordium_V2_Parameter) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ContractStateV0: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractStateV0"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ContractStateV0, rhs: Concordium_V2_ContractStateV0) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockItemStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockItemStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "received"),
    2: .same(proto: "committed"),
    3: .same(proto: "finalized"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .received(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .received(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_BlockItemStatus.Committed?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .committed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .committed(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_BlockItemStatus.Finalized?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .finalized(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .finalized(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.status {
    case .received?: try {
      guard case .received(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .committed?: try {
      guard case .committed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .finalized?: try {
      guard case .finalized(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockItemStatus, rhs: Concordium_V2_BlockItemStatus) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockItemStatus.Committed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlockItemStatus.protoMessageName + ".Committed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outcomes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.outcomes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outcomes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outcomes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockItemStatus.Committed, rhs: Concordium_V2_BlockItemStatus.Committed) -> Bool {
    if lhs.outcomes != rhs.outcomes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockItemStatus.Finalized: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlockItemStatus.protoMessageName + ".Finalized"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outcome"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outcome) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockItemStatus.Finalized, rhs: Concordium_V2_BlockItemStatus.Finalized) -> Bool {
    if lhs._outcome != rhs._outcome {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockItemSummaryInBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockItemSummaryInBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_hash"),
    2: .same(proto: "outcome"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blockHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outcome) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._outcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockItemSummaryInBlock, rhs: Concordium_V2_BlockItemSummaryInBlock) -> Bool {
    if lhs._blockHash != rhs._blockHash {return false}
    if lhs._outcome != rhs._outcome {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Energy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Energy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Energy, rhs: Concordium_V2_Energy) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Slot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Slot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Slot, rhs: Concordium_V2_Slot) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_NextAccountSequenceNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NextAccountSequenceNumber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
    2: .standard(proto: "all_final"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sequenceNumber) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allFinal) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sequenceNumber {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.allFinal != false {
      try visitor.visitSingularBoolField(value: self.allFinal, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_NextAccountSequenceNumber, rhs: Concordium_V2_NextAccountSequenceNumber) -> Bool {
    if lhs._sequenceNumber != rhs._sequenceNumber {return false}
    if lhs.allFinal != rhs.allFinal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Duration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Duration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Duration, rhs: Concordium_V2_Duration) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_RejectReason: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RejectReason"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "module_not_wf"),
    2: .standard(proto: "module_hash_already_exists"),
    3: .standard(proto: "invalid_account_reference"),
    4: .standard(proto: "invalid_init_method"),
    5: .standard(proto: "invalid_receive_method"),
    6: .standard(proto: "invalid_module_reference"),
    7: .standard(proto: "invalid_contract_address"),
    8: .standard(proto: "runtime_failure"),
    9: .standard(proto: "amount_too_large"),
    10: .standard(proto: "serialization_failure"),
    11: .standard(proto: "out_of_energy"),
    12: .standard(proto: "rejected_init"),
    13: .standard(proto: "rejected_receive"),
    14: .standard(proto: "invalid_proof"),
    15: .standard(proto: "already_a_baker"),
    16: .standard(proto: "not_a_baker"),
    17: .standard(proto: "insufficient_balance_for_baker_stake"),
    18: .standard(proto: "stake_under_minimum_threshold_for_baking"),
    19: .standard(proto: "baker_in_cooldown"),
    20: .standard(proto: "duplicate_aggregation_key"),
    21: .standard(proto: "non_existent_credential_id"),
    22: .standard(proto: "key_index_already_in_use"),
    23: .standard(proto: "invalid_account_threshold"),
    24: .standard(proto: "invalid_credential_key_sign_threshold"),
    25: .standard(proto: "invalid_encrypted_amount_transfer_proof"),
    26: .standard(proto: "invalid_transfer_to_public_proof"),
    27: .standard(proto: "encrypted_amount_self_transfer"),
    28: .standard(proto: "invalid_index_on_encrypted_transfer"),
    29: .standard(proto: "zero_scheduledAmount"),
    30: .standard(proto: "non_increasing_schedule"),
    31: .standard(proto: "first_scheduled_release_expired"),
    32: .standard(proto: "scheduled_self_transfer"),
    33: .standard(proto: "invalid_credentials"),
    34: .standard(proto: "duplicate_cred_ids"),
    35: .standard(proto: "non_existent_cred_ids"),
    36: .standard(proto: "remove_first_credential"),
    37: .standard(proto: "credential_holder_did_not_sign"),
    38: .standard(proto: "not_allowed_multiple_credentials"),
    39: .standard(proto: "not_allowed_to_receive_encrypted"),
    40: .standard(proto: "not_allowed_to_handle_encrypted"),
    41: .standard(proto: "missing_baker_add_parameters"),
    42: .standard(proto: "finalization_reward_commission_not_in_range"),
    43: .standard(proto: "baking_reward_commission_not_in_range"),
    44: .standard(proto: "transaction_fee_commission_not_in_range"),
    45: .standard(proto: "already_a_delegator"),
    46: .standard(proto: "insufficient_balance_for_delegation_stake"),
    47: .standard(proto: "missing_delegation_add_parameters"),
    48: .standard(proto: "insufficient_delegation_stake"),
    49: .standard(proto: "delegator_in_cooldown"),
    50: .standard(proto: "not_a_delegator"),
    51: .standard(proto: "delegation_target_not_a_baker"),
    52: .standard(proto: "stake_over_maximum_threshold_for_pool"),
    53: .standard(proto: "pool_would_become_over_delegated"),
    54: .standard(proto: "pool_closed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .moduleNotWf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .moduleNotWf(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_ModuleRef?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .moduleHashAlreadyExists(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .moduleHashAlreadyExists(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_AccountAddress?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .invalidAccountReference(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .invalidAccountReference(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_RejectReason.InvalidInitMethod?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .invalidInitMethod(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .invalidInitMethod(v)
        }
      }()
      case 5: try {
        var v: Concordium_V2_RejectReason.InvalidReceiveMethod?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .invalidReceiveMethod(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .invalidReceiveMethod(v)
        }
      }()
      case 6: try {
        var v: Concordium_V2_ModuleRef?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .invalidModuleReference(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .invalidModuleReference(v)
        }
      }()
      case 7: try {
        var v: Concordium_V2_ContractAddress?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .invalidContractAddress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .invalidContractAddress(v)
        }
      }()
      case 8: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .runtimeFailure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .runtimeFailure(v)
        }
      }()
      case 9: try {
        var v: Concordium_V2_RejectReason.AmountTooLarge?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .amountTooLarge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .amountTooLarge(v)
        }
      }()
      case 10: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .serializationFailure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .serializationFailure(v)
        }
      }()
      case 11: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .outOfEnergy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .outOfEnergy(v)
        }
      }()
      case 12: try {
        var v: Concordium_V2_RejectReason.RejectedInit?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .rejectedInit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .rejectedInit(v)
        }
      }()
      case 13: try {
        var v: Concordium_V2_RejectReason.RejectedReceive?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .rejectedReceive(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .rejectedReceive(v)
        }
      }()
      case 14: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .invalidProof(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .invalidProof(v)
        }
      }()
      case 15: try {
        var v: Concordium_V2_BakerId?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .alreadyABaker(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .alreadyABaker(v)
        }
      }()
      case 16: try {
        var v: Concordium_V2_AccountAddress?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .notABaker(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .notABaker(v)
        }
      }()
      case 17: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .insufficientBalanceForBakerStake(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .insufficientBalanceForBakerStake(v)
        }
      }()
      case 18: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .stakeUnderMinimumThresholdForBaking(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .stakeUnderMinimumThresholdForBaking(v)
        }
      }()
      case 19: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .bakerInCooldown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .bakerInCooldown(v)
        }
      }()
      case 20: try {
        var v: Concordium_V2_BakerAggregationVerifyKey?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .duplicateAggregationKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .duplicateAggregationKey(v)
        }
      }()
      case 21: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .nonExistentCredentialID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .nonExistentCredentialID(v)
        }
      }()
      case 22: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .keyIndexAlreadyInUse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .keyIndexAlreadyInUse(v)
        }
      }()
      case 23: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .invalidAccountThreshold(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .invalidAccountThreshold(v)
        }
      }()
      case 24: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .invalidCredentialKeySignThreshold(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .invalidCredentialKeySignThreshold(v)
        }
      }()
      case 25: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .invalidEncryptedAmountTransferProof(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .invalidEncryptedAmountTransferProof(v)
        }
      }()
      case 26: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .invalidTransferToPublicProof(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .invalidTransferToPublicProof(v)
        }
      }()
      case 27: try {
        var v: Concordium_V2_AccountAddress?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .encryptedAmountSelfTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .encryptedAmountSelfTransfer(v)
        }
      }()
      case 28: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .invalidIndexOnEncryptedTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .invalidIndexOnEncryptedTransfer(v)
        }
      }()
      case 29: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .zeroScheduledAmount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .zeroScheduledAmount(v)
        }
      }()
      case 30: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .nonIncreasingSchedule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .nonIncreasingSchedule(v)
        }
      }()
      case 31: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .firstScheduledReleaseExpired(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .firstScheduledReleaseExpired(v)
        }
      }()
      case 32: try {
        var v: Concordium_V2_AccountAddress?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .scheduledSelfTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .scheduledSelfTransfer(v)
        }
      }()
      case 33: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .invalidCredentials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .invalidCredentials(v)
        }
      }()
      case 34: try {
        var v: Concordium_V2_RejectReason.DuplicateCredIds?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .duplicateCredIds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .duplicateCredIds(v)
        }
      }()
      case 35: try {
        var v: Concordium_V2_RejectReason.NonExistentCredIds?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .nonExistentCredIds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .nonExistentCredIds(v)
        }
      }()
      case 36: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .removeFirstCredential(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .removeFirstCredential(v)
        }
      }()
      case 37: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .credentialHolderDidNotSign(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .credentialHolderDidNotSign(v)
        }
      }()
      case 38: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .notAllowedMultipleCredentials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .notAllowedMultipleCredentials(v)
        }
      }()
      case 39: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .notAllowedToReceiveEncrypted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .notAllowedToReceiveEncrypted(v)
        }
      }()
      case 40: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .notAllowedToHandleEncrypted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .notAllowedToHandleEncrypted(v)
        }
      }()
      case 41: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .missingBakerAddParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .missingBakerAddParameters(v)
        }
      }()
      case 42: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .finalizationRewardCommissionNotInRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .finalizationRewardCommissionNotInRange(v)
        }
      }()
      case 43: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .bakingRewardCommissionNotInRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .bakingRewardCommissionNotInRange(v)
        }
      }()
      case 44: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .transactionFeeCommissionNotInRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .transactionFeeCommissionNotInRange(v)
        }
      }()
      case 45: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .alreadyADelegator(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .alreadyADelegator(v)
        }
      }()
      case 46: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .insufficientBalanceForDelegationStake(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .insufficientBalanceForDelegationStake(v)
        }
      }()
      case 47: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .missingDelegationAddParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .missingDelegationAddParameters(v)
        }
      }()
      case 48: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .insufficientDelegationStake(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .insufficientDelegationStake(v)
        }
      }()
      case 49: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .delegatorInCooldown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .delegatorInCooldown(v)
        }
      }()
      case 50: try {
        var v: Concordium_V2_AccountAddress?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .notADelegator(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .notADelegator(v)
        }
      }()
      case 51: try {
        var v: Concordium_V2_BakerId?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .delegationTargetNotABaker(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .delegationTargetNotABaker(v)
        }
      }()
      case 52: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .stakeOverMaximumThresholdForPool(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .stakeOverMaximumThresholdForPool(v)
        }
      }()
      case 53: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .poolWouldBecomeOverDelegated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .poolWouldBecomeOverDelegated(v)
        }
      }()
      case 54: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .poolClosed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .poolClosed(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.reason {
    case .moduleNotWf?: try {
      guard case .moduleNotWf(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .moduleHashAlreadyExists?: try {
      guard case .moduleHashAlreadyExists(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .invalidAccountReference?: try {
      guard case .invalidAccountReference(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .invalidInitMethod?: try {
      guard case .invalidInitMethod(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .invalidReceiveMethod?: try {
      guard case .invalidReceiveMethod(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .invalidModuleReference?: try {
      guard case .invalidModuleReference(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .invalidContractAddress?: try {
      guard case .invalidContractAddress(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .runtimeFailure?: try {
      guard case .runtimeFailure(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .amountTooLarge?: try {
      guard case .amountTooLarge(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .serializationFailure?: try {
      guard case .serializationFailure(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .outOfEnergy?: try {
      guard case .outOfEnergy(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .rejectedInit?: try {
      guard case .rejectedInit(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .rejectedReceive?: try {
      guard case .rejectedReceive(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .invalidProof?: try {
      guard case .invalidProof(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .alreadyABaker?: try {
      guard case .alreadyABaker(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .notABaker?: try {
      guard case .notABaker(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .insufficientBalanceForBakerStake?: try {
      guard case .insufficientBalanceForBakerStake(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .stakeUnderMinimumThresholdForBaking?: try {
      guard case .stakeUnderMinimumThresholdForBaking(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .bakerInCooldown?: try {
      guard case .bakerInCooldown(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .duplicateAggregationKey?: try {
      guard case .duplicateAggregationKey(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .nonExistentCredentialID?: try {
      guard case .nonExistentCredentialID(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .keyIndexAlreadyInUse?: try {
      guard case .keyIndexAlreadyInUse(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .invalidAccountThreshold?: try {
      guard case .invalidAccountThreshold(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .invalidCredentialKeySignThreshold?: try {
      guard case .invalidCredentialKeySignThreshold(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .invalidEncryptedAmountTransferProof?: try {
      guard case .invalidEncryptedAmountTransferProof(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .invalidTransferToPublicProof?: try {
      guard case .invalidTransferToPublicProof(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .encryptedAmountSelfTransfer?: try {
      guard case .encryptedAmountSelfTransfer(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .invalidIndexOnEncryptedTransfer?: try {
      guard case .invalidIndexOnEncryptedTransfer(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .zeroScheduledAmount?: try {
      guard case .zeroScheduledAmount(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .nonIncreasingSchedule?: try {
      guard case .nonIncreasingSchedule(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .firstScheduledReleaseExpired?: try {
      guard case .firstScheduledReleaseExpired(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .scheduledSelfTransfer?: try {
      guard case .scheduledSelfTransfer(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .invalidCredentials?: try {
      guard case .invalidCredentials(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .duplicateCredIds?: try {
      guard case .duplicateCredIds(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .nonExistentCredIds?: try {
      guard case .nonExistentCredIds(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .removeFirstCredential?: try {
      guard case .removeFirstCredential(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .credentialHolderDidNotSign?: try {
      guard case .credentialHolderDidNotSign(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .notAllowedMultipleCredentials?: try {
      guard case .notAllowedMultipleCredentials(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .notAllowedToReceiveEncrypted?: try {
      guard case .notAllowedToReceiveEncrypted(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .notAllowedToHandleEncrypted?: try {
      guard case .notAllowedToHandleEncrypted(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .missingBakerAddParameters?: try {
      guard case .missingBakerAddParameters(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .finalizationRewardCommissionNotInRange?: try {
      guard case .finalizationRewardCommissionNotInRange(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .bakingRewardCommissionNotInRange?: try {
      guard case .bakingRewardCommissionNotInRange(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .transactionFeeCommissionNotInRange?: try {
      guard case .transactionFeeCommissionNotInRange(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .alreadyADelegator?: try {
      guard case .alreadyADelegator(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .insufficientBalanceForDelegationStake?: try {
      guard case .insufficientBalanceForDelegationStake(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .missingDelegationAddParameters?: try {
      guard case .missingDelegationAddParameters(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .insufficientDelegationStake?: try {
      guard case .insufficientDelegationStake(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .delegatorInCooldown?: try {
      guard case .delegatorInCooldown(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .notADelegator?: try {
      guard case .notADelegator(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .delegationTargetNotABaker?: try {
      guard case .delegationTargetNotABaker(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .stakeOverMaximumThresholdForPool?: try {
      guard case .stakeOverMaximumThresholdForPool(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .poolWouldBecomeOverDelegated?: try {
      guard case .poolWouldBecomeOverDelegated(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case .poolClosed?: try {
      guard case .poolClosed(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_RejectReason, rhs: Concordium_V2_RejectReason) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_RejectReason.InvalidInitMethod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_RejectReason.protoMessageName + ".InvalidInitMethod"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "module_ref"),
    2: .standard(proto: "init_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._moduleRef) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._initName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._moduleRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._initName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_RejectReason.InvalidInitMethod, rhs: Concordium_V2_RejectReason.InvalidInitMethod) -> Bool {
    if lhs._moduleRef != rhs._moduleRef {return false}
    if lhs._initName != rhs._initName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_RejectReason.InvalidReceiveMethod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_RejectReason.protoMessageName + ".InvalidReceiveMethod"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "module_ref"),
    2: .standard(proto: "receive_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._moduleRef) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._receiveName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._moduleRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._receiveName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_RejectReason.InvalidReceiveMethod, rhs: Concordium_V2_RejectReason.InvalidReceiveMethod) -> Bool {
    if lhs._moduleRef != rhs._moduleRef {return false}
    if lhs._receiveName != rhs._receiveName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_RejectReason.AmountTooLarge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_RejectReason.protoMessageName + ".AmountTooLarge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_RejectReason.AmountTooLarge, rhs: Concordium_V2_RejectReason.AmountTooLarge) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_RejectReason.RejectedInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_RejectReason.protoMessageName + ".RejectedInit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reject_reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.rejectReason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rejectReason != 0 {
      try visitor.visitSingularInt32Field(value: self.rejectReason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_RejectReason.RejectedInit, rhs: Concordium_V2_RejectReason.RejectedInit) -> Bool {
    if lhs.rejectReason != rhs.rejectReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_RejectReason.RejectedReceive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_RejectReason.protoMessageName + ".RejectedReceive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reject_reason"),
    2: .standard(proto: "contract_address"),
    3: .standard(proto: "receive_name"),
    4: .same(proto: "parameter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.rejectReason) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._contractAddress) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._receiveName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._parameter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.rejectReason != 0 {
      try visitor.visitSingularInt32Field(value: self.rejectReason, fieldNumber: 1)
    }
    try { if let v = self._contractAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._receiveName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._parameter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_RejectReason.RejectedReceive, rhs: Concordium_V2_RejectReason.RejectedReceive) -> Bool {
    if lhs.rejectReason != rhs.rejectReason {return false}
    if lhs._contractAddress != rhs._contractAddress {return false}
    if lhs._receiveName != rhs._receiveName {return false}
    if lhs._parameter != rhs._parameter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_RejectReason.DuplicateCredIds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_RejectReason.protoMessageName + ".DuplicateCredIds"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_RejectReason.DuplicateCredIds, rhs: Concordium_V2_RejectReason.DuplicateCredIds) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_RejectReason.NonExistentCredIds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_RejectReason.protoMessageName + ".NonExistentCredIds"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_RejectReason.NonExistentCredIds, rhs: Concordium_V2_RejectReason.NonExistentCredIds) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ContractInitializedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractInitializedEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_version"),
    2: .standard(proto: "origin_ref"),
    3: .same(proto: "address"),
    4: .same(proto: "amount"),
    5: .standard(proto: "init_name"),
    6: .same(proto: "events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.contractVersion) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._originRef) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._initName) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.contractVersion != .v0 {
      try visitor.visitSingularEnumField(value: self.contractVersion, fieldNumber: 1)
    }
    try { if let v = self._originRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._initName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ContractInitializedEvent, rhs: Concordium_V2_ContractInitializedEvent) -> Bool {
    if lhs.contractVersion != rhs.contractVersion {return false}
    if lhs._originRef != rhs._originRef {return false}
    if lhs._address != rhs._address {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._initName != rhs._initName {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ContractEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ContractEvent, rhs: Concordium_V2_ContractEvent) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InstanceUpdatedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstanceUpdatedEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contract_version"),
    2: .same(proto: "address"),
    3: .same(proto: "instigator"),
    4: .same(proto: "amount"),
    5: .same(proto: "parameter"),
    6: .standard(proto: "receive_name"),
    7: .same(proto: "events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.contractVersion) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._instigator) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._parameter) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._receiveName) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.contractVersion != .v0 {
      try visitor.visitSingularEnumField(value: self.contractVersion, fieldNumber: 1)
    }
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._instigator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._parameter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._receiveName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InstanceUpdatedEvent, rhs: Concordium_V2_InstanceUpdatedEvent) -> Bool {
    if lhs.contractVersion != rhs.contractVersion {return false}
    if lhs._address != rhs._address {return false}
    if lhs._instigator != rhs._instigator {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._parameter != rhs._parameter {return false}
    if lhs._receiveName != rhs._receiveName {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ContractTraceElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractTraceElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updated"),
    2: .same(proto: "transferred"),
    3: .same(proto: "interrupted"),
    4: .same(proto: "resumed"),
    5: .same(proto: "upgraded"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_InstanceUpdatedEvent?
        var hadOneofValue = false
        if let current = self.element {
          hadOneofValue = true
          if case .updated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.element = .updated(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_ContractTraceElement.Transferred?
        var hadOneofValue = false
        if let current = self.element {
          hadOneofValue = true
          if case .transferred(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.element = .transferred(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_ContractTraceElement.Interrupted?
        var hadOneofValue = false
        if let current = self.element {
          hadOneofValue = true
          if case .interrupted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.element = .interrupted(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_ContractTraceElement.Resumed?
        var hadOneofValue = false
        if let current = self.element {
          hadOneofValue = true
          if case .resumed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.element = .resumed(v)
        }
      }()
      case 5: try {
        var v: Concordium_V2_ContractTraceElement.Upgraded?
        var hadOneofValue = false
        if let current = self.element {
          hadOneofValue = true
          if case .upgraded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.element = .upgraded(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.element {
    case .updated?: try {
      guard case .updated(let v)? = self.element else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .transferred?: try {
      guard case .transferred(let v)? = self.element else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .interrupted?: try {
      guard case .interrupted(let v)? = self.element else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .resumed?: try {
      guard case .resumed(let v)? = self.element else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .upgraded?: try {
      guard case .upgraded(let v)? = self.element else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ContractTraceElement, rhs: Concordium_V2_ContractTraceElement) -> Bool {
    if lhs.element != rhs.element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ContractTraceElement.Transferred: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_ContractTraceElement.protoMessageName + ".Transferred"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "amount"),
    3: .same(proto: "receiver"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sender) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._receiver) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._receiver {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ContractTraceElement.Transferred, rhs: Concordium_V2_ContractTraceElement.Transferred) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._receiver != rhs._receiver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ContractTraceElement.Interrupted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_ContractTraceElement.protoMessageName + ".Interrupted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ContractTraceElement.Interrupted, rhs: Concordium_V2_ContractTraceElement.Interrupted) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ContractTraceElement.Resumed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_ContractTraceElement.protoMessageName + ".Resumed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ContractTraceElement.Resumed, rhs: Concordium_V2_ContractTraceElement.Resumed) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ContractTraceElement.Upgraded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_ContractTraceElement.protoMessageName + ".Upgraded"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ContractTraceElement.Upgraded, rhs: Concordium_V2_ContractTraceElement.Upgraded) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerKeysEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BakerKeysEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_id"),
    2: .same(proto: "account"),
    3: .standard(proto: "sign_key"),
    4: .standard(proto: "election_key"),
    5: .standard(proto: "aggregation_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._electionKey) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._aggregationKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._electionKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._aggregationKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerKeysEvent, rhs: Concordium_V2_BakerKeysEvent) -> Bool {
    if lhs._bakerID != rhs._bakerID {return false}
    if lhs._account != rhs._account {return false}
    if lhs._signKey != rhs._signKey {return false}
    if lhs._electionKey != rhs._electionKey {return false}
    if lhs._aggregationKey != rhs._aggregationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Memo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Memo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Memo, rhs: Concordium_V2_Memo) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerStakeUpdatedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BakerStakeUpdatedData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_id"),
    2: .standard(proto: "new_stake"),
    3: .same(proto: "increased"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newStake) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.increased) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newStake {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.increased != false {
      try visitor.visitSingularBoolField(value: self.increased, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerStakeUpdatedData, rhs: Concordium_V2_BakerStakeUpdatedData) -> Bool {
    if lhs._bakerID != rhs._bakerID {return false}
    if lhs._newStake != rhs._newStake {return false}
    if lhs.increased != rhs.increased {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_EncryptedAmountRemovedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptedAmountRemovedEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "new_amount"),
    3: .standard(proto: "input_amount"),
    4: .standard(proto: "up_to_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newAmount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._inputAmount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.upToIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._inputAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.upToIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.upToIndex, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_EncryptedAmountRemovedEvent, rhs: Concordium_V2_EncryptedAmountRemovedEvent) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._newAmount != rhs._newAmount {return false}
    if lhs._inputAmount != rhs._inputAmount {return false}
    if lhs.upToIndex != rhs.upToIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_NewEncryptedAmountEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewEncryptedAmountEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receiver"),
    2: .standard(proto: "new_index"),
    3: .standard(proto: "encrypted_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._receiver) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.newIndex) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._encryptedAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._receiver {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.newIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.newIndex, fieldNumber: 2)
    }
    try { if let v = self._encryptedAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_NewEncryptedAmountEvent, rhs: Concordium_V2_NewEncryptedAmountEvent) -> Bool {
    if lhs._receiver != rhs._receiver {return false}
    if lhs.newIndex != rhs.newIndex {return false}
    if lhs._encryptedAmount != rhs._encryptedAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_EncryptedSelfAmountAddedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptedSelfAmountAddedEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "new_amount"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newAmount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_EncryptedSelfAmountAddedEvent, rhs: Concordium_V2_EncryptedSelfAmountAddedEvent) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._newAmount != rhs._newAmount {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_RegisteredData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisteredData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_RegisteredData, rhs: Concordium_V2_RegisteredData) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BakerEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_added"),
    2: .standard(proto: "baker_removed"),
    3: .standard(proto: "baker_stake_increased"),
    4: .standard(proto: "baker_stake_decreased"),
    5: .standard(proto: "baker_restake_earnings_updated"),
    6: .standard(proto: "baker_keys_updated"),
    7: .standard(proto: "baker_set_open_status"),
    8: .standard(proto: "baker_set_metadata_url"),
    9: .standard(proto: "baker_set_transaction_fee_commission"),
    10: .standard(proto: "baker_set_baking_reward_commission"),
    11: .standard(proto: "baker_set_finalization_reward_commission"),
    12: .standard(proto: "delegation_removed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_BakerEvent.BakerAdded?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .bakerAdded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .bakerAdded(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_BakerId?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .bakerRemoved(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .bakerRemoved(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_BakerEvent.BakerStakeIncreased?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .bakerStakeIncreased(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .bakerStakeIncreased(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_BakerEvent.BakerStakeDecreased?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .bakerStakeDecreased(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .bakerStakeDecreased(v)
        }
      }()
      case 5: try {
        var v: Concordium_V2_BakerEvent.BakerRestakeEarningsUpdated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .bakerRestakeEarningsUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .bakerRestakeEarningsUpdated(v)
        }
      }()
      case 6: try {
        var v: Concordium_V2_BakerKeysEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .bakerKeysUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .bakerKeysUpdated(v)
        }
      }()
      case 7: try {
        var v: Concordium_V2_BakerEvent.BakerSetOpenStatus?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .bakerSetOpenStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .bakerSetOpenStatus(v)
        }
      }()
      case 8: try {
        var v: Concordium_V2_BakerEvent.BakerSetMetadataUrl?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .bakerSetMetadataURL(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .bakerSetMetadataURL(v)
        }
      }()
      case 9: try {
        var v: Concordium_V2_BakerEvent.BakerSetTransactionFeeCommission?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .bakerSetTransactionFeeCommission(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .bakerSetTransactionFeeCommission(v)
        }
      }()
      case 10: try {
        var v: Concordium_V2_BakerEvent.BakerSetBakingRewardCommission?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .bakerSetBakingRewardCommission(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .bakerSetBakingRewardCommission(v)
        }
      }()
      case 11: try {
        var v: Concordium_V2_BakerEvent.BakerSetFinalizationRewardCommission?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .bakerSetFinalizationRewardCommission(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .bakerSetFinalizationRewardCommission(v)
        }
      }()
      case 12: try {
        var v: Concordium_V2_BakerEvent.DelegationRemoved?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .delegationRemoved(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .delegationRemoved(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .bakerAdded?: try {
      guard case .bakerAdded(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .bakerRemoved?: try {
      guard case .bakerRemoved(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .bakerStakeIncreased?: try {
      guard case .bakerStakeIncreased(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .bakerStakeDecreased?: try {
      guard case .bakerStakeDecreased(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .bakerRestakeEarningsUpdated?: try {
      guard case .bakerRestakeEarningsUpdated(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .bakerKeysUpdated?: try {
      guard case .bakerKeysUpdated(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .bakerSetOpenStatus?: try {
      guard case .bakerSetOpenStatus(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .bakerSetMetadataURL?: try {
      guard case .bakerSetMetadataURL(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .bakerSetTransactionFeeCommission?: try {
      guard case .bakerSetTransactionFeeCommission(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .bakerSetBakingRewardCommission?: try {
      guard case .bakerSetBakingRewardCommission(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .bakerSetFinalizationRewardCommission?: try {
      guard case .bakerSetFinalizationRewardCommission(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .delegationRemoved?: try {
      guard case .delegationRemoved(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerEvent, rhs: Concordium_V2_BakerEvent) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerEvent.BakerAdded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BakerEvent.protoMessageName + ".BakerAdded"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "keys_event"),
    2: .same(proto: "stake"),
    3: .standard(proto: "restake_earnings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keysEvent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stake) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.restakeEarnings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keysEvent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stake {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.restakeEarnings != false {
      try visitor.visitSingularBoolField(value: self.restakeEarnings, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerEvent.BakerAdded, rhs: Concordium_V2_BakerEvent.BakerAdded) -> Bool {
    if lhs._keysEvent != rhs._keysEvent {return false}
    if lhs._stake != rhs._stake {return false}
    if lhs.restakeEarnings != rhs.restakeEarnings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerEvent.BakerStakeIncreased: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BakerEvent.protoMessageName + ".BakerStakeIncreased"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_id"),
    2: .standard(proto: "new_stake"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newStake) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newStake {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerEvent.BakerStakeIncreased, rhs: Concordium_V2_BakerEvent.BakerStakeIncreased) -> Bool {
    if lhs._bakerID != rhs._bakerID {return false}
    if lhs._newStake != rhs._newStake {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerEvent.BakerStakeDecreased: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BakerEvent.protoMessageName + ".BakerStakeDecreased"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_id"),
    2: .standard(proto: "new_stake"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newStake) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newStake {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerEvent.BakerStakeDecreased, rhs: Concordium_V2_BakerEvent.BakerStakeDecreased) -> Bool {
    if lhs._bakerID != rhs._bakerID {return false}
    if lhs._newStake != rhs._newStake {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerEvent.BakerRestakeEarningsUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BakerEvent.protoMessageName + ".BakerRestakeEarningsUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_id"),
    2: .standard(proto: "restake_earnings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.restakeEarnings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.restakeEarnings != false {
      try visitor.visitSingularBoolField(value: self.restakeEarnings, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerEvent.BakerRestakeEarningsUpdated, rhs: Concordium_V2_BakerEvent.BakerRestakeEarningsUpdated) -> Bool {
    if lhs._bakerID != rhs._bakerID {return false}
    if lhs.restakeEarnings != rhs.restakeEarnings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerEvent.BakerSetOpenStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BakerEvent.protoMessageName + ".BakerSetOpenStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_id"),
    2: .standard(proto: "open_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.openStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.openStatus != .openForAll {
      try visitor.visitSingularEnumField(value: self.openStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerEvent.BakerSetOpenStatus, rhs: Concordium_V2_BakerEvent.BakerSetOpenStatus) -> Bool {
    if lhs._bakerID != rhs._bakerID {return false}
    if lhs.openStatus != rhs.openStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerEvent.BakerSetMetadataUrl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BakerEvent.protoMessageName + ".BakerSetMetadataUrl"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_id"),
    2: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerEvent.BakerSetMetadataUrl, rhs: Concordium_V2_BakerEvent.BakerSetMetadataUrl) -> Bool {
    if lhs._bakerID != rhs._bakerID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerEvent.BakerSetTransactionFeeCommission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BakerEvent.protoMessageName + ".BakerSetTransactionFeeCommission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_id"),
    2: .standard(proto: "transaction_fee_commission"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._transactionFeeCommission) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._transactionFeeCommission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerEvent.BakerSetTransactionFeeCommission, rhs: Concordium_V2_BakerEvent.BakerSetTransactionFeeCommission) -> Bool {
    if lhs._bakerID != rhs._bakerID {return false}
    if lhs._transactionFeeCommission != rhs._transactionFeeCommission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerEvent.BakerSetBakingRewardCommission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BakerEvent.protoMessageName + ".BakerSetBakingRewardCommission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_id"),
    2: .standard(proto: "baking_reward_commission"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._bakingRewardCommission) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._bakingRewardCommission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerEvent.BakerSetBakingRewardCommission, rhs: Concordium_V2_BakerEvent.BakerSetBakingRewardCommission) -> Bool {
    if lhs._bakerID != rhs._bakerID {return false}
    if lhs._bakingRewardCommission != rhs._bakingRewardCommission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerEvent.BakerSetFinalizationRewardCommission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BakerEvent.protoMessageName + ".BakerSetFinalizationRewardCommission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_id"),
    2: .standard(proto: "finalization_reward_commission"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._finalizationRewardCommission) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._finalizationRewardCommission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerEvent.BakerSetFinalizationRewardCommission, rhs: Concordium_V2_BakerEvent.BakerSetFinalizationRewardCommission) -> Bool {
    if lhs._bakerID != rhs._bakerID {return false}
    if lhs._finalizationRewardCommission != rhs._finalizationRewardCommission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerEvent.DelegationRemoved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BakerEvent.protoMessageName + ".DelegationRemoved"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegator_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._delegatorID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._delegatorID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerEvent.DelegationRemoved, rhs: Concordium_V2_BakerEvent.DelegationRemoved) -> Bool {
    if lhs._delegatorID != rhs._delegatorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DelegatorId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelegatorId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DelegatorId, rhs: Concordium_V2_DelegatorId) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DelegationEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelegationEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegation_stake_increased"),
    2: .standard(proto: "delegation_stake_decreased"),
    3: .standard(proto: "delegation_set_restake_earnings"),
    4: .standard(proto: "delegation_set_delegation_target"),
    5: .standard(proto: "delegation_added"),
    6: .standard(proto: "delegation_removed"),
    7: .standard(proto: "baker_removed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_DelegationEvent.DelegationStakeIncreased?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .delegationStakeIncreased(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .delegationStakeIncreased(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_DelegationEvent.DelegationStakeDecreased?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .delegationStakeDecreased(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .delegationStakeDecreased(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_DelegationEvent.DelegationSetRestakeEarnings?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .delegationSetRestakeEarnings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .delegationSetRestakeEarnings(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_DelegationEvent.DelegationSetDelegationTarget?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .delegationSetDelegationTarget(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .delegationSetDelegationTarget(v)
        }
      }()
      case 5: try {
        var v: Concordium_V2_DelegatorId?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .delegationAdded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .delegationAdded(v)
        }
      }()
      case 6: try {
        var v: Concordium_V2_DelegatorId?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .delegationRemoved(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .delegationRemoved(v)
        }
      }()
      case 7: try {
        var v: Concordium_V2_DelegationEvent.BakerRemoved?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .bakerRemoved(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .bakerRemoved(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .delegationStakeIncreased?: try {
      guard case .delegationStakeIncreased(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .delegationStakeDecreased?: try {
      guard case .delegationStakeDecreased(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .delegationSetRestakeEarnings?: try {
      guard case .delegationSetRestakeEarnings(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .delegationSetDelegationTarget?: try {
      guard case .delegationSetDelegationTarget(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .delegationAdded?: try {
      guard case .delegationAdded(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .delegationRemoved?: try {
      guard case .delegationRemoved(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .bakerRemoved?: try {
      guard case .bakerRemoved(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DelegationEvent, rhs: Concordium_V2_DelegationEvent) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DelegationEvent.DelegationStakeIncreased: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DelegationEvent.protoMessageName + ".DelegationStakeIncreased"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegator_id"),
    2: .standard(proto: "new_stake"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._delegatorID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newStake) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._delegatorID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newStake {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DelegationEvent.DelegationStakeIncreased, rhs: Concordium_V2_DelegationEvent.DelegationStakeIncreased) -> Bool {
    if lhs._delegatorID != rhs._delegatorID {return false}
    if lhs._newStake != rhs._newStake {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DelegationEvent.DelegationStakeDecreased: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DelegationEvent.protoMessageName + ".DelegationStakeDecreased"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegator_id"),
    2: .standard(proto: "new_stake"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._delegatorID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newStake) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._delegatorID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newStake {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DelegationEvent.DelegationStakeDecreased, rhs: Concordium_V2_DelegationEvent.DelegationStakeDecreased) -> Bool {
    if lhs._delegatorID != rhs._delegatorID {return false}
    if lhs._newStake != rhs._newStake {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DelegationEvent.DelegationSetRestakeEarnings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DelegationEvent.protoMessageName + ".DelegationSetRestakeEarnings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegator_id"),
    2: .standard(proto: "restake_earnings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._delegatorID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.restakeEarnings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._delegatorID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.restakeEarnings != false {
      try visitor.visitSingularBoolField(value: self.restakeEarnings, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DelegationEvent.DelegationSetRestakeEarnings, rhs: Concordium_V2_DelegationEvent.DelegationSetRestakeEarnings) -> Bool {
    if lhs._delegatorID != rhs._delegatorID {return false}
    if lhs.restakeEarnings != rhs.restakeEarnings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DelegationEvent.DelegationSetDelegationTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DelegationEvent.protoMessageName + ".DelegationSetDelegationTarget"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegator_id"),
    2: .standard(proto: "delegation_target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._delegatorID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._delegationTarget) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._delegatorID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._delegationTarget {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DelegationEvent.DelegationSetDelegationTarget, rhs: Concordium_V2_DelegationEvent.DelegationSetDelegationTarget) -> Bool {
    if lhs._delegatorID != rhs._delegatorID {return false}
    if lhs._delegationTarget != rhs._delegationTarget {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DelegationEvent.BakerRemoved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DelegationEvent.protoMessageName + ".BakerRemoved"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DelegationEvent.BakerRemoved, rhs: Concordium_V2_DelegationEvent.BakerRemoved) -> Bool {
    if lhs._bakerID != rhs._bakerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionEffects: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountTransactionEffects"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "none"),
    2: .standard(proto: "module_deployed"),
    3: .standard(proto: "contract_initialized"),
    4: .standard(proto: "contract_update_issued"),
    5: .standard(proto: "account_transfer"),
    6: .standard(proto: "baker_added"),
    7: .standard(proto: "baker_removed"),
    8: .standard(proto: "baker_stake_updated"),
    9: .standard(proto: "baker_restake_earnings_updated"),
    10: .standard(proto: "baker_keys_updated"),
    11: .standard(proto: "encrypted_amount_transferred"),
    12: .standard(proto: "transferred_to_encrypted"),
    13: .standard(proto: "transferred_to_public"),
    14: .standard(proto: "transferred_with_schedule"),
    15: .standard(proto: "credential_keys_updated"),
    16: .standard(proto: "credentials_updated"),
    17: .standard(proto: "data_registered"),
    18: .standard(proto: "baker_configured"),
    19: .standard(proto: "delegation_configured"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_AccountTransactionEffects.None?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .none(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .none(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_ModuleRef?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .moduleDeployed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .moduleDeployed(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_ContractInitializedEvent?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .contractInitialized(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .contractInitialized(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_AccountTransactionEffects.ContractUpdateIssued?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .contractUpdateIssued(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .contractUpdateIssued(v)
        }
      }()
      case 5: try {
        var v: Concordium_V2_AccountTransactionEffects.AccountTransfer?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .accountTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .accountTransfer(v)
        }
      }()
      case 6: try {
        var v: Concordium_V2_BakerEvent.BakerAdded?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .bakerAdded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .bakerAdded(v)
        }
      }()
      case 7: try {
        var v: Concordium_V2_BakerId?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .bakerRemoved(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .bakerRemoved(v)
        }
      }()
      case 8: try {
        var v: Concordium_V2_AccountTransactionEffects.BakerStakeUpdated?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .bakerStakeUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .bakerStakeUpdated(v)
        }
      }()
      case 9: try {
        var v: Concordium_V2_BakerEvent.BakerRestakeEarningsUpdated?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .bakerRestakeEarningsUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .bakerRestakeEarningsUpdated(v)
        }
      }()
      case 10: try {
        var v: Concordium_V2_BakerKeysEvent?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .bakerKeysUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .bakerKeysUpdated(v)
        }
      }()
      case 11: try {
        var v: Concordium_V2_AccountTransactionEffects.EncryptedAmountTransferred?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .encryptedAmountTransferred(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .encryptedAmountTransferred(v)
        }
      }()
      case 12: try {
        var v: Concordium_V2_EncryptedSelfAmountAddedEvent?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .transferredToEncrypted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .transferredToEncrypted(v)
        }
      }()
      case 13: try {
        var v: Concordium_V2_AccountTransactionEffects.TransferredToPublic?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .transferredToPublic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .transferredToPublic(v)
        }
      }()
      case 14: try {
        var v: Concordium_V2_AccountTransactionEffects.TransferredWithSchedule?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .transferredWithSchedule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .transferredWithSchedule(v)
        }
      }()
      case 15: try {
        var v: Concordium_V2_CredentialRegistrationId?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .credentialKeysUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .credentialKeysUpdated(v)
        }
      }()
      case 16: try {
        var v: Concordium_V2_AccountTransactionEffects.CredentialsUpdated?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .credentialsUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .credentialsUpdated(v)
        }
      }()
      case 17: try {
        var v: Concordium_V2_RegisteredData?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .dataRegistered(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .dataRegistered(v)
        }
      }()
      case 18: try {
        var v: Concordium_V2_AccountTransactionEffects.BakerConfigured?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .bakerConfigured(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .bakerConfigured(v)
        }
      }()
      case 19: try {
        var v: Concordium_V2_AccountTransactionEffects.DelegationConfigured?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .delegationConfigured(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .delegationConfigured(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.effect {
    case .none?: try {
      guard case .none(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .moduleDeployed?: try {
      guard case .moduleDeployed(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .contractInitialized?: try {
      guard case .contractInitialized(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .contractUpdateIssued?: try {
      guard case .contractUpdateIssued(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .accountTransfer?: try {
      guard case .accountTransfer(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .bakerAdded?: try {
      guard case .bakerAdded(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .bakerRemoved?: try {
      guard case .bakerRemoved(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .bakerStakeUpdated?: try {
      guard case .bakerStakeUpdated(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .bakerRestakeEarningsUpdated?: try {
      guard case .bakerRestakeEarningsUpdated(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .bakerKeysUpdated?: try {
      guard case .bakerKeysUpdated(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .encryptedAmountTransferred?: try {
      guard case .encryptedAmountTransferred(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .transferredToEncrypted?: try {
      guard case .transferredToEncrypted(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .transferredToPublic?: try {
      guard case .transferredToPublic(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .transferredWithSchedule?: try {
      guard case .transferredWithSchedule(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .credentialKeysUpdated?: try {
      guard case .credentialKeysUpdated(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .credentialsUpdated?: try {
      guard case .credentialsUpdated(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .dataRegistered?: try {
      guard case .dataRegistered(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .bakerConfigured?: try {
      guard case .bakerConfigured(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .delegationConfigured?: try {
      guard case .delegationConfigured(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionEffects, rhs: Concordium_V2_AccountTransactionEffects) -> Bool {
    if lhs.effect != rhs.effect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionEffects.None: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_AccountTransactionEffects.protoMessageName + ".None"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_type"),
    2: .standard(proto: "reject_reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._transactionType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rejectReason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transactionType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rejectReason {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionEffects.None, rhs: Concordium_V2_AccountTransactionEffects.None) -> Bool {
    if lhs._transactionType != rhs._transactionType {return false}
    if lhs._rejectReason != rhs._rejectReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionEffects.ContractUpdateIssued: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_AccountTransactionEffects.protoMessageName + ".ContractUpdateIssued"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "effects"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.effects) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.effects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.effects, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionEffects.ContractUpdateIssued, rhs: Concordium_V2_AccountTransactionEffects.ContractUpdateIssued) -> Bool {
    if lhs.effects != rhs.effects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionEffects.AccountTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_AccountTransactionEffects.protoMessageName + ".AccountTransfer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "receiver"),
    3: .same(proto: "memo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._receiver) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._memo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._receiver {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._memo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionEffects.AccountTransfer, rhs: Concordium_V2_AccountTransactionEffects.AccountTransfer) -> Bool {
    if lhs._amount != rhs._amount {return false}
    if lhs._receiver != rhs._receiver {return false}
    if lhs._memo != rhs._memo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionEffects.BakerStakeUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_AccountTransactionEffects.protoMessageName + ".BakerStakeUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "update"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._update) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._update {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionEffects.BakerStakeUpdated, rhs: Concordium_V2_AccountTransactionEffects.BakerStakeUpdated) -> Bool {
    if lhs._update != rhs._update {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionEffects.EncryptedAmountTransferred: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_AccountTransactionEffects.protoMessageName + ".EncryptedAmountTransferred"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "removed"),
    2: .same(proto: "added"),
    3: .same(proto: "memo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._removed) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._added) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._memo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._removed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._added {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._memo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionEffects.EncryptedAmountTransferred, rhs: Concordium_V2_AccountTransactionEffects.EncryptedAmountTransferred) -> Bool {
    if lhs._removed != rhs._removed {return false}
    if lhs._added != rhs._added {return false}
    if lhs._memo != rhs._memo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionEffects.TransferredToPublic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_AccountTransactionEffects.protoMessageName + ".TransferredToPublic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "removed"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._removed) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._removed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionEffects.TransferredToPublic, rhs: Concordium_V2_AccountTransactionEffects.TransferredToPublic) -> Bool {
    if lhs._removed != rhs._removed {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionEffects.TransferredWithSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_AccountTransactionEffects.protoMessageName + ".TransferredWithSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receiver"),
    2: .same(proto: "amount"),
    3: .same(proto: "memo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._receiver) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._memo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._receiver {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 2)
    }
    try { if let v = self._memo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionEffects.TransferredWithSchedule, rhs: Concordium_V2_AccountTransactionEffects.TransferredWithSchedule) -> Bool {
    if lhs._receiver != rhs._receiver {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs._memo != rhs._memo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionEffects.CredentialsUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_AccountTransactionEffects.protoMessageName + ".CredentialsUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_cred_ids"),
    2: .standard(proto: "removed_cred_ids"),
    3: .standard(proto: "new_threshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.newCredIds) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.removedCredIds) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newThreshold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.newCredIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newCredIds, fieldNumber: 1)
    }
    if !self.removedCredIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.removedCredIds, fieldNumber: 2)
    }
    try { if let v = self._newThreshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionEffects.CredentialsUpdated, rhs: Concordium_V2_AccountTransactionEffects.CredentialsUpdated) -> Bool {
    if lhs.newCredIds != rhs.newCredIds {return false}
    if lhs.removedCredIds != rhs.removedCredIds {return false}
    if lhs._newThreshold != rhs._newThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionEffects.BakerConfigured: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_AccountTransactionEffects.protoMessageName + ".BakerConfigured"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionEffects.BakerConfigured, rhs: Concordium_V2_AccountTransactionEffects.BakerConfigured) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionEffects.DelegationConfigured: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_AccountTransactionEffects.protoMessageName + ".DelegationConfigured"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionEffects.DelegationConfigured, rhs: Concordium_V2_AccountTransactionEffects.DelegationConfigured) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ElectionDifficulty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ElectionDifficulty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ElectionDifficulty, rhs: Concordium_V2_ElectionDifficulty) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_TimeoutParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeoutParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timeout_base"),
    2: .standard(proto: "timeout_increase"),
    3: .standard(proto: "timeout_decrease"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timeoutBase) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timeoutIncrease) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeoutDecrease) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timeoutBase {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timeoutIncrease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timeoutDecrease {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_TimeoutParameters, rhs: Concordium_V2_TimeoutParameters) -> Bool {
    if lhs._timeoutBase != rhs._timeoutBase {return false}
    if lhs._timeoutIncrease != rhs._timeoutIncrease {return false}
    if lhs._timeoutDecrease != rhs._timeoutDecrease {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_FinalizationCommitteeParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalizationCommitteeParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "minimum_finalizers"),
    2: .standard(proto: "maximum_finalizers"),
    3: .standard(proto: "finalizer_relative_stake_threshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.minimumFinalizers) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.maximumFinalizers) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._finalizerRelativeStakeThreshold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.minimumFinalizers != 0 {
      try visitor.visitSingularUInt32Field(value: self.minimumFinalizers, fieldNumber: 1)
    }
    if self.maximumFinalizers != 0 {
      try visitor.visitSingularUInt32Field(value: self.maximumFinalizers, fieldNumber: 2)
    }
    try { if let v = self._finalizerRelativeStakeThreshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_FinalizationCommitteeParameters, rhs: Concordium_V2_FinalizationCommitteeParameters) -> Bool {
    if lhs.minimumFinalizers != rhs.minimumFinalizers {return false}
    if lhs.maximumFinalizers != rhs.maximumFinalizers {return false}
    if lhs._finalizerRelativeStakeThreshold != rhs._finalizerRelativeStakeThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ConsensusParametersV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConsensusParametersV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timeout_parameters"),
    2: .standard(proto: "min_block_time"),
    3: .standard(proto: "block_energy_limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timeoutParameters) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._minBlockTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._blockEnergyLimit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timeoutParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._minBlockTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._blockEnergyLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ConsensusParametersV1, rhs: Concordium_V2_ConsensusParametersV1) -> Bool {
    if lhs._timeoutParameters != rhs._timeoutParameters {return false}
    if lhs._minBlockTime != rhs._minBlockTime {return false}
    if lhs._blockEnergyLimit != rhs._blockEnergyLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ExchangeRate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExchangeRate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ExchangeRate, rhs: Concordium_V2_ExchangeRate) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Ratio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ratio"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numerator"),
    2: .same(proto: "denominator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.numerator) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.denominator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numerator != 0 {
      try visitor.visitSingularUInt64Field(value: self.numerator, fieldNumber: 1)
    }
    if self.denominator != 0 {
      try visitor.visitSingularUInt64Field(value: self.denominator, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Ratio, rhs: Concordium_V2_Ratio) -> Bool {
    if lhs.numerator != rhs.numerator {return false}
    if lhs.denominator != rhs.denominator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_UpdatePublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdatePublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_UpdatePublicKey, rhs: Concordium_V2_UpdatePublicKey) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_UpdateKeysThreshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateKeysThreshold"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_UpdateKeysThreshold, rhs: Concordium_V2_UpdateKeysThreshold) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_UpdateKeysIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateKeysIndex"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_UpdateKeysIndex, rhs: Concordium_V2_UpdateKeysIndex) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_HigherLevelKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HigherLevelKeys"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    2: .same(proto: "threshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._threshold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try { if let v = self._threshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_HigherLevelKeys, rhs: Concordium_V2_HigherLevelKeys) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs._threshold != rhs._threshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccessStructure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessStructure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_public_keys"),
    2: .standard(proto: "access_threshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accessPublicKeys) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accessThreshold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.accessPublicKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessPublicKeys, fieldNumber: 1)
    }
    try { if let v = self._accessThreshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccessStructure, rhs: Concordium_V2_AccessStructure) -> Bool {
    if lhs.accessPublicKeys != rhs.accessPublicKeys {return false}
    if lhs._accessThreshold != rhs._accessThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AuthorizationsV0: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthorizationsV0"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    2: .same(proto: "emergency"),
    3: .same(proto: "protocol"),
    4: .standard(proto: "parameter_consensus"),
    5: .standard(proto: "parameter_euro_per_energy"),
    6: .standard(proto: "parameter_micro_CCD_per_euro"),
    7: .standard(proto: "parameter_foundation_account"),
    8: .standard(proto: "parameter_mint_distribution"),
    9: .standard(proto: "parameter_transaction_fee_distribution"),
    10: .standard(proto: "parameter_gas_rewards"),
    11: .standard(proto: "pool_parameters"),
    12: .standard(proto: "add_anonymity_revoker"),
    13: .standard(proto: "add_identity_provider"),
  ]

  fileprivate class _StorageClass {
    var _keys: [Concordium_V2_UpdatePublicKey] = []
    var _emergency: Concordium_V2_AccessStructure? = nil
    var _protocol: Concordium_V2_AccessStructure? = nil
    var _parameterConsensus: Concordium_V2_AccessStructure? = nil
    var _parameterEuroPerEnergy: Concordium_V2_AccessStructure? = nil
    var _parameterMicroCcdPerEuro: Concordium_V2_AccessStructure? = nil
    var _parameterFoundationAccount: Concordium_V2_AccessStructure? = nil
    var _parameterMintDistribution: Concordium_V2_AccessStructure? = nil
    var _parameterTransactionFeeDistribution: Concordium_V2_AccessStructure? = nil
    var _parameterGasRewards: Concordium_V2_AccessStructure? = nil
    var _poolParameters: Concordium_V2_AccessStructure? = nil
    var _addAnonymityRevoker: Concordium_V2_AccessStructure? = nil
    var _addIdentityProvider: Concordium_V2_AccessStructure? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _keys = source._keys
      _emergency = source._emergency
      _protocol = source._protocol
      _parameterConsensus = source._parameterConsensus
      _parameterEuroPerEnergy = source._parameterEuroPerEnergy
      _parameterMicroCcdPerEuro = source._parameterMicroCcdPerEuro
      _parameterFoundationAccount = source._parameterFoundationAccount
      _parameterMintDistribution = source._parameterMintDistribution
      _parameterTransactionFeeDistribution = source._parameterTransactionFeeDistribution
      _parameterGasRewards = source._parameterGasRewards
      _poolParameters = source._poolParameters
      _addAnonymityRevoker = source._addAnonymityRevoker
      _addIdentityProvider = source._addIdentityProvider
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._keys) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._emergency) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._protocol) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._parameterConsensus) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._parameterEuroPerEnergy) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._parameterMicroCcdPerEuro) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._parameterFoundationAccount) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._parameterMintDistribution) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._parameterTransactionFeeDistribution) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._parameterGasRewards) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._poolParameters) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._addAnonymityRevoker) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._addIdentityProvider) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._keys.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._keys, fieldNumber: 1)
      }
      try { if let v = _storage._emergency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._protocol {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._parameterConsensus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._parameterEuroPerEnergy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._parameterMicroCcdPerEuro {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._parameterFoundationAccount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._parameterMintDistribution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._parameterTransactionFeeDistribution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._parameterGasRewards {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._poolParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._addAnonymityRevoker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._addIdentityProvider {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AuthorizationsV0, rhs: Concordium_V2_AuthorizationsV0) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._keys != rhs_storage._keys {return false}
        if _storage._emergency != rhs_storage._emergency {return false}
        if _storage._protocol != rhs_storage._protocol {return false}
        if _storage._parameterConsensus != rhs_storage._parameterConsensus {return false}
        if _storage._parameterEuroPerEnergy != rhs_storage._parameterEuroPerEnergy {return false}
        if _storage._parameterMicroCcdPerEuro != rhs_storage._parameterMicroCcdPerEuro {return false}
        if _storage._parameterFoundationAccount != rhs_storage._parameterFoundationAccount {return false}
        if _storage._parameterMintDistribution != rhs_storage._parameterMintDistribution {return false}
        if _storage._parameterTransactionFeeDistribution != rhs_storage._parameterTransactionFeeDistribution {return false}
        if _storage._parameterGasRewards != rhs_storage._parameterGasRewards {return false}
        if _storage._poolParameters != rhs_storage._poolParameters {return false}
        if _storage._addAnonymityRevoker != rhs_storage._addAnonymityRevoker {return false}
        if _storage._addIdentityProvider != rhs_storage._addIdentityProvider {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AuthorizationsV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthorizationsV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v0"),
    2: .standard(proto: "parameter_cooldown"),
    3: .standard(proto: "parameter_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._v0) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parameterCooldown) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._parameterTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._v0 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._parameterCooldown {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._parameterTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AuthorizationsV1, rhs: Concordium_V2_AuthorizationsV1) -> Bool {
    if lhs._v0 != rhs._v0 {return false}
    if lhs._parameterCooldown != rhs._parameterCooldown {return false}
    if lhs._parameterTime != rhs._parameterTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Description: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Description"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
    3: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Description, rhs: Concordium_V2_Description) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ArInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
    2: .same(proto: "description"),
    3: .standard(proto: "public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identity) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ArInfo, rhs: Concordium_V2_ArInfo) -> Bool {
    if lhs._identity != rhs._identity {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ArInfo.ArIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_ArInfo.protoMessageName + ".ArIdentity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ArInfo.ArIdentity, rhs: Concordium_V2_ArInfo.ArIdentity) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ArInfo.ArPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_ArInfo.protoMessageName + ".ArPublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ArInfo.ArPublicKey, rhs: Concordium_V2_ArInfo.ArPublicKey) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_IpIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IpIdentity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_IpIdentity, rhs: Concordium_V2_IpIdentity) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_IpInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IpInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
    2: .same(proto: "description"),
    3: .standard(proto: "verify_key"),
    4: .standard(proto: "cdi_verify_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identity) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._verifyKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._cdiVerifyKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._verifyKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._cdiVerifyKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_IpInfo, rhs: Concordium_V2_IpInfo) -> Bool {
    if lhs._identity != rhs._identity {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._verifyKey != rhs._verifyKey {return false}
    if lhs._cdiVerifyKey != rhs._cdiVerifyKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_IpInfo.IpVerifyKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_IpInfo.protoMessageName + ".IpVerifyKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_IpInfo.IpVerifyKey, rhs: Concordium_V2_IpInfo.IpVerifyKey) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_IpInfo.IpCdiVerifyKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_IpInfo.protoMessageName + ".IpCdiVerifyKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_IpInfo.IpCdiVerifyKey, rhs: Concordium_V2_IpInfo.IpCdiVerifyKey) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DurationSeconds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DurationSeconds"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DurationSeconds, rhs: Concordium_V2_DurationSeconds) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InclusiveRangeAmountFraction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InclusiveRangeAmountFraction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .standard(proto: "max_"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._min) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._max_) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._min {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._max_ {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InclusiveRangeAmountFraction, rhs: Concordium_V2_InclusiveRangeAmountFraction) -> Bool {
    if lhs._min != rhs._min {return false}
    if lhs._max_ != rhs._max_ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_CommissionRanges: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommissionRanges"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "finalization"),
    2: .same(proto: "baking"),
    3: .same(proto: "transaction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._finalization) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._baking) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._finalization {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._baking {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_CommissionRanges, rhs: Concordium_V2_CommissionRanges) -> Bool {
    if lhs._finalization != rhs._finalization {return false}
    if lhs._baking != rhs._baking {return false}
    if lhs._transaction != rhs._transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_CapitalBound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CapitalBound"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_CapitalBound, rhs: Concordium_V2_CapitalBound) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_LeverageFactor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeverageFactor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_LeverageFactor, rhs: Concordium_V2_LeverageFactor) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Epoch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Epoch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Epoch, rhs: Concordium_V2_Epoch) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Round: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Round"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Round, rhs: Concordium_V2_Round) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_RewardPeriodLength: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RewardPeriodLength"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_RewardPeriodLength, rhs: Concordium_V2_RewardPeriodLength) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_MintRate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MintRate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mantissa"),
    2: .same(proto: "exponent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.mantissa) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.exponent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mantissa != 0 {
      try visitor.visitSingularUInt32Field(value: self.mantissa, fieldNumber: 1)
    }
    if self.exponent != 0 {
      try visitor.visitSingularUInt32Field(value: self.exponent, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_MintRate, rhs: Concordium_V2_MintRate) -> Bool {
    if lhs.mantissa != rhs.mantissa {return false}
    if lhs.exponent != rhs.exponent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_CooldownParametersCpv1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CooldownParametersCpv1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_owner_cooldown"),
    2: .standard(proto: "delegator_cooldown"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._poolOwnerCooldown) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._delegatorCooldown) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._poolOwnerCooldown {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._delegatorCooldown {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_CooldownParametersCpv1, rhs: Concordium_V2_CooldownParametersCpv1) -> Bool {
    if lhs._poolOwnerCooldown != rhs._poolOwnerCooldown {return false}
    if lhs._delegatorCooldown != rhs._delegatorCooldown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PoolParametersCpv1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolParametersCpv1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "passive_finalization_commission"),
    2: .standard(proto: "passive_baking_commission"),
    3: .standard(proto: "passive_transaction_commission"),
    4: .standard(proto: "commission_bounds"),
    5: .standard(proto: "minimum_equity_capital"),
    6: .standard(proto: "capital_bound"),
    7: .standard(proto: "leverage_bound"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._passiveFinalizationCommission) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._passiveBakingCommission) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._passiveTransactionCommission) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._commissionBounds) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._minimumEquityCapital) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._capitalBound) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._leverageBound) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._passiveFinalizationCommission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._passiveBakingCommission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._passiveTransactionCommission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._commissionBounds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._minimumEquityCapital {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._capitalBound {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._leverageBound {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PoolParametersCpv1, rhs: Concordium_V2_PoolParametersCpv1) -> Bool {
    if lhs._passiveFinalizationCommission != rhs._passiveFinalizationCommission {return false}
    if lhs._passiveBakingCommission != rhs._passiveBakingCommission {return false}
    if lhs._passiveTransactionCommission != rhs._passiveTransactionCommission {return false}
    if lhs._commissionBounds != rhs._commissionBounds {return false}
    if lhs._minimumEquityCapital != rhs._minimumEquityCapital {return false}
    if lhs._capitalBound != rhs._capitalBound {return false}
    if lhs._leverageBound != rhs._leverageBound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_TimeParametersCpv1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeParametersCpv1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reward_period_length"),
    2: .standard(proto: "mint_per_payday"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rewardPeriodLength) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mintPerPayday) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rewardPeriodLength {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._mintPerPayday {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_TimeParametersCpv1, rhs: Concordium_V2_TimeParametersCpv1) -> Bool {
    if lhs._rewardPeriodLength != rhs._rewardPeriodLength {return false}
    if lhs._mintPerPayday != rhs._mintPerPayday {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_MintDistributionCpv1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MintDistributionCpv1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baking_reward"),
    2: .standard(proto: "finalization_reward"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakingReward) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._finalizationReward) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakingReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._finalizationReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_MintDistributionCpv1, rhs: Concordium_V2_MintDistributionCpv1) -> Bool {
    if lhs._bakingReward != rhs._bakingReward {return false}
    if lhs._finalizationReward != rhs._finalizationReward {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ProtocolUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProtocolUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_"),
    2: .standard(proto: "specification_url"),
    3: .same(proto: "specificationHash"),
    4: .standard(proto: "specification_auxiliary_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message_) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.specificationURL) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._specificationHash) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.specificationAuxiliaryData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message_.isEmpty {
      try visitor.visitSingularStringField(value: self.message_, fieldNumber: 1)
    }
    if !self.specificationURL.isEmpty {
      try visitor.visitSingularStringField(value: self.specificationURL, fieldNumber: 2)
    }
    try { if let v = self._specificationHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.specificationAuxiliaryData.isEmpty {
      try visitor.visitSingularBytesField(value: self.specificationAuxiliaryData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ProtocolUpdate, rhs: Concordium_V2_ProtocolUpdate) -> Bool {
    if lhs.message_ != rhs.message_ {return false}
    if lhs.specificationURL != rhs.specificationURL {return false}
    if lhs._specificationHash != rhs._specificationHash {return false}
    if lhs.specificationAuxiliaryData != rhs.specificationAuxiliaryData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_MintDistributionCpv0: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MintDistributionCpv0"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mint_per_slot"),
    2: .standard(proto: "baking_reward"),
    3: .standard(proto: "finalization_reward"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mintPerSlot) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._bakingReward) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._finalizationReward) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mintPerSlot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._bakingReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._finalizationReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_MintDistributionCpv0, rhs: Concordium_V2_MintDistributionCpv0) -> Bool {
    if lhs._mintPerSlot != rhs._mintPerSlot {return false}
    if lhs._bakingReward != rhs._bakingReward {return false}
    if lhs._finalizationReward != rhs._finalizationReward {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_TransactionFeeDistribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionFeeDistribution"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "baker"),
    2: .standard(proto: "gas_account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baker) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gasAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._gasAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_TransactionFeeDistribution, rhs: Concordium_V2_TransactionFeeDistribution) -> Bool {
    if lhs._baker != rhs._baker {return false}
    if lhs._gasAccount != rhs._gasAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_GasRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GasRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "baker"),
    2: .standard(proto: "finalization_proof"),
    3: .standard(proto: "account_creation"),
    4: .standard(proto: "chain_update"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baker) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._finalizationProof) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._accountCreation) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._chainUpdate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._finalizationProof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._accountCreation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._chainUpdate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_GasRewards, rhs: Concordium_V2_GasRewards) -> Bool {
    if lhs._baker != rhs._baker {return false}
    if lhs._finalizationProof != rhs._finalizationProof {return false}
    if lhs._accountCreation != rhs._accountCreation {return false}
    if lhs._chainUpdate != rhs._chainUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_GasRewardsCpv2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GasRewardsCpv2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "baker"),
    3: .standard(proto: "account_creation"),
    4: .standard(proto: "chain_update"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baker) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._accountCreation) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._chainUpdate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountCreation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._chainUpdate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_GasRewardsCpv2, rhs: Concordium_V2_GasRewardsCpv2) -> Bool {
    if lhs._baker != rhs._baker {return false}
    if lhs._accountCreation != rhs._accountCreation {return false}
    if lhs._chainUpdate != rhs._chainUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerStakeThreshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BakerStakeThreshold"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_stake_threshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerStakeThreshold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerStakeThreshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerStakeThreshold, rhs: Concordium_V2_BakerStakeThreshold) -> Bool {
    if lhs._bakerStakeThreshold != rhs._bakerStakeThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_RootUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RootUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_keys_update"),
    2: .standard(proto: "level_1_keys_update"),
    3: .standard(proto: "level_2_keys_update_v0"),
    4: .standard(proto: "level_2_keys_update_v1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_HigherLevelKeys?
        var hadOneofValue = false
        if let current = self.updateType {
          hadOneofValue = true
          if case .rootKeysUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.updateType = .rootKeysUpdate(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_HigherLevelKeys?
        var hadOneofValue = false
        if let current = self.updateType {
          hadOneofValue = true
          if case .level1KeysUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.updateType = .level1KeysUpdate(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_AuthorizationsV0?
        var hadOneofValue = false
        if let current = self.updateType {
          hadOneofValue = true
          if case .level2KeysUpdateV0(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.updateType = .level2KeysUpdateV0(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_AuthorizationsV1?
        var hadOneofValue = false
        if let current = self.updateType {
          hadOneofValue = true
          if case .level2KeysUpdateV1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.updateType = .level2KeysUpdateV1(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.updateType {
    case .rootKeysUpdate?: try {
      guard case .rootKeysUpdate(let v)? = self.updateType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .level1KeysUpdate?: try {
      guard case .level1KeysUpdate(let v)? = self.updateType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .level2KeysUpdateV0?: try {
      guard case .level2KeysUpdateV0(let v)? = self.updateType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .level2KeysUpdateV1?: try {
      guard case .level2KeysUpdateV1(let v)? = self.updateType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_RootUpdate, rhs: Concordium_V2_RootUpdate) -> Bool {
    if lhs.updateType != rhs.updateType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Level1Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Level1Update"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "level_1_keys_update"),
    2: .standard(proto: "level_2_keys_update_v0"),
    3: .standard(proto: "level_2_keys_update_v1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_HigherLevelKeys?
        var hadOneofValue = false
        if let current = self.updateType {
          hadOneofValue = true
          if case .level1KeysUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.updateType = .level1KeysUpdate(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_AuthorizationsV0?
        var hadOneofValue = false
        if let current = self.updateType {
          hadOneofValue = true
          if case .level2KeysUpdateV0(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.updateType = .level2KeysUpdateV0(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_AuthorizationsV1?
        var hadOneofValue = false
        if let current = self.updateType {
          hadOneofValue = true
          if case .level2KeysUpdateV1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.updateType = .level2KeysUpdateV1(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.updateType {
    case .level1KeysUpdate?: try {
      guard case .level1KeysUpdate(let v)? = self.updateType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .level2KeysUpdateV0?: try {
      guard case .level2KeysUpdateV0(let v)? = self.updateType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .level2KeysUpdateV1?: try {
      guard case .level2KeysUpdateV1(let v)? = self.updateType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Level1Update, rhs: Concordium_V2_Level1Update) -> Bool {
    if lhs.updateType != rhs.updateType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_UpdatePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdatePayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "protocol_update"),
    2: .standard(proto: "election_difficulty_update"),
    3: .standard(proto: "euro_per_energy_update"),
    4: .standard(proto: "micro_ccd_per_euro_update"),
    5: .standard(proto: "foundation_account_update"),
    6: .standard(proto: "mint_distribution_update"),
    7: .standard(proto: "transaction_fee_distribution_update"),
    8: .standard(proto: "gas_rewards_update"),
    9: .standard(proto: "baker_stake_threshold_update"),
    10: .standard(proto: "root_update"),
    11: .standard(proto: "level_1_update"),
    12: .standard(proto: "add_anonymity_revoker_update"),
    13: .standard(proto: "add_identity_provider_update"),
    14: .standard(proto: "cooldown_parameters_cpv_1_update"),
    15: .standard(proto: "pool_parameters_cpv_1_update"),
    16: .standard(proto: "time_parameters_cpv_1_update"),
    17: .standard(proto: "mint_distribution_cpv_1_update"),
    18: .standard(proto: "gas_rewards_cpv_2_update"),
    19: .standard(proto: "timeout_parameters_update"),
    20: .standard(proto: "min_block_time_update"),
    21: .standard(proto: "block_energy_limit_update"),
    22: .standard(proto: "finalization_committee_parameters_update"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_ProtocolUpdate?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .protocolUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .protocolUpdate(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_ElectionDifficulty?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .electionDifficultyUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .electionDifficultyUpdate(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_ExchangeRate?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .euroPerEnergyUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .euroPerEnergyUpdate(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_ExchangeRate?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .microCcdPerEuroUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .microCcdPerEuroUpdate(v)
        }
      }()
      case 5: try {
        var v: Concordium_V2_AccountAddress?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .foundationAccountUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .foundationAccountUpdate(v)
        }
      }()
      case 6: try {
        var v: Concordium_V2_MintDistributionCpv0?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .mintDistributionUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .mintDistributionUpdate(v)
        }
      }()
      case 7: try {
        var v: Concordium_V2_TransactionFeeDistribution?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .transactionFeeDistributionUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .transactionFeeDistributionUpdate(v)
        }
      }()
      case 8: try {
        var v: Concordium_V2_GasRewards?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .gasRewardsUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .gasRewardsUpdate(v)
        }
      }()
      case 9: try {
        var v: Concordium_V2_BakerStakeThreshold?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .bakerStakeThresholdUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .bakerStakeThresholdUpdate(v)
        }
      }()
      case 10: try {
        var v: Concordium_V2_RootUpdate?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .rootUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .rootUpdate(v)
        }
      }()
      case 11: try {
        var v: Concordium_V2_Level1Update?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .level1Update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .level1Update(v)
        }
      }()
      case 12: try {
        var v: Concordium_V2_ArInfo?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .addAnonymityRevokerUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .addAnonymityRevokerUpdate(v)
        }
      }()
      case 13: try {
        var v: Concordium_V2_IpInfo?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .addIdentityProviderUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .addIdentityProviderUpdate(v)
        }
      }()
      case 14: try {
        var v: Concordium_V2_CooldownParametersCpv1?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .cooldownParametersCpv1Update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .cooldownParametersCpv1Update(v)
        }
      }()
      case 15: try {
        var v: Concordium_V2_PoolParametersCpv1?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .poolParametersCpv1Update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .poolParametersCpv1Update(v)
        }
      }()
      case 16: try {
        var v: Concordium_V2_TimeParametersCpv1?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .timeParametersCpv1Update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .timeParametersCpv1Update(v)
        }
      }()
      case 17: try {
        var v: Concordium_V2_MintDistributionCpv1?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .mintDistributionCpv1Update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .mintDistributionCpv1Update(v)
        }
      }()
      case 18: try {
        var v: Concordium_V2_GasRewardsCpv2?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .gasRewardsCpv2Update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .gasRewardsCpv2Update(v)
        }
      }()
      case 19: try {
        var v: Concordium_V2_TimeoutParameters?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .timeoutParametersUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .timeoutParametersUpdate(v)
        }
      }()
      case 20: try {
        var v: Concordium_V2_Duration?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .minBlockTimeUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .minBlockTimeUpdate(v)
        }
      }()
      case 21: try {
        var v: Concordium_V2_Energy?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .blockEnergyLimitUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .blockEnergyLimitUpdate(v)
        }
      }()
      case 22: try {
        var v: Concordium_V2_FinalizationCommitteeParameters?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .finalizationCommitteeParametersUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .finalizationCommitteeParametersUpdate(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .protocolUpdate?: try {
      guard case .protocolUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .electionDifficultyUpdate?: try {
      guard case .electionDifficultyUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .euroPerEnergyUpdate?: try {
      guard case .euroPerEnergyUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .microCcdPerEuroUpdate?: try {
      guard case .microCcdPerEuroUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .foundationAccountUpdate?: try {
      guard case .foundationAccountUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .mintDistributionUpdate?: try {
      guard case .mintDistributionUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .transactionFeeDistributionUpdate?: try {
      guard case .transactionFeeDistributionUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .gasRewardsUpdate?: try {
      guard case .gasRewardsUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .bakerStakeThresholdUpdate?: try {
      guard case .bakerStakeThresholdUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .rootUpdate?: try {
      guard case .rootUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .level1Update?: try {
      guard case .level1Update(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .addAnonymityRevokerUpdate?: try {
      guard case .addAnonymityRevokerUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .addIdentityProviderUpdate?: try {
      guard case .addIdentityProviderUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .cooldownParametersCpv1Update?: try {
      guard case .cooldownParametersCpv1Update(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .poolParametersCpv1Update?: try {
      guard case .poolParametersCpv1Update(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .timeParametersCpv1Update?: try {
      guard case .timeParametersCpv1Update(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .mintDistributionCpv1Update?: try {
      guard case .mintDistributionCpv1Update(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .gasRewardsCpv2Update?: try {
      guard case .gasRewardsCpv2Update(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .timeoutParametersUpdate?: try {
      guard case .timeoutParametersUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .minBlockTimeUpdate?: try {
      guard case .minBlockTimeUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .blockEnergyLimitUpdate?: try {
      guard case .blockEnergyLimitUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .finalizationCommitteeParametersUpdate?: try {
      guard case .finalizationCommitteeParametersUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_UpdatePayload, rhs: Concordium_V2_UpdatePayload) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountTransactionDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cost"),
    2: .same(proto: "sender"),
    3: .same(proto: "effects"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cost) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sender) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._effects) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cost {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._effects {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionDetails, rhs: Concordium_V2_AccountTransactionDetails) -> Bool {
    if lhs._cost != rhs._cost {return false}
    if lhs._sender != rhs._sender {return false}
    if lhs._effects != rhs._effects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountCreationDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountCreationDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "credential_type"),
    2: .same(proto: "address"),
    3: .standard(proto: "reg_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.credentialType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._regID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.credentialType != .initial {
      try visitor.visitSingularEnumField(value: self.credentialType, fieldNumber: 1)
    }
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._regID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountCreationDetails, rhs: Concordium_V2_AccountCreationDetails) -> Bool {
    if lhs.credentialType != rhs.credentialType {return false}
    if lhs._address != rhs._address {return false}
    if lhs._regID != rhs._regID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_TransactionTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_TransactionTime, rhs: Concordium_V2_TransactionTime) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_UpdateDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "effective_time"),
    2: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._effectiveTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._effectiveTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_UpdateDetails, rhs: Concordium_V2_UpdateDetails) -> Bool {
    if lhs._effectiveTime != rhs._effectiveTime {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockItemSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockItemSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "energy_cost"),
    3: .same(proto: "hash"),
    4: .standard(proto: "account_transaction"),
    5: .standard(proto: "account_creation"),
    6: .same(proto: "update"),
  ]

  fileprivate class _StorageClass {
    var _index: Concordium_V2_BlockItemSummary.TransactionIndex? = nil
    var _energyCost: Concordium_V2_Energy? = nil
    var _hash: Concordium_V2_TransactionHash? = nil
    var _details: Concordium_V2_BlockItemSummary.OneOf_Details?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _index = source._index
      _energyCost = source._energyCost
      _hash = source._hash
      _details = source._details
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._index) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._energyCost) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._hash) }()
        case 4: try {
          var v: Concordium_V2_AccountTransactionDetails?
          var hadOneofValue = false
          if let current = _storage._details {
            hadOneofValue = true
            if case .accountTransaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._details = .accountTransaction(v)
          }
        }()
        case 5: try {
          var v: Concordium_V2_AccountCreationDetails?
          var hadOneofValue = false
          if let current = _storage._details {
            hadOneofValue = true
            if case .accountCreation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._details = .accountCreation(v)
          }
        }()
        case 6: try {
          var v: Concordium_V2_UpdateDetails?
          var hadOneofValue = false
          if let current = _storage._details {
            hadOneofValue = true
            if case .update(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._details = .update(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._index {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._energyCost {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._hash {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      switch _storage._details {
      case .accountTransaction?: try {
        guard case .accountTransaction(let v)? = _storage._details else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .accountCreation?: try {
        guard case .accountCreation(let v)? = _storage._details else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .update?: try {
        guard case .update(let v)? = _storage._details else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockItemSummary, rhs: Concordium_V2_BlockItemSummary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._index != rhs_storage._index {return false}
        if _storage._energyCost != rhs_storage._energyCost {return false}
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._details != rhs_storage._details {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockItemSummary.TransactionIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlockItemSummary.protoMessageName + ".TransactionIndex"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockItemSummary.TransactionIndex, rhs: Concordium_V2_BlockItemSummary.TransactionIndex) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_GenesisIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisIndex"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_GenesisIndex, rhs: Concordium_V2_GenesisIndex) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ConsensusInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConsensusInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "best_block"),
    2: .standard(proto: "genesis_block"),
    3: .standard(proto: "genesis_time"),
    4: .standard(proto: "slot_duration"),
    5: .standard(proto: "epoch_duration"),
    6: .standard(proto: "last_finalized_block"),
    7: .standard(proto: "best_block_height"),
    8: .standard(proto: "last_finalized_block_height"),
    9: .standard(proto: "blocks_received_count"),
    10: .standard(proto: "block_last_received_time"),
    11: .standard(proto: "block_receive_latency_ema"),
    12: .standard(proto: "block_receive_latency_emsd"),
    13: .standard(proto: "block_receive_period_ema"),
    14: .standard(proto: "block_receive_period_emsd"),
    15: .standard(proto: "blocks_verified_count"),
    16: .standard(proto: "block_last_arrived_time"),
    17: .standard(proto: "block_arrive_latency_ema"),
    18: .standard(proto: "block_arrive_latency_emsd"),
    19: .standard(proto: "block_arrive_period_ema"),
    20: .standard(proto: "block_arrive_period_emsd"),
    21: .standard(proto: "transactions_per_block_ema"),
    22: .standard(proto: "transactions_per_block_emsd"),
    23: .standard(proto: "finalization_count"),
    24: .standard(proto: "last_finalized_time"),
    25: .standard(proto: "finalization_period_ema"),
    26: .standard(proto: "finalization_period_emsd"),
    27: .standard(proto: "protocol_version"),
    28: .standard(proto: "genesis_index"),
    29: .standard(proto: "current_era_genesis_block"),
    30: .standard(proto: "current_era_genesis_time"),
    31: .standard(proto: "current_timeout_duration"),
    32: .standard(proto: "current_round"),
    33: .standard(proto: "current_epoch"),
    34: .standard(proto: "trigger_block_time"),
  ]

  fileprivate class _StorageClass {
    var _bestBlock: Concordium_V2_BlockHash? = nil
    var _genesisBlock: Concordium_V2_BlockHash? = nil
    var _genesisTime: Concordium_V2_Timestamp? = nil
    var _slotDuration: Concordium_V2_Duration? = nil
    var _epochDuration: Concordium_V2_Duration? = nil
    var _lastFinalizedBlock: Concordium_V2_BlockHash? = nil
    var _bestBlockHeight: Concordium_V2_AbsoluteBlockHeight? = nil
    var _lastFinalizedBlockHeight: Concordium_V2_AbsoluteBlockHeight? = nil
    var _blocksReceivedCount: UInt32 = 0
    var _blockLastReceivedTime: Concordium_V2_Timestamp? = nil
    var _blockReceiveLatencyEma: Double = 0
    var _blockReceiveLatencyEmsd: Double = 0
    var _blockReceivePeriodEma: Double? = nil
    var _blockReceivePeriodEmsd: Double? = nil
    var _blocksVerifiedCount: UInt32 = 0
    var _blockLastArrivedTime: Concordium_V2_Timestamp? = nil
    var _blockArriveLatencyEma: Double = 0
    var _blockArriveLatencyEmsd: Double = 0
    var _blockArrivePeriodEma: Double? = nil
    var _blockArrivePeriodEmsd: Double? = nil
    var _transactionsPerBlockEma: Double = 0
    var _transactionsPerBlockEmsd: Double = 0
    var _finalizationCount: UInt32 = 0
    var _lastFinalizedTime: Concordium_V2_Timestamp? = nil
    var _finalizationPeriodEma: Double? = nil
    var _finalizationPeriodEmsd: Double? = nil
    var _protocolVersion: Concordium_V2_ProtocolVersion = .protocolVersion1
    var _genesisIndex: Concordium_V2_GenesisIndex? = nil
    var _currentEraGenesisBlock: Concordium_V2_BlockHash? = nil
    var _currentEraGenesisTime: Concordium_V2_Timestamp? = nil
    var _currentTimeoutDuration: Concordium_V2_Duration? = nil
    var _currentRound: Concordium_V2_Round? = nil
    var _currentEpoch: Concordium_V2_Epoch? = nil
    var _triggerBlockTime: Concordium_V2_Timestamp? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _bestBlock = source._bestBlock
      _genesisBlock = source._genesisBlock
      _genesisTime = source._genesisTime
      _slotDuration = source._slotDuration
      _epochDuration = source._epochDuration
      _lastFinalizedBlock = source._lastFinalizedBlock
      _bestBlockHeight = source._bestBlockHeight
      _lastFinalizedBlockHeight = source._lastFinalizedBlockHeight
      _blocksReceivedCount = source._blocksReceivedCount
      _blockLastReceivedTime = source._blockLastReceivedTime
      _blockReceiveLatencyEma = source._blockReceiveLatencyEma
      _blockReceiveLatencyEmsd = source._blockReceiveLatencyEmsd
      _blockReceivePeriodEma = source._blockReceivePeriodEma
      _blockReceivePeriodEmsd = source._blockReceivePeriodEmsd
      _blocksVerifiedCount = source._blocksVerifiedCount
      _blockLastArrivedTime = source._blockLastArrivedTime
      _blockArriveLatencyEma = source._blockArriveLatencyEma
      _blockArriveLatencyEmsd = source._blockArriveLatencyEmsd
      _blockArrivePeriodEma = source._blockArrivePeriodEma
      _blockArrivePeriodEmsd = source._blockArrivePeriodEmsd
      _transactionsPerBlockEma = source._transactionsPerBlockEma
      _transactionsPerBlockEmsd = source._transactionsPerBlockEmsd
      _finalizationCount = source._finalizationCount
      _lastFinalizedTime = source._lastFinalizedTime
      _finalizationPeriodEma = source._finalizationPeriodEma
      _finalizationPeriodEmsd = source._finalizationPeriodEmsd
      _protocolVersion = source._protocolVersion
      _genesisIndex = source._genesisIndex
      _currentEraGenesisBlock = source._currentEraGenesisBlock
      _currentEraGenesisTime = source._currentEraGenesisTime
      _currentTimeoutDuration = source._currentTimeoutDuration
      _currentRound = source._currentRound
      _currentEpoch = source._currentEpoch
      _triggerBlockTime = source._triggerBlockTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._bestBlock) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._genesisBlock) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._genesisTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._slotDuration) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._epochDuration) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._lastFinalizedBlock) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._bestBlockHeight) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lastFinalizedBlockHeight) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._blocksReceivedCount) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._blockLastReceivedTime) }()
        case 11: try { try decoder.decodeSingularDoubleField(value: &_storage._blockReceiveLatencyEma) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._blockReceiveLatencyEmsd) }()
        case 13: try { try decoder.decodeSingularDoubleField(value: &_storage._blockReceivePeriodEma) }()
        case 14: try { try decoder.decodeSingularDoubleField(value: &_storage._blockReceivePeriodEmsd) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._blocksVerifiedCount) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._blockLastArrivedTime) }()
        case 17: try { try decoder.decodeSingularDoubleField(value: &_storage._blockArriveLatencyEma) }()
        case 18: try { try decoder.decodeSingularDoubleField(value: &_storage._blockArriveLatencyEmsd) }()
        case 19: try { try decoder.decodeSingularDoubleField(value: &_storage._blockArrivePeriodEma) }()
        case 20: try { try decoder.decodeSingularDoubleField(value: &_storage._blockArrivePeriodEmsd) }()
        case 21: try { try decoder.decodeSingularDoubleField(value: &_storage._transactionsPerBlockEma) }()
        case 22: try { try decoder.decodeSingularDoubleField(value: &_storage._transactionsPerBlockEmsd) }()
        case 23: try { try decoder.decodeSingularUInt32Field(value: &_storage._finalizationCount) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._lastFinalizedTime) }()
        case 25: try { try decoder.decodeSingularDoubleField(value: &_storage._finalizationPeriodEma) }()
        case 26: try { try decoder.decodeSingularDoubleField(value: &_storage._finalizationPeriodEmsd) }()
        case 27: try { try decoder.decodeSingularEnumField(value: &_storage._protocolVersion) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._genesisIndex) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._currentEraGenesisBlock) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._currentEraGenesisTime) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._currentTimeoutDuration) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._currentRound) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._currentEpoch) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._triggerBlockTime) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._bestBlock {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._genesisBlock {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._genesisTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._slotDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._epochDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._lastFinalizedBlock {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._bestBlockHeight {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._lastFinalizedBlockHeight {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._blocksReceivedCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._blocksReceivedCount, fieldNumber: 9)
      }
      try { if let v = _storage._blockLastReceivedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._blockReceiveLatencyEma.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._blockReceiveLatencyEma, fieldNumber: 11)
      }
      if _storage._blockReceiveLatencyEmsd.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._blockReceiveLatencyEmsd, fieldNumber: 12)
      }
      try { if let v = _storage._blockReceivePeriodEma {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._blockReceivePeriodEmsd {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 14)
      } }()
      if _storage._blocksVerifiedCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._blocksVerifiedCount, fieldNumber: 15)
      }
      try { if let v = _storage._blockLastArrivedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._blockArriveLatencyEma.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._blockArriveLatencyEma, fieldNumber: 17)
      }
      if _storage._blockArriveLatencyEmsd.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._blockArriveLatencyEmsd, fieldNumber: 18)
      }
      try { if let v = _storage._blockArrivePeriodEma {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._blockArrivePeriodEmsd {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 20)
      } }()
      if _storage._transactionsPerBlockEma.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._transactionsPerBlockEma, fieldNumber: 21)
      }
      if _storage._transactionsPerBlockEmsd.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._transactionsPerBlockEmsd, fieldNumber: 22)
      }
      if _storage._finalizationCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._finalizationCount, fieldNumber: 23)
      }
      try { if let v = _storage._lastFinalizedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._finalizationPeriodEma {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._finalizationPeriodEmsd {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 26)
      } }()
      if _storage._protocolVersion != .protocolVersion1 {
        try visitor.visitSingularEnumField(value: _storage._protocolVersion, fieldNumber: 27)
      }
      try { if let v = _storage._genesisIndex {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._currentEraGenesisBlock {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._currentEraGenesisTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._currentTimeoutDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._currentRound {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._currentEpoch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      } }()
      try { if let v = _storage._triggerBlockTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ConsensusInfo, rhs: Concordium_V2_ConsensusInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._bestBlock != rhs_storage._bestBlock {return false}
        if _storage._genesisBlock != rhs_storage._genesisBlock {return false}
        if _storage._genesisTime != rhs_storage._genesisTime {return false}
        if _storage._slotDuration != rhs_storage._slotDuration {return false}
        if _storage._epochDuration != rhs_storage._epochDuration {return false}
        if _storage._lastFinalizedBlock != rhs_storage._lastFinalizedBlock {return false}
        if _storage._bestBlockHeight != rhs_storage._bestBlockHeight {return false}
        if _storage._lastFinalizedBlockHeight != rhs_storage._lastFinalizedBlockHeight {return false}
        if _storage._blocksReceivedCount != rhs_storage._blocksReceivedCount {return false}
        if _storage._blockLastReceivedTime != rhs_storage._blockLastReceivedTime {return false}
        if _storage._blockReceiveLatencyEma != rhs_storage._blockReceiveLatencyEma {return false}
        if _storage._blockReceiveLatencyEmsd != rhs_storage._blockReceiveLatencyEmsd {return false}
        if _storage._blockReceivePeriodEma != rhs_storage._blockReceivePeriodEma {return false}
        if _storage._blockReceivePeriodEmsd != rhs_storage._blockReceivePeriodEmsd {return false}
        if _storage._blocksVerifiedCount != rhs_storage._blocksVerifiedCount {return false}
        if _storage._blockLastArrivedTime != rhs_storage._blockLastArrivedTime {return false}
        if _storage._blockArriveLatencyEma != rhs_storage._blockArriveLatencyEma {return false}
        if _storage._blockArriveLatencyEmsd != rhs_storage._blockArriveLatencyEmsd {return false}
        if _storage._blockArrivePeriodEma != rhs_storage._blockArrivePeriodEma {return false}
        if _storage._blockArrivePeriodEmsd != rhs_storage._blockArrivePeriodEmsd {return false}
        if _storage._transactionsPerBlockEma != rhs_storage._transactionsPerBlockEma {return false}
        if _storage._transactionsPerBlockEmsd != rhs_storage._transactionsPerBlockEmsd {return false}
        if _storage._finalizationCount != rhs_storage._finalizationCount {return false}
        if _storage._lastFinalizedTime != rhs_storage._lastFinalizedTime {return false}
        if _storage._finalizationPeriodEma != rhs_storage._finalizationPeriodEma {return false}
        if _storage._finalizationPeriodEmsd != rhs_storage._finalizationPeriodEmsd {return false}
        if _storage._protocolVersion != rhs_storage._protocolVersion {return false}
        if _storage._genesisIndex != rhs_storage._genesisIndex {return false}
        if _storage._currentEraGenesisBlock != rhs_storage._currentEraGenesisBlock {return false}
        if _storage._currentEraGenesisTime != rhs_storage._currentEraGenesisTime {return false}
        if _storage._currentTimeoutDuration != rhs_storage._currentTimeoutDuration {return false}
        if _storage._currentRound != rhs_storage._currentRound {return false}
        if _storage._currentEpoch != rhs_storage._currentEpoch {return false}
        if _storage._triggerBlockTime != rhs_storage._triggerBlockTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ArrivedBlockInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArrivedBlockInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._hash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ArrivedBlockInfo, rhs: Concordium_V2_ArrivedBlockInfo) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs._height != rhs._height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_CryptographicParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CryptographicParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "genesis_string"),
    2: .standard(proto: "bulletproof_generators"),
    3: .standard(proto: "on_chain_commitment_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.genesisString) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.bulletproofGenerators) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.onChainCommitmentKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.genesisString.isEmpty {
      try visitor.visitSingularStringField(value: self.genesisString, fieldNumber: 1)
    }
    if !self.bulletproofGenerators.isEmpty {
      try visitor.visitSingularBytesField(value: self.bulletproofGenerators, fieldNumber: 2)
    }
    if !self.onChainCommitmentKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.onChainCommitmentKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_CryptographicParameters, rhs: Concordium_V2_CryptographicParameters) -> Bool {
    if lhs.genesisString != rhs.genesisString {return false}
    if lhs.bulletproofGenerators != rhs.bulletproofGenerators {return false}
    if lhs.onChainCommitmentKey != rhs.onChainCommitmentKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
    3: .standard(proto: "parent_block"),
    4: .standard(proto: "last_finalized_block"),
    5: .standard(proto: "genesis_index"),
    6: .standard(proto: "era_block_height"),
    7: .standard(proto: "receive_time"),
    8: .standard(proto: "arrive_time"),
    9: .standard(proto: "slot_number"),
    10: .standard(proto: "slot_time"),
    11: .same(proto: "baker"),
    12: .same(proto: "finalized"),
    13: .standard(proto: "transaction_count"),
    14: .standard(proto: "transactions_energy_cost"),
    15: .standard(proto: "transactions_size"),
    16: .standard(proto: "state_hash"),
    17: .standard(proto: "protocol_version"),
    18: .same(proto: "round"),
    19: .same(proto: "epoch"),
  ]

  fileprivate class _StorageClass {
    var _hash: Concordium_V2_BlockHash? = nil
    var _height: Concordium_V2_AbsoluteBlockHeight? = nil
    var _parentBlock: Concordium_V2_BlockHash? = nil
    var _lastFinalizedBlock: Concordium_V2_BlockHash? = nil
    var _genesisIndex: Concordium_V2_GenesisIndex? = nil
    var _eraBlockHeight: Concordium_V2_BlockHeight? = nil
    var _receiveTime: Concordium_V2_Timestamp? = nil
    var _arriveTime: Concordium_V2_Timestamp? = nil
    var _slotNumber: Concordium_V2_Slot? = nil
    var _slotTime: Concordium_V2_Timestamp? = nil
    var _baker: Concordium_V2_BakerId? = nil
    var _finalized: Bool = false
    var _transactionCount: UInt32 = 0
    var _transactionsEnergyCost: Concordium_V2_Energy? = nil
    var _transactionsSize: UInt32 = 0
    var _stateHash: Concordium_V2_StateHash? = nil
    var _protocolVersion: Concordium_V2_ProtocolVersion = .protocolVersion1
    var _round: Concordium_V2_Round? = nil
    var _epoch: Concordium_V2_Epoch? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _hash = source._hash
      _height = source._height
      _parentBlock = source._parentBlock
      _lastFinalizedBlock = source._lastFinalizedBlock
      _genesisIndex = source._genesisIndex
      _eraBlockHeight = source._eraBlockHeight
      _receiveTime = source._receiveTime
      _arriveTime = source._arriveTime
      _slotNumber = source._slotNumber
      _slotTime = source._slotTime
      _baker = source._baker
      _finalized = source._finalized
      _transactionCount = source._transactionCount
      _transactionsEnergyCost = source._transactionsEnergyCost
      _transactionsSize = source._transactionsSize
      _stateHash = source._stateHash
      _protocolVersion = source._protocolVersion
      _round = source._round
      _epoch = source._epoch
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._hash) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._height) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._parentBlock) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._lastFinalizedBlock) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._genesisIndex) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._eraBlockHeight) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._receiveTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._arriveTime) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._slotNumber) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._slotTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._baker) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._finalized) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._transactionCount) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._transactionsEnergyCost) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._transactionsSize) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._stateHash) }()
        case 17: try { try decoder.decodeSingularEnumField(value: &_storage._protocolVersion) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._round) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._epoch) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._hash {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._height {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._parentBlock {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._lastFinalizedBlock {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._genesisIndex {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._eraBlockHeight {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._receiveTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._arriveTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._slotNumber {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._slotTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._baker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._finalized != false {
        try visitor.visitSingularBoolField(value: _storage._finalized, fieldNumber: 12)
      }
      if _storage._transactionCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._transactionCount, fieldNumber: 13)
      }
      try { if let v = _storage._transactionsEnergyCost {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._transactionsSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._transactionsSize, fieldNumber: 15)
      }
      try { if let v = _storage._stateHash {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._protocolVersion != .protocolVersion1 {
        try visitor.visitSingularEnumField(value: _storage._protocolVersion, fieldNumber: 17)
      }
      try { if let v = _storage._round {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._epoch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockInfo, rhs: Concordium_V2_BlockInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._parentBlock != rhs_storage._parentBlock {return false}
        if _storage._lastFinalizedBlock != rhs_storage._lastFinalizedBlock {return false}
        if _storage._genesisIndex != rhs_storage._genesisIndex {return false}
        if _storage._eraBlockHeight != rhs_storage._eraBlockHeight {return false}
        if _storage._receiveTime != rhs_storage._receiveTime {return false}
        if _storage._arriveTime != rhs_storage._arriveTime {return false}
        if _storage._slotNumber != rhs_storage._slotNumber {return false}
        if _storage._slotTime != rhs_storage._slotTime {return false}
        if _storage._baker != rhs_storage._baker {return false}
        if _storage._finalized != rhs_storage._finalized {return false}
        if _storage._transactionCount != rhs_storage._transactionCount {return false}
        if _storage._transactionsEnergyCost != rhs_storage._transactionsEnergyCost {return false}
        if _storage._transactionsSize != rhs_storage._transactionsSize {return false}
        if _storage._stateHash != rhs_storage._stateHash {return false}
        if _storage._protocolVersion != rhs_storage._protocolVersion {return false}
        if _storage._round != rhs_storage._round {return false}
        if _storage._epoch != rhs_storage._epoch {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PoolInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_hash"),
    2: .same(proto: "baker"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blockHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._baker) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._baker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PoolInfoRequest, rhs: Concordium_V2_PoolInfoRequest) -> Bool {
    if lhs._blockHash != rhs._blockHash {return false}
    if lhs._baker != rhs._baker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PoolPendingChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolPendingChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reduce"),
    2: .same(proto: "remove"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_PoolPendingChange.Reduce?
        var hadOneofValue = false
        if let current = self.change {
          hadOneofValue = true
          if case .reduce(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.change = .reduce(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_PoolPendingChange.Remove?
        var hadOneofValue = false
        if let current = self.change {
          hadOneofValue = true
          if case .remove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.change = .remove(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.change {
    case .reduce?: try {
      guard case .reduce(let v)? = self.change else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .remove?: try {
      guard case .remove(let v)? = self.change else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PoolPendingChange, rhs: Concordium_V2_PoolPendingChange) -> Bool {
    if lhs.change != rhs.change {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PoolPendingChange.Reduce: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_PoolPendingChange.protoMessageName + ".Reduce"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reduced_equity_capital"),
    2: .standard(proto: "effective_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._reducedEquityCapital) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._effectiveTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._reducedEquityCapital {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._effectiveTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PoolPendingChange.Reduce, rhs: Concordium_V2_PoolPendingChange.Reduce) -> Bool {
    if lhs._reducedEquityCapital != rhs._reducedEquityCapital {return false}
    if lhs._effectiveTime != rhs._effectiveTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PoolPendingChange.Remove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_PoolPendingChange.protoMessageName + ".Remove"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "effective_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._effectiveTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._effectiveTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PoolPendingChange.Remove, rhs: Concordium_V2_PoolPendingChange.Remove) -> Bool {
    if lhs._effectiveTime != rhs._effectiveTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PoolCurrentPaydayInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolCurrentPaydayInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "blocks_baked"),
    2: .standard(proto: "finalization_live"),
    3: .standard(proto: "transaction_fees_earned"),
    4: .standard(proto: "effective_stake"),
    5: .standard(proto: "lottery_power"),
    6: .standard(proto: "baker_equity_capital"),
    7: .standard(proto: "delegated_capital"),
    8: .standard(proto: "commission_rates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.blocksBaked) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.finalizationLive) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._transactionFeesEarned) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._effectiveStake) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.lotteryPower) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._bakerEquityCapital) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._delegatedCapital) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._commissionRates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.blocksBaked != 0 {
      try visitor.visitSingularUInt64Field(value: self.blocksBaked, fieldNumber: 1)
    }
    if self.finalizationLive != false {
      try visitor.visitSingularBoolField(value: self.finalizationLive, fieldNumber: 2)
    }
    try { if let v = self._transactionFeesEarned {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._effectiveStake {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.lotteryPower.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lotteryPower, fieldNumber: 5)
    }
    try { if let v = self._bakerEquityCapital {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._delegatedCapital {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._commissionRates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PoolCurrentPaydayInfo, rhs: Concordium_V2_PoolCurrentPaydayInfo) -> Bool {
    if lhs.blocksBaked != rhs.blocksBaked {return false}
    if lhs.finalizationLive != rhs.finalizationLive {return false}
    if lhs._transactionFeesEarned != rhs._transactionFeesEarned {return false}
    if lhs._effectiveStake != rhs._effectiveStake {return false}
    if lhs.lotteryPower != rhs.lotteryPower {return false}
    if lhs._bakerEquityCapital != rhs._bakerEquityCapital {return false}
    if lhs._delegatedCapital != rhs._delegatedCapital {return false}
    if lhs._commissionRates != rhs._commissionRates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PoolInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "baker"),
    2: .same(proto: "address"),
    3: .standard(proto: "equity_capital"),
    4: .standard(proto: "delegated_capital"),
    5: .standard(proto: "delegated_capital_cap"),
    6: .standard(proto: "pool_info"),
    7: .standard(proto: "equity_pending_change"),
    8: .standard(proto: "current_payday_info"),
    9: .standard(proto: "all_pool_total_capital"),
  ]

  fileprivate class _StorageClass {
    var _baker: Concordium_V2_BakerId? = nil
    var _address: Concordium_V2_AccountAddress? = nil
    var _equityCapital: Concordium_V2_Amount? = nil
    var _delegatedCapital: Concordium_V2_Amount? = nil
    var _delegatedCapitalCap: Concordium_V2_Amount? = nil
    var _poolInfo: Concordium_V2_BakerPoolInfo? = nil
    var _equityPendingChange: Concordium_V2_PoolPendingChange? = nil
    var _currentPaydayInfo: Concordium_V2_PoolCurrentPaydayInfo? = nil
    var _allPoolTotalCapital: Concordium_V2_Amount? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _baker = source._baker
      _address = source._address
      _equityCapital = source._equityCapital
      _delegatedCapital = source._delegatedCapital
      _delegatedCapitalCap = source._delegatedCapitalCap
      _poolInfo = source._poolInfo
      _equityPendingChange = source._equityPendingChange
      _currentPaydayInfo = source._currentPaydayInfo
      _allPoolTotalCapital = source._allPoolTotalCapital
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._baker) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._address) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._equityCapital) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._delegatedCapital) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._delegatedCapitalCap) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._poolInfo) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._equityPendingChange) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._currentPaydayInfo) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._allPoolTotalCapital) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._baker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._address {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._equityCapital {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._delegatedCapital {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._delegatedCapitalCap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._poolInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._equityPendingChange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._currentPaydayInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._allPoolTotalCapital {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PoolInfoResponse, rhs: Concordium_V2_PoolInfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._baker != rhs_storage._baker {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._equityCapital != rhs_storage._equityCapital {return false}
        if _storage._delegatedCapital != rhs_storage._delegatedCapital {return false}
        if _storage._delegatedCapitalCap != rhs_storage._delegatedCapitalCap {return false}
        if _storage._poolInfo != rhs_storage._poolInfo {return false}
        if _storage._equityPendingChange != rhs_storage._equityPendingChange {return false}
        if _storage._currentPaydayInfo != rhs_storage._currentPaydayInfo {return false}
        if _storage._allPoolTotalCapital != rhs_storage._allPoolTotalCapital {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PassiveDelegationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PassiveDelegationInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegated_capital"),
    2: .standard(proto: "commission_rates"),
    3: .standard(proto: "current_payday_transaction_fees_earned"),
    4: .standard(proto: "current_payday_delegated_capital"),
    5: .standard(proto: "all_pool_total_capital"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._delegatedCapital) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._commissionRates) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._currentPaydayTransactionFeesEarned) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._currentPaydayDelegatedCapital) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._allPoolTotalCapital) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._delegatedCapital {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._commissionRates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._currentPaydayTransactionFeesEarned {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._currentPaydayDelegatedCapital {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._allPoolTotalCapital {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PassiveDelegationInfo, rhs: Concordium_V2_PassiveDelegationInfo) -> Bool {
    if lhs._delegatedCapital != rhs._delegatedCapital {return false}
    if lhs._commissionRates != rhs._commissionRates {return false}
    if lhs._currentPaydayTransactionFeesEarned != rhs._currentPaydayTransactionFeesEarned {return false}
    if lhs._currentPaydayDelegatedCapital != rhs._currentPaydayDelegatedCapital {return false}
    if lhs._allPoolTotalCapital != rhs._allPoolTotalCapital {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlocksAtHeightRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlocksAtHeightRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "absolute"),
    2: .same(proto: "relative"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_BlocksAtHeightRequest.Absolute?
        var hadOneofValue = false
        if let current = self.blocksAtHeight {
          hadOneofValue = true
          if case .absolute(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blocksAtHeight = .absolute(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_BlocksAtHeightRequest.Relative?
        var hadOneofValue = false
        if let current = self.blocksAtHeight {
          hadOneofValue = true
          if case .relative(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blocksAtHeight = .relative(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.blocksAtHeight {
    case .absolute?: try {
      guard case .absolute(let v)? = self.blocksAtHeight else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .relative?: try {
      guard case .relative(let v)? = self.blocksAtHeight else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlocksAtHeightRequest, rhs: Concordium_V2_BlocksAtHeightRequest) -> Bool {
    if lhs.blocksAtHeight != rhs.blocksAtHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlocksAtHeightRequest.Absolute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlocksAtHeightRequest.protoMessageName + ".Absolute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._height {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlocksAtHeightRequest.Absolute, rhs: Concordium_V2_BlocksAtHeightRequest.Absolute) -> Bool {
    if lhs._height != rhs._height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlocksAtHeightRequest.Relative: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlocksAtHeightRequest.protoMessageName + ".Relative"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "genesis_index"),
    2: .same(proto: "height"),
    3: .same(proto: "restrict"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._genesisIndex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._height) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.restrict) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._genesisIndex {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.restrict != false {
      try visitor.visitSingularBoolField(value: self.restrict, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlocksAtHeightRequest.Relative, rhs: Concordium_V2_BlocksAtHeightRequest.Relative) -> Bool {
    if lhs._genesisIndex != rhs._genesisIndex {return false}
    if lhs._height != rhs._height {return false}
    if lhs.restrict != rhs.restrict {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlocksAtHeightResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlocksAtHeightResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blocks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlocksAtHeightResponse, rhs: Concordium_V2_BlocksAtHeightResponse) -> Bool {
    if lhs.blocks != rhs.blocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_TokenomicsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenomicsInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v0"),
    2: .same(proto: "v1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_TokenomicsInfo.V0?
        var hadOneofValue = false
        if let current = self.tokenomics {
          hadOneofValue = true
          if case .v0(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tokenomics = .v0(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_TokenomicsInfo.V1?
        var hadOneofValue = false
        if let current = self.tokenomics {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.tokenomics = .v1(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.tokenomics {
    case .v0?: try {
      guard case .v0(let v)? = self.tokenomics else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .v1?: try {
      guard case .v1(let v)? = self.tokenomics else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_TokenomicsInfo, rhs: Concordium_V2_TokenomicsInfo) -> Bool {
    if lhs.tokenomics != rhs.tokenomics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_TokenomicsInfo.V0: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_TokenomicsInfo.protoMessageName + ".V0"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_amount"),
    2: .standard(proto: "total_encrypted_amount"),
    3: .standard(proto: "baking_reward_account"),
    4: .standard(proto: "finalization_reward_account"),
    5: .standard(proto: "gas_account"),
    6: .standard(proto: "protocol_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._totalAmount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._totalEncryptedAmount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bakingRewardAccount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._finalizationRewardAccount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._gasAccount) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.protocolVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._totalAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._totalEncryptedAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bakingRewardAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._finalizationRewardAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gasAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.protocolVersion != .protocolVersion1 {
      try visitor.visitSingularEnumField(value: self.protocolVersion, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_TokenomicsInfo.V0, rhs: Concordium_V2_TokenomicsInfo.V0) -> Bool {
    if lhs._totalAmount != rhs._totalAmount {return false}
    if lhs._totalEncryptedAmount != rhs._totalEncryptedAmount {return false}
    if lhs._bakingRewardAccount != rhs._bakingRewardAccount {return false}
    if lhs._finalizationRewardAccount != rhs._finalizationRewardAccount {return false}
    if lhs._gasAccount != rhs._gasAccount {return false}
    if lhs.protocolVersion != rhs.protocolVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_TokenomicsInfo.V1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_TokenomicsInfo.protoMessageName + ".V1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_amount"),
    2: .standard(proto: "total_encrypted_amount"),
    3: .standard(proto: "baking_reward_account"),
    4: .standard(proto: "finalization_reward_account"),
    5: .standard(proto: "gas_account"),
    6: .standard(proto: "foundation_transaction_rewards"),
    7: .standard(proto: "next_payday_time"),
    8: .standard(proto: "next_payday_mint_rate"),
    9: .standard(proto: "total_staked_capital"),
    10: .standard(proto: "protocol_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._totalAmount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._totalEncryptedAmount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bakingRewardAccount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._finalizationRewardAccount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._gasAccount) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._foundationTransactionRewards) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._nextPaydayTime) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._nextPaydayMintRate) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._totalStakedCapital) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.protocolVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._totalAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._totalEncryptedAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bakingRewardAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._finalizationRewardAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._gasAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._foundationTransactionRewards {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._nextPaydayTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._nextPaydayMintRate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._totalStakedCapital {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if self.protocolVersion != .protocolVersion1 {
      try visitor.visitSingularEnumField(value: self.protocolVersion, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_TokenomicsInfo.V1, rhs: Concordium_V2_TokenomicsInfo.V1) -> Bool {
    if lhs._totalAmount != rhs._totalAmount {return false}
    if lhs._totalEncryptedAmount != rhs._totalEncryptedAmount {return false}
    if lhs._bakingRewardAccount != rhs._bakingRewardAccount {return false}
    if lhs._finalizationRewardAccount != rhs._finalizationRewardAccount {return false}
    if lhs._gasAccount != rhs._gasAccount {return false}
    if lhs._foundationTransactionRewards != rhs._foundationTransactionRewards {return false}
    if lhs._nextPaydayTime != rhs._nextPaydayTime {return false}
    if lhs._nextPaydayMintRate != rhs._nextPaydayMintRate {return false}
    if lhs._totalStakedCapital != rhs._totalStakedCapital {return false}
    if lhs.protocolVersion != rhs.protocolVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InvokeInstanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvokeInstanceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_hash"),
    2: .same(proto: "invoker"),
    3: .same(proto: "instance"),
    4: .same(proto: "amount"),
    5: .same(proto: "entrypoint"),
    6: .same(proto: "parameter"),
    7: .same(proto: "energy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blockHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._invoker) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._entrypoint) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._parameter) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._energy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._invoker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._entrypoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._parameter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._energy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InvokeInstanceRequest, rhs: Concordium_V2_InvokeInstanceRequest) -> Bool {
    if lhs._blockHash != rhs._blockHash {return false}
    if lhs._invoker != rhs._invoker {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._entrypoint != rhs._entrypoint {return false}
    if lhs._parameter != rhs._parameter {return false}
    if lhs._energy != rhs._energy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InvokeInstanceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InvokeInstanceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_InvokeInstanceResponse.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_InvokeInstanceResponse.Failure?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .failure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .failure(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failure?: try {
      guard case .failure(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InvokeInstanceResponse, rhs: Concordium_V2_InvokeInstanceResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InvokeInstanceResponse.Failure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_InvokeInstanceResponse.protoMessageName + ".Failure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "return_value"),
    2: .standard(proto: "used_energy"),
    3: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._returnValue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._usedEnergy) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._returnValue {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._usedEnergy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._reason {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InvokeInstanceResponse.Failure, rhs: Concordium_V2_InvokeInstanceResponse.Failure) -> Bool {
    if lhs._returnValue != rhs._returnValue {return false}
    if lhs._usedEnergy != rhs._usedEnergy {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InvokeInstanceResponse.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_InvokeInstanceResponse.protoMessageName + ".Success"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "return_value"),
    2: .standard(proto: "used_energy"),
    3: .same(proto: "effects"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._returnValue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._usedEnergy) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.effects) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._returnValue {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._usedEnergy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.effects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.effects, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InvokeInstanceResponse.Success, rhs: Concordium_V2_InvokeInstanceResponse.Success) -> Bool {
    if lhs._returnValue != rhs._returnValue {return false}
    if lhs._usedEnergy != rhs._usedEnergy {return false}
    if lhs.effects != rhs.effects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_GetPoolDelegatorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPoolDelegatorsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_hash"),
    2: .same(proto: "baker"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blockHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._baker) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._baker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_GetPoolDelegatorsRequest, rhs: Concordium_V2_GetPoolDelegatorsRequest) -> Bool {
    if lhs._blockHash != rhs._blockHash {return false}
    if lhs._baker != rhs._baker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DelegatorInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelegatorInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "stake"),
    3: .standard(proto: "pending_change"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stake) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pendingChange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stake {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pendingChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DelegatorInfo, rhs: Concordium_V2_DelegatorInfo) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._stake != rhs._stake {return false}
    if lhs._pendingChange != rhs._pendingChange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DelegatorRewardPeriodInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelegatorRewardPeriodInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "stake"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stake) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stake {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DelegatorRewardPeriodInfo, rhs: Concordium_V2_DelegatorRewardPeriodInfo) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._stake != rhs._stake {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Branch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Branch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_hash"),
    2: .same(proto: "children"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blockHash) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Branch, rhs: Concordium_V2_Branch) -> Bool {
    if lhs._blockHash != rhs._blockHash {return false}
    if lhs.children != rhs.children {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_LeadershipElectionNonce: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeadershipElectionNonce"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_LeadershipElectionNonce, rhs: Concordium_V2_LeadershipElectionNonce) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ElectionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ElectionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "election_difficulty"),
    2: .standard(proto: "election_nonce"),
    3: .standard(proto: "baker_election_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._electionDifficulty) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._electionNonce) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.bakerElectionInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._electionDifficulty {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._electionNonce {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.bakerElectionInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bakerElectionInfo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ElectionInfo, rhs: Concordium_V2_ElectionInfo) -> Bool {
    if lhs._electionDifficulty != rhs._electionDifficulty {return false}
    if lhs._electionNonce != rhs._electionNonce {return false}
    if lhs.bakerElectionInfo != rhs.bakerElectionInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ElectionInfo.Baker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_ElectionInfo.protoMessageName + ".Baker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "baker"),
    2: .same(proto: "account"),
    3: .standard(proto: "lottery_power"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baker) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.lotteryPower) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.lotteryPower.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lotteryPower, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ElectionInfo.Baker, rhs: Concordium_V2_ElectionInfo.Baker) -> Bool {
    if lhs._baker != rhs._baker {return false}
    if lhs._account != rhs._account {return false}
    if lhs.lotteryPower != rhs.lotteryPower {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockSpecialEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockSpecialEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baking_rewards"),
    2: .same(proto: "mint"),
    3: .standard(proto: "finalization_rewards"),
    4: .standard(proto: "block_reward"),
    5: .standard(proto: "payday_foundation_reward"),
    6: .standard(proto: "payday_account_reward"),
    7: .standard(proto: "block_accrue_reward"),
    8: .standard(proto: "payday_pool_reward"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_BlockSpecialEvent.BakingRewards?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .bakingRewards(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .bakingRewards(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_BlockSpecialEvent.Mint?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .mint(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .mint(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_BlockSpecialEvent.FinalizationRewards?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .finalizationRewards(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .finalizationRewards(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_BlockSpecialEvent.BlockReward?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .blockReward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .blockReward(v)
        }
      }()
      case 5: try {
        var v: Concordium_V2_BlockSpecialEvent.PaydayFoundationReward?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .paydayFoundationReward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .paydayFoundationReward(v)
        }
      }()
      case 6: try {
        var v: Concordium_V2_BlockSpecialEvent.PaydayAccountReward?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .paydayAccountReward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .paydayAccountReward(v)
        }
      }()
      case 7: try {
        var v: Concordium_V2_BlockSpecialEvent.BlockAccrueReward?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .blockAccrueReward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .blockAccrueReward(v)
        }
      }()
      case 8: try {
        var v: Concordium_V2_BlockSpecialEvent.PaydayPoolReward?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .paydayPoolReward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .paydayPoolReward(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .bakingRewards?: try {
      guard case .bakingRewards(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .mint?: try {
      guard case .mint(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .finalizationRewards?: try {
      guard case .finalizationRewards(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .blockReward?: try {
      guard case .blockReward(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .paydayFoundationReward?: try {
      guard case .paydayFoundationReward(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .paydayAccountReward?: try {
      guard case .paydayAccountReward(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .blockAccrueReward?: try {
      guard case .blockAccrueReward(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .paydayPoolReward?: try {
      guard case .paydayPoolReward(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockSpecialEvent, rhs: Concordium_V2_BlockSpecialEvent) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockSpecialEvent.AccountAmounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlockSpecialEvent.protoMessageName + ".AccountAmounts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockSpecialEvent.AccountAmounts, rhs: Concordium_V2_BlockSpecialEvent.AccountAmounts) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockSpecialEvent.AccountAmounts.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlockSpecialEvent.AccountAmounts.protoMessageName + ".Entry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockSpecialEvent.AccountAmounts.Entry, rhs: Concordium_V2_BlockSpecialEvent.AccountAmounts.Entry) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockSpecialEvent.BakingRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlockSpecialEvent.protoMessageName + ".BakingRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_rewards"),
    2: .same(proto: "remainder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerRewards) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._remainder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerRewards {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._remainder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockSpecialEvent.BakingRewards, rhs: Concordium_V2_BlockSpecialEvent.BakingRewards) -> Bool {
    if lhs._bakerRewards != rhs._bakerRewards {return false}
    if lhs._remainder != rhs._remainder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockSpecialEvent.Mint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlockSpecialEvent.protoMessageName + ".Mint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mint_baking_reward"),
    2: .standard(proto: "mint_finalization_reward"),
    3: .standard(proto: "mint_platform_development_charge"),
    4: .standard(proto: "foundation_account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mintBakingReward) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mintFinalizationReward) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mintPlatformDevelopmentCharge) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._foundationAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mintBakingReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._mintFinalizationReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mintPlatformDevelopmentCharge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._foundationAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockSpecialEvent.Mint, rhs: Concordium_V2_BlockSpecialEvent.Mint) -> Bool {
    if lhs._mintBakingReward != rhs._mintBakingReward {return false}
    if lhs._mintFinalizationReward != rhs._mintFinalizationReward {return false}
    if lhs._mintPlatformDevelopmentCharge != rhs._mintPlatformDevelopmentCharge {return false}
    if lhs._foundationAccount != rhs._foundationAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockSpecialEvent.FinalizationRewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlockSpecialEvent.protoMessageName + ".FinalizationRewards"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "finalization_rewards"),
    2: .same(proto: "remainder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._finalizationRewards) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._remainder) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._finalizationRewards {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._remainder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockSpecialEvent.FinalizationRewards, rhs: Concordium_V2_BlockSpecialEvent.FinalizationRewards) -> Bool {
    if lhs._finalizationRewards != rhs._finalizationRewards {return false}
    if lhs._remainder != rhs._remainder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockSpecialEvent.BlockReward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlockSpecialEvent.protoMessageName + ".BlockReward"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_fees"),
    2: .standard(proto: "old_gas_account"),
    3: .standard(proto: "new_gas_account"),
    4: .standard(proto: "baker_reward"),
    5: .standard(proto: "foundation_charge"),
    6: .same(proto: "baker"),
    7: .standard(proto: "foundation_account"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transactionFees) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._oldGasAccount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newGasAccount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._bakerReward) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._foundationCharge) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._baker) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._foundationAccount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transactionFees {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldGasAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newGasAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bakerReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._foundationCharge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._baker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._foundationAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockSpecialEvent.BlockReward, rhs: Concordium_V2_BlockSpecialEvent.BlockReward) -> Bool {
    if lhs._transactionFees != rhs._transactionFees {return false}
    if lhs._oldGasAccount != rhs._oldGasAccount {return false}
    if lhs._newGasAccount != rhs._newGasAccount {return false}
    if lhs._bakerReward != rhs._bakerReward {return false}
    if lhs._foundationCharge != rhs._foundationCharge {return false}
    if lhs._baker != rhs._baker {return false}
    if lhs._foundationAccount != rhs._foundationAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockSpecialEvent.PaydayFoundationReward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlockSpecialEvent.protoMessageName + ".PaydayFoundationReward"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "foundation_account"),
    2: .standard(proto: "development_charge"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._foundationAccount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._developmentCharge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._foundationAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._developmentCharge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockSpecialEvent.PaydayFoundationReward, rhs: Concordium_V2_BlockSpecialEvent.PaydayFoundationReward) -> Bool {
    if lhs._foundationAccount != rhs._foundationAccount {return false}
    if lhs._developmentCharge != rhs._developmentCharge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockSpecialEvent.PaydayAccountReward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlockSpecialEvent.protoMessageName + ".PaydayAccountReward"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "transaction_fees"),
    3: .standard(proto: "baker_reward"),
    4: .standard(proto: "finalization_reward"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._transactionFees) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bakerReward) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._finalizationReward) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._transactionFees {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bakerReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._finalizationReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockSpecialEvent.PaydayAccountReward, rhs: Concordium_V2_BlockSpecialEvent.PaydayAccountReward) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._transactionFees != rhs._transactionFees {return false}
    if lhs._bakerReward != rhs._bakerReward {return false}
    if lhs._finalizationReward != rhs._finalizationReward {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockSpecialEvent.BlockAccrueReward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlockSpecialEvent.protoMessageName + ".BlockAccrueReward"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_fees"),
    2: .standard(proto: "old_gas_account"),
    3: .standard(proto: "new_gas_account"),
    4: .standard(proto: "baker_reward"),
    5: .standard(proto: "passive_reward"),
    6: .standard(proto: "foundation_charge"),
    7: .same(proto: "baker"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transactionFees) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._oldGasAccount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newGasAccount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._bakerReward) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._passiveReward) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._foundationCharge) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._baker) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transactionFees {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldGasAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newGasAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bakerReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._passiveReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._foundationCharge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._baker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockSpecialEvent.BlockAccrueReward, rhs: Concordium_V2_BlockSpecialEvent.BlockAccrueReward) -> Bool {
    if lhs._transactionFees != rhs._transactionFees {return false}
    if lhs._oldGasAccount != rhs._oldGasAccount {return false}
    if lhs._newGasAccount != rhs._newGasAccount {return false}
    if lhs._bakerReward != rhs._bakerReward {return false}
    if lhs._passiveReward != rhs._passiveReward {return false}
    if lhs._foundationCharge != rhs._foundationCharge {return false}
    if lhs._baker != rhs._baker {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockSpecialEvent.PaydayPoolReward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_BlockSpecialEvent.protoMessageName + ".PaydayPoolReward"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_owner"),
    2: .standard(proto: "transaction_fees"),
    3: .standard(proto: "baker_reward"),
    4: .standard(proto: "finalization_reward"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._poolOwner) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._transactionFees) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bakerReward) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._finalizationReward) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._poolOwner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._transactionFees {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bakerReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._finalizationReward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockSpecialEvent.PaydayPoolReward, rhs: Concordium_V2_BlockSpecialEvent.PaydayPoolReward) -> Bool {
    if lhs._poolOwner != rhs._poolOwner {return false}
    if lhs._transactionFees != rhs._transactionFees {return false}
    if lhs._bakerReward != rhs._bakerReward {return false}
    if lhs._finalizationReward != rhs._finalizationReward {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PendingUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "effective_time"),
    2: .standard(proto: "root_keys"),
    3: .standard(proto: "level1_keys"),
    4: .standard(proto: "level2_keys_cpv_0"),
    5: .standard(proto: "level2_keys_cpv_1"),
    6: .same(proto: "protocol"),
    7: .standard(proto: "election_difficulty"),
    8: .standard(proto: "euro_per_energy"),
    9: .standard(proto: "micro_ccd_per_euro"),
    10: .standard(proto: "foundation_account"),
    11: .standard(proto: "mint_distribution_cpv_0"),
    12: .standard(proto: "mint_distribution_cpv_1"),
    13: .standard(proto: "transaction_fee_distribution"),
    14: .standard(proto: "gas_rewards"),
    15: .standard(proto: "pool_parameters_cpv_0"),
    16: .standard(proto: "pool_parameters_cpv_1"),
    17: .standard(proto: "add_anonymity_revoker"),
    18: .standard(proto: "add_identity_provider"),
    19: .standard(proto: "cooldown_parameters"),
    20: .standard(proto: "time_parameters"),
    21: .standard(proto: "gas_rewards_cpv_2"),
    22: .standard(proto: "timeout_parameters"),
    23: .standard(proto: "min_block_time"),
    24: .standard(proto: "block_energy_limit"),
    25: .standard(proto: "finalization_committee_parameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._effectiveTime) }()
      case 2: try {
        var v: Concordium_V2_HigherLevelKeys?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .rootKeys(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .rootKeys(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_HigherLevelKeys?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .level1Keys(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .level1Keys(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_AuthorizationsV0?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .level2KeysCpv0(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .level2KeysCpv0(v)
        }
      }()
      case 5: try {
        var v: Concordium_V2_AuthorizationsV1?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .level2KeysCpv1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .level2KeysCpv1(v)
        }
      }()
      case 6: try {
        var v: Concordium_V2_ProtocolUpdate?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .protocol(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .protocol(v)
        }
      }()
      case 7: try {
        var v: Concordium_V2_ElectionDifficulty?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .electionDifficulty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .electionDifficulty(v)
        }
      }()
      case 8: try {
        var v: Concordium_V2_ExchangeRate?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .euroPerEnergy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .euroPerEnergy(v)
        }
      }()
      case 9: try {
        var v: Concordium_V2_ExchangeRate?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .microCcdPerEuro(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .microCcdPerEuro(v)
        }
      }()
      case 10: try {
        var v: Concordium_V2_AccountAddress?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .foundationAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .foundationAccount(v)
        }
      }()
      case 11: try {
        var v: Concordium_V2_MintDistributionCpv0?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .mintDistributionCpv0(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .mintDistributionCpv0(v)
        }
      }()
      case 12: try {
        var v: Concordium_V2_MintDistributionCpv1?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .mintDistributionCpv1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .mintDistributionCpv1(v)
        }
      }()
      case 13: try {
        var v: Concordium_V2_TransactionFeeDistribution?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .transactionFeeDistribution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .transactionFeeDistribution(v)
        }
      }()
      case 14: try {
        var v: Concordium_V2_GasRewards?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .gasRewards(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .gasRewards(v)
        }
      }()
      case 15: try {
        var v: Concordium_V2_BakerStakeThreshold?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .poolParametersCpv0(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .poolParametersCpv0(v)
        }
      }()
      case 16: try {
        var v: Concordium_V2_PoolParametersCpv1?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .poolParametersCpv1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .poolParametersCpv1(v)
        }
      }()
      case 17: try {
        var v: Concordium_V2_ArInfo?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .addAnonymityRevoker(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .addAnonymityRevoker(v)
        }
      }()
      case 18: try {
        var v: Concordium_V2_IpInfo?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .addIdentityProvider(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .addIdentityProvider(v)
        }
      }()
      case 19: try {
        var v: Concordium_V2_CooldownParametersCpv1?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .cooldownParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .cooldownParameters(v)
        }
      }()
      case 20: try {
        var v: Concordium_V2_TimeParametersCpv1?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .timeParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .timeParameters(v)
        }
      }()
      case 21: try {
        var v: Concordium_V2_GasRewardsCpv2?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .gasRewardsCpv2(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .gasRewardsCpv2(v)
        }
      }()
      case 22: try {
        var v: Concordium_V2_TimeoutParameters?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .timeoutParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .timeoutParameters(v)
        }
      }()
      case 23: try {
        var v: Concordium_V2_Duration?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .minBlockTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .minBlockTime(v)
        }
      }()
      case 24: try {
        var v: Concordium_V2_Energy?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .blockEnergyLimit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .blockEnergyLimit(v)
        }
      }()
      case 25: try {
        var v: Concordium_V2_FinalizationCommitteeParameters?
        var hadOneofValue = false
        if let current = self.effect {
          hadOneofValue = true
          if case .finalizationCommitteeParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.effect = .finalizationCommitteeParameters(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._effectiveTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.effect {
    case .rootKeys?: try {
      guard case .rootKeys(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .level1Keys?: try {
      guard case .level1Keys(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .level2KeysCpv0?: try {
      guard case .level2KeysCpv0(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .level2KeysCpv1?: try {
      guard case .level2KeysCpv1(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .protocol?: try {
      guard case .protocol(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .electionDifficulty?: try {
      guard case .electionDifficulty(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .euroPerEnergy?: try {
      guard case .euroPerEnergy(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .microCcdPerEuro?: try {
      guard case .microCcdPerEuro(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .foundationAccount?: try {
      guard case .foundationAccount(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .mintDistributionCpv0?: try {
      guard case .mintDistributionCpv0(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .mintDistributionCpv1?: try {
      guard case .mintDistributionCpv1(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .transactionFeeDistribution?: try {
      guard case .transactionFeeDistribution(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .gasRewards?: try {
      guard case .gasRewards(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .poolParametersCpv0?: try {
      guard case .poolParametersCpv0(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .poolParametersCpv1?: try {
      guard case .poolParametersCpv1(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .addAnonymityRevoker?: try {
      guard case .addAnonymityRevoker(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .addIdentityProvider?: try {
      guard case .addIdentityProvider(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .cooldownParameters?: try {
      guard case .cooldownParameters(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .timeParameters?: try {
      guard case .timeParameters(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .gasRewardsCpv2?: try {
      guard case .gasRewardsCpv2(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .timeoutParameters?: try {
      guard case .timeoutParameters(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .minBlockTime?: try {
      guard case .minBlockTime(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .blockEnergyLimit?: try {
      guard case .blockEnergyLimit(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .finalizationCommitteeParameters?: try {
      guard case .finalizationCommitteeParameters(let v)? = self.effect else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PendingUpdate, rhs: Concordium_V2_PendingUpdate) -> Bool {
    if lhs._effectiveTime != rhs._effectiveTime {return false}
    if lhs.effect != rhs.effect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_NextUpdateSequenceNumbers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NextUpdateSequenceNumbers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_keys"),
    2: .standard(proto: "level1_keys"),
    3: .standard(proto: "level2_keys"),
    4: .same(proto: "protocol"),
    5: .standard(proto: "election_difficulty"),
    6: .standard(proto: "euro_per_energy"),
    7: .standard(proto: "micro_ccd_per_euro"),
    8: .standard(proto: "foundation_account"),
    9: .standard(proto: "mint_distribution"),
    10: .standard(proto: "transaction_fee_distribution"),
    11: .standard(proto: "gas_rewards"),
    12: .standard(proto: "pool_parameters"),
    13: .standard(proto: "add_anonymity_revoker"),
    14: .standard(proto: "add_identity_provider"),
    15: .standard(proto: "cooldown_parameters"),
    16: .standard(proto: "time_parameters"),
    17: .standard(proto: "timeout_parameters"),
    18: .standard(proto: "min_block_time"),
    19: .standard(proto: "block_energy_limit"),
    20: .standard(proto: "finalization_committee_parameters"),
  ]

  fileprivate class _StorageClass {
    var _rootKeys: Concordium_V2_SequenceNumber? = nil
    var _level1Keys: Concordium_V2_SequenceNumber? = nil
    var _level2Keys: Concordium_V2_SequenceNumber? = nil
    var _protocol: Concordium_V2_SequenceNumber? = nil
    var _electionDifficulty: Concordium_V2_SequenceNumber? = nil
    var _euroPerEnergy: Concordium_V2_SequenceNumber? = nil
    var _microCcdPerEuro: Concordium_V2_SequenceNumber? = nil
    var _foundationAccount: Concordium_V2_SequenceNumber? = nil
    var _mintDistribution: Concordium_V2_SequenceNumber? = nil
    var _transactionFeeDistribution: Concordium_V2_SequenceNumber? = nil
    var _gasRewards: Concordium_V2_SequenceNumber? = nil
    var _poolParameters: Concordium_V2_SequenceNumber? = nil
    var _addAnonymityRevoker: Concordium_V2_SequenceNumber? = nil
    var _addIdentityProvider: Concordium_V2_SequenceNumber? = nil
    var _cooldownParameters: Concordium_V2_SequenceNumber? = nil
    var _timeParameters: Concordium_V2_SequenceNumber? = nil
    var _timeoutParameters: Concordium_V2_SequenceNumber? = nil
    var _minBlockTime: Concordium_V2_SequenceNumber? = nil
    var _blockEnergyLimit: Concordium_V2_SequenceNumber? = nil
    var _finalizationCommitteeParameters: Concordium_V2_SequenceNumber? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _rootKeys = source._rootKeys
      _level1Keys = source._level1Keys
      _level2Keys = source._level2Keys
      _protocol = source._protocol
      _electionDifficulty = source._electionDifficulty
      _euroPerEnergy = source._euroPerEnergy
      _microCcdPerEuro = source._microCcdPerEuro
      _foundationAccount = source._foundationAccount
      _mintDistribution = source._mintDistribution
      _transactionFeeDistribution = source._transactionFeeDistribution
      _gasRewards = source._gasRewards
      _poolParameters = source._poolParameters
      _addAnonymityRevoker = source._addAnonymityRevoker
      _addIdentityProvider = source._addIdentityProvider
      _cooldownParameters = source._cooldownParameters
      _timeParameters = source._timeParameters
      _timeoutParameters = source._timeoutParameters
      _minBlockTime = source._minBlockTime
      _blockEnergyLimit = source._blockEnergyLimit
      _finalizationCommitteeParameters = source._finalizationCommitteeParameters
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._rootKeys) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._level1Keys) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._level2Keys) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._protocol) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._electionDifficulty) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._euroPerEnergy) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._microCcdPerEuro) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._foundationAccount) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._mintDistribution) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._transactionFeeDistribution) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._gasRewards) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._poolParameters) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._addAnonymityRevoker) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._addIdentityProvider) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._cooldownParameters) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._timeParameters) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._timeoutParameters) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._minBlockTime) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._blockEnergyLimit) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._finalizationCommitteeParameters) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._rootKeys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._level1Keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._level2Keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._protocol {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._electionDifficulty {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._euroPerEnergy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._microCcdPerEuro {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._foundationAccount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._mintDistribution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._transactionFeeDistribution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._gasRewards {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._poolParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._addAnonymityRevoker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._addIdentityProvider {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._cooldownParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._timeParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._timeoutParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._minBlockTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._blockEnergyLimit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._finalizationCommitteeParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_NextUpdateSequenceNumbers, rhs: Concordium_V2_NextUpdateSequenceNumbers) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rootKeys != rhs_storage._rootKeys {return false}
        if _storage._level1Keys != rhs_storage._level1Keys {return false}
        if _storage._level2Keys != rhs_storage._level2Keys {return false}
        if _storage._protocol != rhs_storage._protocol {return false}
        if _storage._electionDifficulty != rhs_storage._electionDifficulty {return false}
        if _storage._euroPerEnergy != rhs_storage._euroPerEnergy {return false}
        if _storage._microCcdPerEuro != rhs_storage._microCcdPerEuro {return false}
        if _storage._foundationAccount != rhs_storage._foundationAccount {return false}
        if _storage._mintDistribution != rhs_storage._mintDistribution {return false}
        if _storage._transactionFeeDistribution != rhs_storage._transactionFeeDistribution {return false}
        if _storage._gasRewards != rhs_storage._gasRewards {return false}
        if _storage._poolParameters != rhs_storage._poolParameters {return false}
        if _storage._addAnonymityRevoker != rhs_storage._addAnonymityRevoker {return false}
        if _storage._addIdentityProvider != rhs_storage._addIdentityProvider {return false}
        if _storage._cooldownParameters != rhs_storage._cooldownParameters {return false}
        if _storage._timeParameters != rhs_storage._timeParameters {return false}
        if _storage._timeoutParameters != rhs_storage._timeoutParameters {return false}
        if _storage._minBlockTime != rhs_storage._minBlockTime {return false}
        if _storage._blockEnergyLimit != rhs_storage._blockEnergyLimit {return false}
        if _storage._finalizationCommitteeParameters != rhs_storage._finalizationCommitteeParameters {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_IpAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IpAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_IpAddress, rhs: Concordium_V2_IpAddress) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Port: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Port"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Port, rhs: Concordium_V2_Port) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_IpSocketAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IpSocketAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    2: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ip) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ip {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._port {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_IpSocketAddress, rhs: Concordium_V2_IpSocketAddress) -> Bool {
    if lhs._ip != rhs._ip {return false}
    if lhs._port != rhs._port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PeerId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PeerId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PeerId, rhs: Concordium_V2_PeerId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BannedPeer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BannedPeer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ip_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ipAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ipAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BannedPeer, rhs: Concordium_V2_BannedPeer) -> Bool {
    if lhs._ipAddress != rhs._ipAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BannedPeers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BannedPeers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.peers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.peers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BannedPeers, rhs: Concordium_V2_BannedPeers) -> Bool {
    if lhs.peers != rhs.peers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PeerToBan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PeerToBan"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ip_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ipAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ipAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PeerToBan, rhs: Concordium_V2_PeerToBan) -> Bool {
    if lhs._ipAddress != rhs._ipAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DumpRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DumpRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "file"),
    2: .same(proto: "raw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.file) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.raw) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.file.isEmpty {
      try visitor.visitSingularStringField(value: self.file, fieldNumber: 1)
    }
    if self.raw != false {
      try visitor.visitSingularBoolField(value: self.raw, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DumpRequest, rhs: Concordium_V2_DumpRequest) -> Bool {
    if lhs.file != rhs.file {return false}
    if lhs.raw != rhs.raw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PeersInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PeersInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "peers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.peers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.peers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.peers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PeersInfo, rhs: Concordium_V2_PeersInfo) -> Bool {
    if lhs.peers != rhs.peers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PeersInfo.Peer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_PeersInfo.protoMessageName + ".Peer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_id"),
    2: .standard(proto: "socket_address"),
    3: .standard(proto: "network_stats"),
    4: .same(proto: "bootstrapper"),
    5: .standard(proto: "node_catchup_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._peerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._socketAddress) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._networkStats) }()
      case 4: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.consensusInfo {
          hadOneofValue = true
          if case .bootstrapper(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consensusInfo = .bootstrapper(v)
        }
      }()
      case 5: try {
        var v: Concordium_V2_PeersInfo.Peer.CatchupStatus?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.consensusInfo != nil {try decoder.handleConflictingOneOf()}
          self.consensusInfo = .nodeCatchupStatus(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._peerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._socketAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._networkStats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    switch self.consensusInfo {
    case .bootstrapper?: try {
      guard case .bootstrapper(let v)? = self.consensusInfo else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .nodeCatchupStatus?: try {
      guard case .nodeCatchupStatus(let v)? = self.consensusInfo else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PeersInfo.Peer, rhs: Concordium_V2_PeersInfo.Peer) -> Bool {
    if lhs._peerID != rhs._peerID {return false}
    if lhs._socketAddress != rhs._socketAddress {return false}
    if lhs._networkStats != rhs._networkStats {return false}
    if lhs.consensusInfo != rhs.consensusInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PeersInfo.Peer.CatchupStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPTODATE"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "CATCHINGUP"),
  ]
}

extension Concordium_V2_PeersInfo.Peer.NetworkStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_PeersInfo.Peer.protoMessageName + ".NetworkStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "packets_sent"),
    3: .standard(proto: "packets_received"),
    4: .same(proto: "latency"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.packetsSent) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.packetsReceived) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.latency) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packetsSent != 0 {
      try visitor.visitSingularUInt64Field(value: self.packetsSent, fieldNumber: 2)
    }
    if self.packetsReceived != 0 {
      try visitor.visitSingularUInt64Field(value: self.packetsReceived, fieldNumber: 3)
    }
    if self.latency != 0 {
      try visitor.visitSingularUInt64Field(value: self.latency, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PeersInfo.Peer.NetworkStats, rhs: Concordium_V2_PeersInfo.Peer.NetworkStats) -> Bool {
    if lhs.packetsSent != rhs.packetsSent {return false}
    if lhs.packetsReceived != rhs.packetsReceived {return false}
    if lhs.latency != rhs.latency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodeInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_version"),
    3: .standard(proto: "local_time"),
    4: .standard(proto: "peer_uptime"),
    5: .standard(proto: "network_info"),
    6: .same(proto: "bootstrapper"),
    7: .same(proto: "node"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.peerVersion) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._localTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._peerUptime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._networkInfo) }()
      case 6: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .bootstrapper(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .bootstrapper(v)
        }
      }()
      case 7: try {
        var v: Concordium_V2_NodeInfo.Node?
        var hadOneofValue = false
        if let current = self.details {
          hadOneofValue = true
          if case .node(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.details = .node(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.peerVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.peerVersion, fieldNumber: 1)
    }
    try { if let v = self._localTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._peerUptime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._networkInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    switch self.details {
    case .bootstrapper?: try {
      guard case .bootstrapper(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .node?: try {
      guard case .node(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_NodeInfo, rhs: Concordium_V2_NodeInfo) -> Bool {
    if lhs.peerVersion != rhs.peerVersion {return false}
    if lhs._localTime != rhs._localTime {return false}
    if lhs._peerUptime != rhs._peerUptime {return false}
    if lhs._networkInfo != rhs._networkInfo {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_NodeInfo.NetworkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_NodeInfo.protoMessageName + ".NetworkInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .standard(proto: "peer_total_sent"),
    3: .standard(proto: "peer_total_received"),
    4: .standard(proto: "avg_bps_in"),
    5: .standard(proto: "avg_bps_out"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.peerTotalSent) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.peerTotalReceived) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.avgBpsIn) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.avgBpsOut) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.peerTotalSent != 0 {
      try visitor.visitSingularUInt64Field(value: self.peerTotalSent, fieldNumber: 2)
    }
    if self.peerTotalReceived != 0 {
      try visitor.visitSingularUInt64Field(value: self.peerTotalReceived, fieldNumber: 3)
    }
    if self.avgBpsIn != 0 {
      try visitor.visitSingularUInt64Field(value: self.avgBpsIn, fieldNumber: 4)
    }
    if self.avgBpsOut != 0 {
      try visitor.visitSingularUInt64Field(value: self.avgBpsOut, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_NodeInfo.NetworkInfo, rhs: Concordium_V2_NodeInfo.NetworkInfo) -> Bool {
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs.peerTotalSent != rhs.peerTotalSent {return false}
    if lhs.peerTotalReceived != rhs.peerTotalReceived {return false}
    if lhs.avgBpsIn != rhs.avgBpsIn {return false}
    if lhs.avgBpsOut != rhs.avgBpsOut {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_NodeInfo.BakerConsensusInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_NodeInfo.protoMessageName + ".BakerConsensusInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baker_id"),
    2: .standard(proto: "passive_committee_info"),
    3: .standard(proto: "active_baker_committee_info"),
    4: .standard(proto: "active_finalizer_committee_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bakerID) }()
      case 2: try {
        var v: Concordium_V2_NodeInfo.BakerConsensusInfo.PassiveCommitteeInfo?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.status != nil {try decoder.handleConflictingOneOf()}
          self.status = .passiveCommitteeInfo(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_NodeInfo.BakerConsensusInfo.ActiveBakerCommitteeInfo?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .activeBakerCommitteeInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .activeBakerCommitteeInfo(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_NodeInfo.BakerConsensusInfo.ActiveFinalizerCommitteeInfo?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .activeFinalizerCommitteeInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .activeFinalizerCommitteeInfo(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bakerID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.status {
    case .passiveCommitteeInfo?: try {
      guard case .passiveCommitteeInfo(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .activeBakerCommitteeInfo?: try {
      guard case .activeBakerCommitteeInfo(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .activeFinalizerCommitteeInfo?: try {
      guard case .activeFinalizerCommitteeInfo(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_NodeInfo.BakerConsensusInfo, rhs: Concordium_V2_NodeInfo.BakerConsensusInfo) -> Bool {
    if lhs._bakerID != rhs._bakerID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_NodeInfo.BakerConsensusInfo.PassiveCommitteeInfo: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_IN_COMMITTEE"),
    1: .same(proto: "ADDED_BUT_NOT_ACTIVE_IN_COMMITTEE"),
    2: .same(proto: "ADDED_BUT_WRONG_KEYS"),
  ]
}

extension Concordium_V2_NodeInfo.BakerConsensusInfo.ActiveBakerCommitteeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_NodeInfo.BakerConsensusInfo.protoMessageName + ".ActiveBakerCommitteeInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_NodeInfo.BakerConsensusInfo.ActiveBakerCommitteeInfo, rhs: Concordium_V2_NodeInfo.BakerConsensusInfo.ActiveBakerCommitteeInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_NodeInfo.BakerConsensusInfo.ActiveFinalizerCommitteeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_NodeInfo.BakerConsensusInfo.protoMessageName + ".ActiveFinalizerCommitteeInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_NodeInfo.BakerConsensusInfo.ActiveFinalizerCommitteeInfo, rhs: Concordium_V2_NodeInfo.BakerConsensusInfo.ActiveFinalizerCommitteeInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_NodeInfo.Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_NodeInfo.protoMessageName + ".Node"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "not_running"),
    2: .same(proto: "passive"),
    3: .same(proto: "active"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.consensusStatus {
          hadOneofValue = true
          if case .notRunning(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consensusStatus = .notRunning(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.consensusStatus {
          hadOneofValue = true
          if case .passive(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consensusStatus = .passive(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_NodeInfo.BakerConsensusInfo?
        var hadOneofValue = false
        if let current = self.consensusStatus {
          hadOneofValue = true
          if case .active(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consensusStatus = .active(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.consensusStatus {
    case .notRunning?: try {
      guard case .notRunning(let v)? = self.consensusStatus else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .passive?: try {
      guard case .passive(let v)? = self.consensusStatus else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .active?: try {
      guard case .active(let v)? = self.consensusStatus else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_NodeInfo.Node, rhs: Concordium_V2_NodeInfo.Node) -> Bool {
    if lhs.consensusStatus != rhs.consensusStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_SendBlockItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendBlockItemRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_transaction"),
    2: .standard(proto: "credential_deployment"),
    3: .standard(proto: "update_instruction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_AccountTransaction?
        var hadOneofValue = false
        if let current = self.blockItem {
          hadOneofValue = true
          if case .accountTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blockItem = .accountTransaction(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_CredentialDeployment?
        var hadOneofValue = false
        if let current = self.blockItem {
          hadOneofValue = true
          if case .credentialDeployment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blockItem = .credentialDeployment(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_UpdateInstruction?
        var hadOneofValue = false
        if let current = self.blockItem {
          hadOneofValue = true
          if case .updateInstruction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blockItem = .updateInstruction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.blockItem {
    case .accountTransaction?: try {
      guard case .accountTransaction(let v)? = self.blockItem else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .credentialDeployment?: try {
      guard case .credentialDeployment(let v)? = self.blockItem else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .updateInstruction?: try {
      guard case .updateInstruction(let v)? = self.blockItem else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_SendBlockItemRequest, rhs: Concordium_V2_SendBlockItemRequest) -> Bool {
    if lhs.blockItem != rhs.blockItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_CredentialDeployment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CredentialDeployment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_expiry"),
    2: .standard(proto: "raw_payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._messageExpiry) }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .rawPayload(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messageExpiry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if case .rawPayload(let v)? = self.payload {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_CredentialDeployment, rhs: Concordium_V2_CredentialDeployment) -> Bool {
    if lhs._messageExpiry != rhs._messageExpiry {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_Signature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Signature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_Signature, rhs: Concordium_V2_Signature) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_SignatureMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignatureMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signatures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Concordium_V2_Signature>.self, value: &self.signatures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signatures.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Concordium_V2_Signature>.self, value: self.signatures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_SignatureMap, rhs: Concordium_V2_SignatureMap) -> Bool {
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountSignatureMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountSignatureMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signatures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Concordium_V2_Signature>.self, value: &self.signatures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signatures.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Concordium_V2_Signature>.self, value: self.signatures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountSignatureMap, rhs: Concordium_V2_AccountSignatureMap) -> Bool {
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountTransactionSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signatures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Concordium_V2_AccountSignatureMap>.self, value: &self.signatures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signatures.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Concordium_V2_AccountSignatureMap>.self, value: self.signatures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionSignature, rhs: Concordium_V2_AccountTransactionSignature) -> Bool {
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountTransactionHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "sequence_number"),
    3: .standard(proto: "energy_amount"),
    5: .same(proto: "expiry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sender) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sequenceNumber) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._energyAmount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expiry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sequenceNumber {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._energyAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._expiry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionHeader, rhs: Concordium_V2_AccountTransactionHeader) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs._sequenceNumber != rhs._sequenceNumber {return false}
    if lhs._energyAmount != rhs._energyAmount {return false}
    if lhs._expiry != rhs._expiry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_InitContractPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitContractPayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .standard(proto: "module_ref"),
    3: .standard(proto: "init_name"),
    4: .same(proto: "parameter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._moduleRef) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._initName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._parameter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._moduleRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._initName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._parameter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_InitContractPayload, rhs: Concordium_V2_InitContractPayload) -> Bool {
    if lhs._amount != rhs._amount {return false}
    if lhs._moduleRef != rhs._moduleRef {return false}
    if lhs._initName != rhs._initName {return false}
    if lhs._parameter != rhs._parameter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_UpdateContractPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateContractPayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "address"),
    3: .standard(proto: "receive_name"),
    4: .same(proto: "parameter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._receiveName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._parameter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._receiveName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._parameter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_UpdateContractPayload, rhs: Concordium_V2_UpdateContractPayload) -> Bool {
    if lhs._amount != rhs._amount {return false}
    if lhs._address != rhs._address {return false}
    if lhs._receiveName != rhs._receiveName {return false}
    if lhs._parameter != rhs._parameter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_TransferPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransferPayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "receiver"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._receiver) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._receiver {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_TransferPayload, rhs: Concordium_V2_TransferPayload) -> Bool {
    if lhs._amount != rhs._amount {return false}
    if lhs._receiver != rhs._receiver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_TransferWithMemoPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransferWithMemoPayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "receiver"),
    3: .same(proto: "memo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._receiver) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._memo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._receiver {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._memo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_TransferWithMemoPayload, rhs: Concordium_V2_TransferWithMemoPayload) -> Bool {
    if lhs._amount != rhs._amount {return false}
    if lhs._receiver != rhs._receiver {return false}
    if lhs._memo != rhs._memo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountTransactionPayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_payload"),
    2: .standard(proto: "deploy_module"),
    3: .standard(proto: "init_contract"),
    4: .standard(proto: "update_contract"),
    5: .same(proto: "transfer"),
    6: .standard(proto: "transfer_with_memo"),
    7: .standard(proto: "register_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .rawPayload(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_VersionedModuleSource?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .deployModule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .deployModule(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_InitContractPayload?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .initContract(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .initContract(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_UpdateContractPayload?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .updateContract(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .updateContract(v)
        }
      }()
      case 5: try {
        var v: Concordium_V2_TransferPayload?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .transfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .transfer(v)
        }
      }()
      case 6: try {
        var v: Concordium_V2_TransferWithMemoPayload?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .transferWithMemo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .transferWithMemo(v)
        }
      }()
      case 7: try {
        var v: Concordium_V2_RegisteredData?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .registerData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .registerData(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .rawPayload?: try {
      guard case .rawPayload(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .deployModule?: try {
      guard case .deployModule(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .initContract?: try {
      guard case .initContract(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .updateContract?: try {
      guard case .updateContract(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .transfer?: try {
      guard case .transfer(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .transferWithMemo?: try {
      guard case .transferWithMemo(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .registerData?: try {
      guard case .registerData(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionPayload, rhs: Concordium_V2_AccountTransactionPayload) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_PreAccountTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreAccountTransaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_PreAccountTransaction, rhs: Concordium_V2_PreAccountTransaction) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountTransaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .same(proto: "header"),
    3: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransaction, rhs: Concordium_V2_AccountTransaction) -> Bool {
    if lhs._signature != rhs._signature {return false}
    if lhs._header != rhs._header {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_UpdateInstructionHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateInstructionHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequence_number"),
    2: .standard(proto: "effective_time"),
    3: .same(proto: "timeout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sequenceNumber) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._effectiveTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sequenceNumber {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._effectiveTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_UpdateInstructionHeader, rhs: Concordium_V2_UpdateInstructionHeader) -> Bool {
    if lhs._sequenceNumber != rhs._sequenceNumber {return false}
    if lhs._effectiveTime != rhs._effectiveTime {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_UpdateInstructionPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateInstructionPayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "raw_payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .rawPayload(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .rawPayload(let v)? = self.payload {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_UpdateInstructionPayload, rhs: Concordium_V2_UpdateInstructionPayload) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_UpdateInstruction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateInstruction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signatures"),
    2: .same(proto: "header"),
    3: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._signatures) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signatures {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_UpdateInstruction, rhs: Concordium_V2_UpdateInstruction) -> Bool {
    if lhs._signatures != rhs._signatures {return false}
    if lhs._header != rhs._header {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_AccountTransactionSignHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountTransactionSignHash"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_AccountTransactionSignHash, rhs: Concordium_V2_AccountTransactionSignHash) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_CredentialsPerBlockLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CredentialsPerBlockLimit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_CredentialsPerBlockLimit, rhs: Concordium_V2_CredentialsPerBlockLimit) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ChainParametersV0: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainParametersV0"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "election_difficulty"),
    2: .standard(proto: "euro_per_energy"),
    3: .standard(proto: "micro_ccd_per_euro"),
    4: .standard(proto: "baker_cooldown_epochs"),
    5: .standard(proto: "account_creation_limit"),
    6: .standard(proto: "mint_distribution"),
    7: .standard(proto: "transaction_fee_distribution"),
    8: .standard(proto: "gas_rewards"),
    9: .standard(proto: "foundation_account"),
    10: .standard(proto: "minimum_threshold_for_baking"),
    11: .standard(proto: "root_keys"),
    12: .standard(proto: "level1_keys"),
    13: .standard(proto: "level2_keys"),
  ]

  fileprivate class _StorageClass {
    var _electionDifficulty: Concordium_V2_ElectionDifficulty? = nil
    var _euroPerEnergy: Concordium_V2_ExchangeRate? = nil
    var _microCcdPerEuro: Concordium_V2_ExchangeRate? = nil
    var _bakerCooldownEpochs: Concordium_V2_Epoch? = nil
    var _accountCreationLimit: Concordium_V2_CredentialsPerBlockLimit? = nil
    var _mintDistribution: Concordium_V2_MintDistributionCpv0? = nil
    var _transactionFeeDistribution: Concordium_V2_TransactionFeeDistribution? = nil
    var _gasRewards: Concordium_V2_GasRewards? = nil
    var _foundationAccount: Concordium_V2_AccountAddress? = nil
    var _minimumThresholdForBaking: Concordium_V2_Amount? = nil
    var _rootKeys: Concordium_V2_HigherLevelKeys? = nil
    var _level1Keys: Concordium_V2_HigherLevelKeys? = nil
    var _level2Keys: Concordium_V2_AuthorizationsV0? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _electionDifficulty = source._electionDifficulty
      _euroPerEnergy = source._euroPerEnergy
      _microCcdPerEuro = source._microCcdPerEuro
      _bakerCooldownEpochs = source._bakerCooldownEpochs
      _accountCreationLimit = source._accountCreationLimit
      _mintDistribution = source._mintDistribution
      _transactionFeeDistribution = source._transactionFeeDistribution
      _gasRewards = source._gasRewards
      _foundationAccount = source._foundationAccount
      _minimumThresholdForBaking = source._minimumThresholdForBaking
      _rootKeys = source._rootKeys
      _level1Keys = source._level1Keys
      _level2Keys = source._level2Keys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._electionDifficulty) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._euroPerEnergy) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._microCcdPerEuro) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._bakerCooldownEpochs) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._accountCreationLimit) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._mintDistribution) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._transactionFeeDistribution) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._gasRewards) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._foundationAccount) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._minimumThresholdForBaking) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._rootKeys) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._level1Keys) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._level2Keys) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._electionDifficulty {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._euroPerEnergy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._microCcdPerEuro {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._bakerCooldownEpochs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._accountCreationLimit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._mintDistribution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._transactionFeeDistribution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._gasRewards {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._foundationAccount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._minimumThresholdForBaking {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._rootKeys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._level1Keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._level2Keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ChainParametersV0, rhs: Concordium_V2_ChainParametersV0) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._electionDifficulty != rhs_storage._electionDifficulty {return false}
        if _storage._euroPerEnergy != rhs_storage._euroPerEnergy {return false}
        if _storage._microCcdPerEuro != rhs_storage._microCcdPerEuro {return false}
        if _storage._bakerCooldownEpochs != rhs_storage._bakerCooldownEpochs {return false}
        if _storage._accountCreationLimit != rhs_storage._accountCreationLimit {return false}
        if _storage._mintDistribution != rhs_storage._mintDistribution {return false}
        if _storage._transactionFeeDistribution != rhs_storage._transactionFeeDistribution {return false}
        if _storage._gasRewards != rhs_storage._gasRewards {return false}
        if _storage._foundationAccount != rhs_storage._foundationAccount {return false}
        if _storage._minimumThresholdForBaking != rhs_storage._minimumThresholdForBaking {return false}
        if _storage._rootKeys != rhs_storage._rootKeys {return false}
        if _storage._level1Keys != rhs_storage._level1Keys {return false}
        if _storage._level2Keys != rhs_storage._level2Keys {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ChainParametersV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainParametersV1"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "election_difficulty"),
    2: .standard(proto: "euro_per_energy"),
    3: .standard(proto: "micro_ccd_per_euro"),
    4: .standard(proto: "cooldown_parameters"),
    5: .standard(proto: "time_parameters"),
    6: .standard(proto: "account_creation_limit"),
    7: .standard(proto: "mint_distribution"),
    8: .standard(proto: "transaction_fee_distribution"),
    9: .standard(proto: "gas_rewards"),
    10: .standard(proto: "foundation_account"),
    11: .standard(proto: "pool_parameters"),
    12: .standard(proto: "root_keys"),
    13: .standard(proto: "level1_keys"),
    14: .standard(proto: "level2_keys"),
  ]

  fileprivate class _StorageClass {
    var _electionDifficulty: Concordium_V2_ElectionDifficulty? = nil
    var _euroPerEnergy: Concordium_V2_ExchangeRate? = nil
    var _microCcdPerEuro: Concordium_V2_ExchangeRate? = nil
    var _cooldownParameters: Concordium_V2_CooldownParametersCpv1? = nil
    var _timeParameters: Concordium_V2_TimeParametersCpv1? = nil
    var _accountCreationLimit: Concordium_V2_CredentialsPerBlockLimit? = nil
    var _mintDistribution: Concordium_V2_MintDistributionCpv1? = nil
    var _transactionFeeDistribution: Concordium_V2_TransactionFeeDistribution? = nil
    var _gasRewards: Concordium_V2_GasRewards? = nil
    var _foundationAccount: Concordium_V2_AccountAddress? = nil
    var _poolParameters: Concordium_V2_PoolParametersCpv1? = nil
    var _rootKeys: Concordium_V2_HigherLevelKeys? = nil
    var _level1Keys: Concordium_V2_HigherLevelKeys? = nil
    var _level2Keys: Concordium_V2_AuthorizationsV1? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _electionDifficulty = source._electionDifficulty
      _euroPerEnergy = source._euroPerEnergy
      _microCcdPerEuro = source._microCcdPerEuro
      _cooldownParameters = source._cooldownParameters
      _timeParameters = source._timeParameters
      _accountCreationLimit = source._accountCreationLimit
      _mintDistribution = source._mintDistribution
      _transactionFeeDistribution = source._transactionFeeDistribution
      _gasRewards = source._gasRewards
      _foundationAccount = source._foundationAccount
      _poolParameters = source._poolParameters
      _rootKeys = source._rootKeys
      _level1Keys = source._level1Keys
      _level2Keys = source._level2Keys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._electionDifficulty) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._euroPerEnergy) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._microCcdPerEuro) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._cooldownParameters) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._timeParameters) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._accountCreationLimit) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._mintDistribution) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._transactionFeeDistribution) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._gasRewards) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._foundationAccount) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._poolParameters) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._rootKeys) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._level1Keys) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._level2Keys) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._electionDifficulty {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._euroPerEnergy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._microCcdPerEuro {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._cooldownParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._timeParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._accountCreationLimit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._mintDistribution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._transactionFeeDistribution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._gasRewards {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._foundationAccount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._poolParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._rootKeys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._level1Keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._level2Keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ChainParametersV1, rhs: Concordium_V2_ChainParametersV1) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._electionDifficulty != rhs_storage._electionDifficulty {return false}
        if _storage._euroPerEnergy != rhs_storage._euroPerEnergy {return false}
        if _storage._microCcdPerEuro != rhs_storage._microCcdPerEuro {return false}
        if _storage._cooldownParameters != rhs_storage._cooldownParameters {return false}
        if _storage._timeParameters != rhs_storage._timeParameters {return false}
        if _storage._accountCreationLimit != rhs_storage._accountCreationLimit {return false}
        if _storage._mintDistribution != rhs_storage._mintDistribution {return false}
        if _storage._transactionFeeDistribution != rhs_storage._transactionFeeDistribution {return false}
        if _storage._gasRewards != rhs_storage._gasRewards {return false}
        if _storage._foundationAccount != rhs_storage._foundationAccount {return false}
        if _storage._poolParameters != rhs_storage._poolParameters {return false}
        if _storage._rootKeys != rhs_storage._rootKeys {return false}
        if _storage._level1Keys != rhs_storage._level1Keys {return false}
        if _storage._level2Keys != rhs_storage._level2Keys {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ChainParametersV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainParametersV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consensus_parameters"),
    2: .standard(proto: "euro_per_energy"),
    3: .standard(proto: "micro_ccd_per_euro"),
    4: .standard(proto: "cooldown_parameters"),
    5: .standard(proto: "time_parameters"),
    6: .standard(proto: "account_creation_limit"),
    7: .standard(proto: "mint_distribution"),
    8: .standard(proto: "transaction_fee_distribution"),
    9: .standard(proto: "gas_rewards"),
    10: .standard(proto: "foundation_account"),
    11: .standard(proto: "pool_parameters"),
    12: .standard(proto: "root_keys"),
    13: .standard(proto: "level1_keys"),
    14: .standard(proto: "level2_keys"),
    15: .standard(proto: "finalization_committee_parameters"),
  ]

  fileprivate class _StorageClass {
    var _consensusParameters: Concordium_V2_ConsensusParametersV1? = nil
    var _euroPerEnergy: Concordium_V2_ExchangeRate? = nil
    var _microCcdPerEuro: Concordium_V2_ExchangeRate? = nil
    var _cooldownParameters: Concordium_V2_CooldownParametersCpv1? = nil
    var _timeParameters: Concordium_V2_TimeParametersCpv1? = nil
    var _accountCreationLimit: Concordium_V2_CredentialsPerBlockLimit? = nil
    var _mintDistribution: Concordium_V2_MintDistributionCpv1? = nil
    var _transactionFeeDistribution: Concordium_V2_TransactionFeeDistribution? = nil
    var _gasRewards: Concordium_V2_GasRewardsCpv2? = nil
    var _foundationAccount: Concordium_V2_AccountAddress? = nil
    var _poolParameters: Concordium_V2_PoolParametersCpv1? = nil
    var _rootKeys: Concordium_V2_HigherLevelKeys? = nil
    var _level1Keys: Concordium_V2_HigherLevelKeys? = nil
    var _level2Keys: Concordium_V2_AuthorizationsV1? = nil
    var _finalizationCommitteeParameters: Concordium_V2_FinalizationCommitteeParameters? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _consensusParameters = source._consensusParameters
      _euroPerEnergy = source._euroPerEnergy
      _microCcdPerEuro = source._microCcdPerEuro
      _cooldownParameters = source._cooldownParameters
      _timeParameters = source._timeParameters
      _accountCreationLimit = source._accountCreationLimit
      _mintDistribution = source._mintDistribution
      _transactionFeeDistribution = source._transactionFeeDistribution
      _gasRewards = source._gasRewards
      _foundationAccount = source._foundationAccount
      _poolParameters = source._poolParameters
      _rootKeys = source._rootKeys
      _level1Keys = source._level1Keys
      _level2Keys = source._level2Keys
      _finalizationCommitteeParameters = source._finalizationCommitteeParameters
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._consensusParameters) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._euroPerEnergy) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._microCcdPerEuro) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._cooldownParameters) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._timeParameters) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._accountCreationLimit) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._mintDistribution) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._transactionFeeDistribution) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._gasRewards) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._foundationAccount) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._poolParameters) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._rootKeys) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._level1Keys) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._level2Keys) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._finalizationCommitteeParameters) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._consensusParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._euroPerEnergy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._microCcdPerEuro {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._cooldownParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._timeParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._accountCreationLimit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._mintDistribution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._transactionFeeDistribution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._gasRewards {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._foundationAccount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._poolParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._rootKeys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._level1Keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._level2Keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._finalizationCommitteeParameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ChainParametersV2, rhs: Concordium_V2_ChainParametersV2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._consensusParameters != rhs_storage._consensusParameters {return false}
        if _storage._euroPerEnergy != rhs_storage._euroPerEnergy {return false}
        if _storage._microCcdPerEuro != rhs_storage._microCcdPerEuro {return false}
        if _storage._cooldownParameters != rhs_storage._cooldownParameters {return false}
        if _storage._timeParameters != rhs_storage._timeParameters {return false}
        if _storage._accountCreationLimit != rhs_storage._accountCreationLimit {return false}
        if _storage._mintDistribution != rhs_storage._mintDistribution {return false}
        if _storage._transactionFeeDistribution != rhs_storage._transactionFeeDistribution {return false}
        if _storage._gasRewards != rhs_storage._gasRewards {return false}
        if _storage._foundationAccount != rhs_storage._foundationAccount {return false}
        if _storage._poolParameters != rhs_storage._poolParameters {return false}
        if _storage._rootKeys != rhs_storage._rootKeys {return false}
        if _storage._level1Keys != rhs_storage._level1Keys {return false}
        if _storage._level2Keys != rhs_storage._level2Keys {return false}
        if _storage._finalizationCommitteeParameters != rhs_storage._finalizationCommitteeParameters {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_ChainParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "v0"),
    2: .same(proto: "v1"),
    3: .same(proto: "v2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_ChainParametersV0?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .v0(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .v0(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_ChainParametersV1?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .v1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .v1(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_ChainParametersV2?
        var hadOneofValue = false
        if let current = self.parameters {
          hadOneofValue = true
          if case .v2(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.parameters = .v2(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.parameters {
    case .v0?: try {
      guard case .v0(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .v1?: try {
      guard case .v1(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .v2?: try {
      guard case .v2(let v)? = self.parameters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_ChainParameters, rhs: Concordium_V2_ChainParameters) -> Bool {
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_FinalizationSummaryParty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalizationSummaryParty"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "baker"),
    2: .same(proto: "weight"),
    3: .same(proto: "signed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baker) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.weight) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.signed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.weight != 0 {
      try visitor.visitSingularUInt64Field(value: self.weight, fieldNumber: 2)
    }
    if self.signed != false {
      try visitor.visitSingularBoolField(value: self.signed, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_FinalizationSummaryParty, rhs: Concordium_V2_FinalizationSummaryParty) -> Bool {
    if lhs._baker != rhs._baker {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.signed != rhs.signed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_FinalizationIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalizationIndex"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_FinalizationIndex, rhs: Concordium_V2_FinalizationIndex) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_FinalizationSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalizationSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
    2: .same(proto: "index"),
    3: .same(proto: "delay"),
    4: .same(proto: "finalizers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._block) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._index) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._delay) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.finalizers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._block {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._index {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._delay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.finalizers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.finalizers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_FinalizationSummary, rhs: Concordium_V2_FinalizationSummary) -> Bool {
    if lhs._block != rhs._block {return false}
    if lhs._index != rhs._index {return false}
    if lhs._delay != rhs._delay {return false}
    if lhs.finalizers != rhs.finalizers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockFinalizationSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockFinalizationSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "none"),
    2: .same(proto: "record"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_Empty?
        var hadOneofValue = false
        if let current = self.summary {
          hadOneofValue = true
          if case .none(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.summary = .none(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_FinalizationSummary?
        var hadOneofValue = false
        if let current = self.summary {
          hadOneofValue = true
          if case .record(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.summary = .record(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.summary {
    case .none?: try {
      guard case .none(let v)? = self.summary else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .record?: try {
      guard case .record(let v)? = self.summary else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockFinalizationSummary, rhs: Concordium_V2_BlockFinalizationSummary) -> Bool {
    if lhs.summary != rhs.summary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "account_transaction"),
    3: .standard(proto: "credential_deployment"),
    4: .standard(proto: "update_instruction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._hash) }()
      case 2: try {
        var v: Concordium_V2_AccountTransaction?
        var hadOneofValue = false
        if let current = self.blockItem {
          hadOneofValue = true
          if case .accountTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blockItem = .accountTransaction(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_CredentialDeployment?
        var hadOneofValue = false
        if let current = self.blockItem {
          hadOneofValue = true
          if case .credentialDeployment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blockItem = .credentialDeployment(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_UpdateInstruction?
        var hadOneofValue = false
        if let current = self.blockItem {
          hadOneofValue = true
          if case .updateInstruction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.blockItem = .updateInstruction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.blockItem {
    case .accountTransaction?: try {
      guard case .accountTransaction(let v)? = self.blockItem else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .credentialDeployment?: try {
      guard case .credentialDeployment(let v)? = self.blockItem else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .updateInstruction?: try {
      guard case .updateInstruction(let v)? = self.blockItem else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockItem, rhs: Concordium_V2_BlockItem) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs.blockItem != rhs.blockItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BakerRewardPeriodInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BakerRewardPeriodInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "baker"),
    2: .standard(proto: "effective_stake"),
    3: .standard(proto: "commission_rates"),
    4: .standard(proto: "equity_capital"),
    5: .standard(proto: "delegated_capital"),
    6: .standard(proto: "is_finalizer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baker) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._effectiveStake) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._commissionRates) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._equityCapital) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._delegatedCapital) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isFinalizer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._baker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._effectiveStake {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._commissionRates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._equityCapital {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._delegatedCapital {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.isFinalizer != false {
      try visitor.visitSingularBoolField(value: self.isFinalizer, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BakerRewardPeriodInfo, rhs: Concordium_V2_BakerRewardPeriodInfo) -> Bool {
    if lhs._baker != rhs._baker {return false}
    if lhs._effectiveStake != rhs._effectiveStake {return false}
    if lhs._commissionRates != rhs._commissionRates {return false}
    if lhs._equityCapital != rhs._equityCapital {return false}
    if lhs._delegatedCapital != rhs._delegatedCapital {return false}
    if lhs.isFinalizer != rhs.isFinalizer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_QuorumSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuorumSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_QuorumSignature, rhs: Concordium_V2_QuorumSignature) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_QuorumCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QuorumCertificate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_hash"),
    2: .same(proto: "round"),
    3: .same(proto: "epoch"),
    4: .standard(proto: "aggregate_signature"),
    5: .same(proto: "signatories"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blockHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._round) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._epoch) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._aggregateSignature) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.signatories) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blockHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._round {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._epoch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._aggregateSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.signatories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signatories, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_QuorumCertificate, rhs: Concordium_V2_QuorumCertificate) -> Bool {
    if lhs._blockHash != rhs._blockHash {return false}
    if lhs._round != rhs._round {return false}
    if lhs._epoch != rhs._epoch {return false}
    if lhs._aggregateSignature != rhs._aggregateSignature {return false}
    if lhs.signatories != rhs.signatories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_FinalizerRound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalizerRound"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "round"),
    2: .same(proto: "finalizers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._round) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.finalizers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._round {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.finalizers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.finalizers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_FinalizerRound, rhs: Concordium_V2_FinalizerRound) -> Bool {
    if lhs._round != rhs._round {return false}
    if lhs.finalizers != rhs.finalizers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_TimeoutSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeoutSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_TimeoutSignature, rhs: Concordium_V2_TimeoutSignature) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_TimeoutCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimeoutCertificate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "round"),
    2: .standard(proto: "min_epoch"),
    3: .standard(proto: "qc_rounds_first_epoch"),
    4: .standard(proto: "qc_rounds_second_epoch"),
    5: .standard(proto: "aggregate_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._round) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._minEpoch) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.qcRoundsFirstEpoch) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.qcRoundsSecondEpoch) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._aggregateSignature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._round {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._minEpoch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.qcRoundsFirstEpoch.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.qcRoundsFirstEpoch, fieldNumber: 3)
    }
    if !self.qcRoundsSecondEpoch.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.qcRoundsSecondEpoch, fieldNumber: 4)
    }
    try { if let v = self._aggregateSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_TimeoutCertificate, rhs: Concordium_V2_TimeoutCertificate) -> Bool {
    if lhs._round != rhs._round {return false}
    if lhs._minEpoch != rhs._minEpoch {return false}
    if lhs.qcRoundsFirstEpoch != rhs.qcRoundsFirstEpoch {return false}
    if lhs.qcRoundsSecondEpoch != rhs.qcRoundsSecondEpoch {return false}
    if lhs._aggregateSignature != rhs._aggregateSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_SuccessorProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SuccessorProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_SuccessorProof, rhs: Concordium_V2_SuccessorProof) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_EpochFinalizationEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EpochFinalizationEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "finalized_qc"),
    2: .standard(proto: "successor_qc"),
    3: .standard(proto: "successor_proof"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._finalizedQc) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._successorQc) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._successorProof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._finalizedQc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._successorQc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._successorProof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_EpochFinalizationEntry, rhs: Concordium_V2_EpochFinalizationEntry) -> Bool {
    if lhs._finalizedQc != rhs._finalizedQc {return false}
    if lhs._successorQc != rhs._successorQc {return false}
    if lhs._successorProof != rhs._successorProof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_BlockCertificates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockCertificates"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quorum_certificate"),
    2: .standard(proto: "timeout_certificate"),
    3: .standard(proto: "epoch_finalization_entry"),
  ]

  fileprivate class _StorageClass {
    var _quorumCertificate: Concordium_V2_QuorumCertificate? = nil
    var _timeoutCertificate: Concordium_V2_TimeoutCertificate? = nil
    var _epochFinalizationEntry: Concordium_V2_EpochFinalizationEntry? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _quorumCertificate = source._quorumCertificate
      _timeoutCertificate = source._timeoutCertificate
      _epochFinalizationEntry = source._epochFinalizationEntry
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._quorumCertificate) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._timeoutCertificate) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._epochFinalizationEntry) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._quorumCertificate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._timeoutCertificate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._epochFinalizationEntry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_BlockCertificates, rhs: Concordium_V2_BlockCertificates) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._quorumCertificate != rhs_storage._quorumCertificate {return false}
        if _storage._timeoutCertificate != rhs_storage._timeoutCertificate {return false}
        if _storage._epochFinalizationEntry != rhs_storage._epochFinalizationEntry {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_WinningBaker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WinningBaker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "round"),
    2: .same(proto: "winner"),
    3: .same(proto: "present"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._round) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._winner) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.present) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._round {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._winner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.present != false {
      try visitor.visitSingularBoolField(value: self.present, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_WinningBaker, rhs: Concordium_V2_WinningBaker) -> Bool {
    if lhs._round != rhs._round {return false}
    if lhs._winner != rhs._winner {return false}
    if lhs.present != rhs.present {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DryRunRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "load_block_state"),
    2: .standard(proto: "state_query"),
    3: .standard(proto: "state_operation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_BlockHashInput?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .loadBlockState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .loadBlockState(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_DryRunStateQuery?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .stateQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .stateQuery(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_DryRunStateOperation?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .stateOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .stateOperation(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .loadBlockState?: try {
      guard case .loadBlockState(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stateQuery?: try {
      guard case .stateQuery(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .stateOperation?: try {
      guard case .stateOperation(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunRequest, rhs: Concordium_V2_DryRunRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunStateQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DryRunStateQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_account_info"),
    2: .standard(proto: "get_instance_info"),
    3: .standard(proto: "invoke_instance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_AccountIdentifierInput?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .getAccountInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .getAccountInfo(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_ContractAddress?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .getInstanceInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .getInstanceInfo(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_DryRunInvokeInstance?
        var hadOneofValue = false
        if let current = self.query {
          hadOneofValue = true
          if case .invokeInstance(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.query = .invokeInstance(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.query {
    case .getAccountInfo?: try {
      guard case .getAccountInfo(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getInstanceInfo?: try {
      guard case .getInstanceInfo(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .invokeInstance?: try {
      guard case .invokeInstance(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunStateQuery, rhs: Concordium_V2_DryRunStateQuery) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunInvokeInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DryRunInvokeInstance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invoker"),
    2: .same(proto: "instance"),
    3: .same(proto: "amount"),
    4: .same(proto: "entrypoint"),
    5: .same(proto: "parameter"),
    6: .same(proto: "energy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._invoker) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._entrypoint) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._parameter) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._energy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._invoker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._entrypoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._parameter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._energy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunInvokeInstance, rhs: Concordium_V2_DryRunInvokeInstance) -> Bool {
    if lhs._invoker != rhs._invoker {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._entrypoint != rhs._entrypoint {return false}
    if lhs._parameter != rhs._parameter {return false}
    if lhs._energy != rhs._energy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunStateOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DryRunStateOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_timestamp"),
    2: .standard(proto: "mint_to_account"),
    3: .standard(proto: "run_transaction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_Timestamp?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .setTimestamp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .setTimestamp(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_DryRunMintToAccount?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .mintToAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .mintToAccount(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_DryRunTransaction?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .runTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .runTransaction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.operation {
    case .setTimestamp?: try {
      guard case .setTimestamp(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .mintToAccount?: try {
      guard case .mintToAccount(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .runTransaction?: try {
      guard case .runTransaction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunStateOperation, rhs: Concordium_V2_DryRunStateOperation) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunMintToAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DryRunMintToAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunMintToAccount, rhs: Concordium_V2_DryRunMintToAccount) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DryRunTransaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "energy_amount"),
    3: .same(proto: "payload"),
    4: .same(proto: "signatures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sender) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._energyAmount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.signatures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._energyAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signatures, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunTransaction, rhs: Concordium_V2_DryRunTransaction) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs._energyAmount != rhs._energyAmount {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DryRunSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "credential"),
    2: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.credential) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.credential != 0 {
      try visitor.visitSingularUInt32Field(value: self.credential, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularUInt32Field(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunSignature, rhs: Concordium_V2_DryRunSignature) -> Bool {
    if lhs.credential != rhs.credential {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DryRunResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "success"),
    3: .standard(proto: "quota_remaining"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_DryRunErrorResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .error(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_DryRunSuccessResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .success(v)
        }
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._quotaRemaining) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .error?: try {
      guard case .error(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .success?: try {
      guard case .success(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._quotaRemaining {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunResponse, rhs: Concordium_V2_DryRunResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs._quotaRemaining != rhs._quotaRemaining {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunErrorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DryRunErrorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "no_state"),
    2: .standard(proto: "block_not_found"),
    3: .standard(proto: "account_not_found"),
    4: .standard(proto: "instance_not_found"),
    5: .standard(proto: "amount_over_limit"),
    6: .standard(proto: "balance_insufficient"),
    8: .standard(proto: "energy_insufficient"),
    9: .standard(proto: "invoke_failed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_DryRunErrorResponse.NoState?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .noState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .noState(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_DryRunErrorResponse.BlockNotFound?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .blockNotFound(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .blockNotFound(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_DryRunErrorResponse.AccountNotFound?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .accountNotFound(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .accountNotFound(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_DryRunErrorResponse.InstanceNotFound?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .instanceNotFound(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .instanceNotFound(v)
        }
      }()
      case 5: try {
        var v: Concordium_V2_DryRunErrorResponse.AmountOverLimit?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .amountOverLimit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .amountOverLimit(v)
        }
      }()
      case 6: try {
        var v: Concordium_V2_DryRunErrorResponse.BalanceInsufficient?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .balanceInsufficient(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .balanceInsufficient(v)
        }
      }()
      case 8: try {
        var v: Concordium_V2_DryRunErrorResponse.EnergyInsufficient?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .energyInsufficient(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .energyInsufficient(v)
        }
      }()
      case 9: try {
        var v: Concordium_V2_DryRunErrorResponse.InvokeFailure?
        var hadOneofValue = false
        if let current = self.error {
          hadOneofValue = true
          if case .invokeFailed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.error = .invokeFailed(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.error {
    case .noState?: try {
      guard case .noState(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .blockNotFound?: try {
      guard case .blockNotFound(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .accountNotFound?: try {
      guard case .accountNotFound(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .instanceNotFound?: try {
      guard case .instanceNotFound(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .amountOverLimit?: try {
      guard case .amountOverLimit(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .balanceInsufficient?: try {
      guard case .balanceInsufficient(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .energyInsufficient?: try {
      guard case .energyInsufficient(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .invokeFailed?: try {
      guard case .invokeFailed(let v)? = self.error else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunErrorResponse, rhs: Concordium_V2_DryRunErrorResponse) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunErrorResponse.NoState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DryRunErrorResponse.protoMessageName + ".NoState"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunErrorResponse.NoState, rhs: Concordium_V2_DryRunErrorResponse.NoState) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunErrorResponse.BlockNotFound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DryRunErrorResponse.protoMessageName + ".BlockNotFound"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunErrorResponse.BlockNotFound, rhs: Concordium_V2_DryRunErrorResponse.BlockNotFound) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunErrorResponse.AccountNotFound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DryRunErrorResponse.protoMessageName + ".AccountNotFound"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunErrorResponse.AccountNotFound, rhs: Concordium_V2_DryRunErrorResponse.AccountNotFound) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunErrorResponse.InstanceNotFound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DryRunErrorResponse.protoMessageName + ".InstanceNotFound"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunErrorResponse.InstanceNotFound, rhs: Concordium_V2_DryRunErrorResponse.InstanceNotFound) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunErrorResponse.AmountOverLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DryRunErrorResponse.protoMessageName + ".AmountOverLimit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "amount_limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._amountLimit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amountLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunErrorResponse.AmountOverLimit, rhs: Concordium_V2_DryRunErrorResponse.AmountOverLimit) -> Bool {
    if lhs._amountLimit != rhs._amountLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunErrorResponse.BalanceInsufficient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DryRunErrorResponse.protoMessageName + ".BalanceInsufficient"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "required_amount"),
    2: .standard(proto: "available_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._requiredAmount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._availableAmount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requiredAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._availableAmount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunErrorResponse.BalanceInsufficient, rhs: Concordium_V2_DryRunErrorResponse.BalanceInsufficient) -> Bool {
    if lhs._requiredAmount != rhs._requiredAmount {return false}
    if lhs._availableAmount != rhs._availableAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunErrorResponse.EnergyInsufficient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DryRunErrorResponse.protoMessageName + ".EnergyInsufficient"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "energy_required"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._energyRequired) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._energyRequired {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunErrorResponse.EnergyInsufficient, rhs: Concordium_V2_DryRunErrorResponse.EnergyInsufficient) -> Bool {
    if lhs._energyRequired != rhs._energyRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunErrorResponse.InvokeFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DryRunErrorResponse.protoMessageName + ".InvokeFailure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "return_value"),
    2: .standard(proto: "used_energy"),
    3: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._returnValue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._usedEnergy) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._returnValue {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._usedEnergy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._reason {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunErrorResponse.InvokeFailure, rhs: Concordium_V2_DryRunErrorResponse.InvokeFailure) -> Bool {
    if lhs._returnValue != rhs._returnValue {return false}
    if lhs._usedEnergy != rhs._usedEnergy {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunSuccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DryRunSuccessResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "block_state_loaded"),
    2: .standard(proto: "account_info"),
    3: .standard(proto: "instance_info"),
    4: .standard(proto: "invoke_succeeded"),
    5: .standard(proto: "timestamp_set"),
    6: .standard(proto: "minted_to_account"),
    7: .standard(proto: "transaction_executed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Concordium_V2_DryRunSuccessResponse.BlockStateLoaded?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .blockStateLoaded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .blockStateLoaded(v)
        }
      }()
      case 2: try {
        var v: Concordium_V2_AccountInfo?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .accountInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .accountInfo(v)
        }
      }()
      case 3: try {
        var v: Concordium_V2_InstanceInfo?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .instanceInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .instanceInfo(v)
        }
      }()
      case 4: try {
        var v: Concordium_V2_DryRunSuccessResponse.InvokeSuccess?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .invokeSucceeded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .invokeSucceeded(v)
        }
      }()
      case 5: try {
        var v: Concordium_V2_DryRunSuccessResponse.TimestampSet?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .timestampSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .timestampSet(v)
        }
      }()
      case 6: try {
        var v: Concordium_V2_DryRunSuccessResponse.MintedToAccount?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .mintedToAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .mintedToAccount(v)
        }
      }()
      case 7: try {
        var v: Concordium_V2_DryRunSuccessResponse.TransactionExecuted?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .transactionExecuted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .transactionExecuted(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .blockStateLoaded?: try {
      guard case .blockStateLoaded(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .accountInfo?: try {
      guard case .accountInfo(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .instanceInfo?: try {
      guard case .instanceInfo(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .invokeSucceeded?: try {
      guard case .invokeSucceeded(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .timestampSet?: try {
      guard case .timestampSet(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .mintedToAccount?: try {
      guard case .mintedToAccount(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .transactionExecuted?: try {
      guard case .transactionExecuted(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunSuccessResponse, rhs: Concordium_V2_DryRunSuccessResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunSuccessResponse.BlockStateLoaded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DryRunSuccessResponse.protoMessageName + ".BlockStateLoaded"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_timestamp"),
    2: .standard(proto: "block_hash"),
    3: .standard(proto: "protocol_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currentTimestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._blockHash) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.protocolVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currentTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._blockHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.protocolVersion != .protocolVersion1 {
      try visitor.visitSingularEnumField(value: self.protocolVersion, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunSuccessResponse.BlockStateLoaded, rhs: Concordium_V2_DryRunSuccessResponse.BlockStateLoaded) -> Bool {
    if lhs._currentTimestamp != rhs._currentTimestamp {return false}
    if lhs._blockHash != rhs._blockHash {return false}
    if lhs.protocolVersion != rhs.protocolVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunSuccessResponse.TimestampSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DryRunSuccessResponse.protoMessageName + ".TimestampSet"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunSuccessResponse.TimestampSet, rhs: Concordium_V2_DryRunSuccessResponse.TimestampSet) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunSuccessResponse.MintedToAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DryRunSuccessResponse.protoMessageName + ".MintedToAccount"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunSuccessResponse.MintedToAccount, rhs: Concordium_V2_DryRunSuccessResponse.MintedToAccount) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunSuccessResponse.TransactionExecuted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DryRunSuccessResponse.protoMessageName + ".TransactionExecuted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "energy_cost"),
    2: .same(proto: "details"),
    3: .standard(proto: "return_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._energyCost) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._returnValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._energyCost {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._returnValue {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunSuccessResponse.TransactionExecuted, rhs: Concordium_V2_DryRunSuccessResponse.TransactionExecuted) -> Bool {
    if lhs._energyCost != rhs._energyCost {return false}
    if lhs._details != rhs._details {return false}
    if lhs._returnValue != rhs._returnValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Concordium_V2_DryRunSuccessResponse.InvokeSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Concordium_V2_DryRunSuccessResponse.protoMessageName + ".InvokeSuccess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "return_value"),
    2: .standard(proto: "used_energy"),
    3: .same(proto: "effects"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._returnValue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._usedEnergy) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.effects) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._returnValue {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._usedEnergy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.effects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.effects, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Concordium_V2_DryRunSuccessResponse.InvokeSuccess, rhs: Concordium_V2_DryRunSuccessResponse.InvokeSuccess) -> Bool {
    if lhs._returnValue != rhs._returnValue {return false}
    if lhs._usedEnergy != rhs._usedEnergy {return false}
    if lhs.effects != rhs.effects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
